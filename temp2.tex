% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{}

\begin{document}

\hypertarget{head}{%
\section{Head}\label{head}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"bits/stdc++.h"}
 
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ std;}
   
\KeywordTok{typedef} \DataTypeTok{unsigned} \DataTypeTok{long} \DataTypeTok{long}\NormalTok{ ULL;}
\KeywordTok{typedef} \DataTypeTok{long} \DataTypeTok{long}\NormalTok{ LL;}
\KeywordTok{typedef}\NormalTok{ pair\textless{}}\DataTypeTok{int}\NormalTok{, }\DataTypeTok{int}\NormalTok{\textgreater{} pr;}
\KeywordTok{typedef}\NormalTok{ pair\textless{}LL, LL\textgreater{} lpr;}
\KeywordTok{typedef}\NormalTok{ pair\textless{}}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{double}\NormalTok{\textgreater{} dpr;}
\KeywordTok{typedef}\NormalTok{ pair\textless{}}\DataTypeTok{long} \DataTypeTok{double}\NormalTok{, }\DataTypeTok{long} \DataTypeTok{double}\NormalTok{\textgreater{} ldpr;}
\KeywordTok{typedef} \DataTypeTok{double}\NormalTok{ db;}
\KeywordTok{typedef} \DataTypeTok{long} \DataTypeTok{double}\NormalTok{ ld;}
\CommentTok{// typedef complex\textless{}double\textgreater{} cp;}
\CommentTok{// typedef pair\textless{}ld,ld\textgreater{} pt;}
   
\PreprocessorTok{\#define dbgs}\NormalTok{(x)}\PreprocessorTok{ \#}\NormalTok{x}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\StringTok{" = "}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\NormalTok{x}
\PreprocessorTok{\#define dbgs2}\NormalTok{(x,}\PreprocessorTok{ }\NormalTok{y)}\PreprocessorTok{ }\NormalTok{dbgs(x)}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\StringTok{", "}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\NormalTok{dbgs(y)}
\PreprocessorTok{\#define dbgs3}\NormalTok{(x,}\PreprocessorTok{ }\NormalTok{y,}\PreprocessorTok{ }\NormalTok{z)}\PreprocessorTok{ }\NormalTok{dbgs2(x,}\PreprocessorTok{ }\NormalTok{y)}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\StringTok{", "}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\NormalTok{dbgs(z)}
\PreprocessorTok{\#define dbgs4}\NormalTok{(w,}\PreprocessorTok{ }\NormalTok{x,}\PreprocessorTok{ }\NormalTok{y,}\PreprocessorTok{ }\NormalTok{z)}\PreprocessorTok{ }\NormalTok{dbgs3(w,}\PreprocessorTok{ }\NormalTok{x,}\PreprocessorTok{ }\NormalTok{y)}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\StringTok{", "}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\NormalTok{dbgs(z)}
  
\PreprocessorTok{\#define mst}\NormalTok{(s,}\PreprocessorTok{ }\NormalTok{x)}\PreprocessorTok{ }\NormalTok{memset(s,}\PreprocessorTok{ }\NormalTok{x,}\PreprocessorTok{ }\KeywordTok{sizeof}\NormalTok{(s))}
\PreprocessorTok{\#define fi }\NormalTok{first}
\PreprocessorTok{\#define se }\NormalTok{second}
\PreprocessorTok{\#define pb }\NormalTok{push\_back}
\PreprocessorTok{\#define pf }\NormalTok{push\_front}
\PreprocessorTok{\#define ppb }\NormalTok{pop\_back}
\PreprocessorTok{\#define ppf }\NormalTok{pop\_front}
\PreprocessorTok{\#define mp }\NormalTok{make\_pair}
\PreprocessorTok{\#define all}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{x.begin(),}\PreprocessorTok{ }\NormalTok{x.end()}
\PreprocessorTok{\#define unq}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{x.erase(unique(x.begin(),}\PreprocessorTok{ }\NormalTok{x.end()),}\PreprocessorTok{ }\NormalTok{x.end())}
\PreprocessorTok{\#define rg }\AttributeTok{register}
\PreprocessorTok{\#define fp}\NormalTok{(i,}\PreprocessorTok{ }\NormalTok{a,}\PreprocessorTok{ }\NormalTok{b)}\PreprocessorTok{ }\ControlFlowTok{for}\PreprocessorTok{ }\NormalTok{(rg}\PreprocessorTok{ }\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{(a),}\PreprocessorTok{ }\NormalTok{I}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{(b)}\PreprocessorTok{ }\NormalTok{+}\PreprocessorTok{ }\DecValTok{1}\NormalTok{;}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{\textless{}}\PreprocessorTok{ }\NormalTok{I;}\PreprocessorTok{ }\NormalTok{++i)}
\PreprocessorTok{\#define fd}\NormalTok{(i,}\PreprocessorTok{ }\NormalTok{a,}\PreprocessorTok{ }\NormalTok{b)}\PreprocessorTok{ }\ControlFlowTok{for}\PreprocessorTok{ }\NormalTok{(rg}\PreprocessorTok{ }\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{(a),}\PreprocessorTok{ }\NormalTok{I}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{(b){-}}\DecValTok{1}\NormalTok{;}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{\textgreater{}}\PreprocessorTok{ }\NormalTok{I;}\PreprocessorTok{ }\NormalTok{{-}{-}i)}
\PreprocessorTok{\#define ub }\NormalTok{upper\_bound}
\PreprocessorTok{\#define lb }\NormalTok{lower\_bound}
\PreprocessorTok{\#define bitcount }\FunctionTok{\_\_builtin\_popcount}
\PreprocessorTok{\#define sqr}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{((x)*(x))}
  
\PreprocessorTok{\#define go}\NormalTok{(u)}\PreprocessorTok{ }\ControlFlowTok{for}\PreprocessorTok{ }\NormalTok{(rg}\PreprocessorTok{ }\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{pre[u],}\PreprocessorTok{ }\NormalTok{v}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].v;}\PreprocessorTok{ }\NormalTok{i;}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].next,}\PreprocessorTok{ }\NormalTok{v}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].v)}
\PreprocessorTok{\#define gow}\NormalTok{(u)}\PreprocessorTok{ }\ControlFlowTok{for}\PreprocessorTok{ }\NormalTok{(rg}\PreprocessorTok{ }\NormalTok{LL}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{pre[u],}\PreprocessorTok{ }\NormalTok{v}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].v,}\PreprocessorTok{ }\NormalTok{w}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].w;}\PreprocessorTok{ }\NormalTok{i;}\PreprocessorTok{ }\NormalTok{i}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].next,}\PreprocessorTok{ }\NormalTok{v}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].v,}\PreprocessorTok{ }\NormalTok{w}\PreprocessorTok{ }\NormalTok{=}\PreprocessorTok{ }\NormalTok{e[i].w)}
\PreprocessorTok{\#define EDGE}\NormalTok{(N,M)}\PreprocessorTok{ }\KeywordTok{struct}\PreprocessorTok{ }\NormalTok{edge\{}\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{u,v,w,next;\}e[M];}\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{pre[N],edge\_cnt=}\DecValTok{0}\NormalTok{;}\DataTypeTok{void}\PreprocessorTok{ }\NormalTok{addedge(}\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{u,}\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{v,}\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{w=}\DecValTok{0}\NormalTok{)\{edge\_cnt=edge\_cnt+}\DecValTok{1}\NormalTok{,e[edge\_cnt].u=u,e[edge\_cnt].v=v,e[edge\_cnt].w=w,e[edge\_cnt].next=pre[u],pre[u]=edge\_cnt;\}}
\PreprocessorTok{\#define CLEAR\_EDGE}\NormalTok{(N)}\PreprocessorTok{ }\NormalTok{\{edge\_cnt=}\DecValTok{0}\NormalTok{,memset(pre,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{)*(N+}\DecValTok{1}\NormalTok{));\}}
  
\PreprocessorTok{\#define MAXSIZE }\NormalTok{(}\DecValTok{1}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\DecValTok{20}\NormalTok{)}
\PreprocessorTok{\#define isdigit}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{(x}\PreprocessorTok{ }\NormalTok{\textgreater{}=}\PreprocessorTok{ }\CharTok{\textquotesingle{}0\textquotesingle{}}\PreprocessorTok{ }\NormalTok{\&\&}\PreprocessorTok{ }\NormalTok{x}\PreprocessorTok{ }\NormalTok{\textless{}=}\PreprocessorTok{ }\CharTok{\textquotesingle{}9\textquotesingle{}}\NormalTok{)}
  
\PreprocessorTok{\#define MC }\DataTypeTok{int}\PreprocessorTok{ }\NormalTok{\_CASE;scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&\_CASE);fp(case\_num,}\DecValTok{1}\NormalTok{,\_CASE)}
   
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ next\_x[}\DecValTok{8}\NormalTok{] = \{}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, {-}}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, {-}}\DecValTok{1}\NormalTok{, {-}}\DecValTok{1}\NormalTok{\};}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ next\_y[}\DecValTok{8}\NormalTok{] = \{}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, {-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, {-}}\DecValTok{1}\NormalTok{, {-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{\};}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ inf = }\FloatTok{1e9}\NormalTok{+}\DecValTok{5}\NormalTok{;}\CommentTok{//7;}
\AttributeTok{const}\NormalTok{ LL linf = }\FloatTok{1e18}\NormalTok{+}\DecValTok{5}\NormalTok{;}
\AttributeTok{const} \DataTypeTok{double}\NormalTok{ PI = acos({-}}\FloatTok{1.0}\NormalTok{);}
   
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ MAXN = }\DecValTok{81}\NormalTok{;}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ N    = }\FloatTok{2e6}\NormalTok{+}\DecValTok{5}\NormalTok{;}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ fix  = }\DecValTok{500}\NormalTok{*}\DecValTok{500}\NormalTok{+}\DecValTok{5}\NormalTok{;}
 
\PreprocessorTok{\#define mid }\NormalTok{((l+r)/}\DecValTok{2}\NormalTok{)}
\PreprocessorTok{\#define ls }\NormalTok{(cnt\textless{}\textless{}}\DecValTok{1}\NormalTok{)}
\PreprocessorTok{\#define rs }\NormalTok{(cnt\textless{}\textless{}}\DecValTok{1}\NormalTok{|}\DecValTok{1}\NormalTok{)}
 
\CommentTok{// \#define ls(x) ch[x][0]}
\CommentTok{// \#define rs(x) ch[x][1]}
    
\CommentTok{/*{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}head{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}*/}

\DataTypeTok{int}\NormalTok{ work()\{\};}

\CommentTok{// 小数 二分/三分 注意break条件}
\CommentTok{// 浮点运算 sqrt(a\^{}2{-}b\^{}2) 可用 sqrt(a+b)*sqrt(a{-}b) 代替，避免精度问题}
\CommentTok{// long double {-}\textgreater{} \%Lf 别用C11 (C14/16)}
\CommentTok{// 控制位数 cout \textless{}\textless{} setprecision(10) \textless{}\textless{} ans;}
\CommentTok{// reverse vector 注意判空 不然会re}
\CommentTok{// 分块注意维护块上标记 来更新块内数组a[]}
\CommentTok{// vector+lower\_bound常数 \textless{} map/set/(unordered\_map)}
\CommentTok{// map.find不会创建新元素 map[]会 注意空间}
\CommentTok{// 别对指针用memset}
\CommentTok{// 用位运算表示2\^{}n注意加LL 1LL\textless{}\textless{}20}
\CommentTok{// 注意递归爆栈}
\CommentTok{// 注意边界}
\CommentTok{// 注意memset 多组会T}
   
\CommentTok{//\#define ONLINE\_JUDGE}
 
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \CommentTok{// ios::sync\_with\_stdio(false);}
    \CommentTok{// cin.tie(0);}
\PreprocessorTok{\#ifdef ONLINE\_JUDGE}
    \CommentTok{// freopen("triatrip.in", "r",stdin );}
    \CommentTok{// freopen("triatrip.out","w",stdout);}
\PreprocessorTok{\#endif }\CommentTok{// ONLINE\_JUDGE}
\PreprocessorTok{\#ifndef ONLINE\_JUDGE}
    \CommentTok{// gcc 本地扩栈}
    \DataTypeTok{int}\NormalTok{ size = }\DecValTok{512}\NormalTok{ \textless{}\textless{} }\DecValTok{20}\NormalTok{; }\CommentTok{// 512MB  }
    \DataTypeTok{char}\NormalTok{ *p = (}\DataTypeTok{char}\NormalTok{*)malloc(size) + size;  }
    \ExtensionTok{\_\_asm\_\_}\NormalTok{(}\StringTok{"movl \%0, }\SpecialCharTok{\%\%}\StringTok{esp}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{ :: }\StringTok{"r"}\NormalTok{(p)); }
\NormalTok{    freopen(}\StringTok{"input.txt"}\NormalTok{, }\StringTok{"r"}\NormalTok{, stdin);}
    \CommentTok{// freopen("output.txt", "w", stdout);}
\PreprocessorTok{\#endif}
    \CommentTok{// make();}
\NormalTok{    work();}
\PreprocessorTok{\#ifndef ONLINE\_JUDGE}
\NormalTok{    cout \textless{}\textless{} }\StringTok{"time:"}\NormalTok{ \textless{}\textless{} clock() \textless{}\textless{} }\StringTok{"ms"}\NormalTok{ \textless{}\textless{} endl;}
\NormalTok{    freopen(}\StringTok{"CON"}\NormalTok{, }\StringTok{"r"}\NormalTok{, stdin);}
\NormalTok{    freopen(}\StringTok{"CON"}\NormalTok{, }\StringTok{"w"}\NormalTok{, stdout);}
\NormalTok{    system(}\StringTok{"pause"}\NormalTok{);}
\NormalTok{    fflush(stdout);}
\PreprocessorTok{\#endif}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{python}{%
\section{python}\label{python}}

读入

\begin{verbatim}
n,m,k = map(int,raw_input().split())
\end{verbatim}

二维数组

\begin{verbatim}
f = [[0 for i in range(10)] for i in range(10)]
\end{verbatim}

\hypertarget{ux8bfbux5165ux6302}{%
\section{读入挂}\label{ux8bfbux5165ux6302}}

\hypertarget{ux666eux901a}{%
\subsection{普通}\label{ux666eux901a}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ read()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ sum=}\DecValTok{0}\NormalTok{;}\DataTypeTok{char}\NormalTok{ ch=getchar();}
    \ControlFlowTok{while}\NormalTok{(!(ch\textgreater{}=}\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{\&\&ch\textless{}=}\CharTok{\textquotesingle{}9\textquotesingle{}}\NormalTok{))ch=getchar();}
    \ControlFlowTok{while}\NormalTok{(ch\textgreater{}=}\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{\&\&ch\textless{}=}\CharTok{\textquotesingle{}9\textquotesingle{}}\NormalTok{)sum=sum*}\DecValTok{10}\NormalTok{+ch{-}}\DecValTok{48}\NormalTok{,ch=getchar();}
    \ControlFlowTok{return}\NormalTok{ sum;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ out(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
   \ControlFlowTok{if}\NormalTok{(x\textgreater{}}\DecValTok{9}\NormalTok{)out(x/}\DecValTok{10}\NormalTok{);}
\NormalTok{   putchar(x\%}\DecValTok{10}\NormalTok{+}\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux903c}{%
\subsection{二逼}\label{ux4e8cux903c}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// \#define DEBUG 1  //调试开关}
\KeywordTok{struct}\NormalTok{ IO \{}
\PreprocessorTok{\#define MAXSIZE }\NormalTok{(}\DecValTok{1}\PreprocessorTok{ }\NormalTok{\textless{}\textless{}}\PreprocessorTok{ }\DecValTok{20}\NormalTok{)}
\PreprocessorTok{\#define isdigit}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{(x}\PreprocessorTok{ }\NormalTok{\textgreater{}=}\PreprocessorTok{ }\CharTok{\textquotesingle{}0\textquotesingle{}}\PreprocessorTok{ }\NormalTok{\&\&}\PreprocessorTok{ }\NormalTok{x}\PreprocessorTok{ }\NormalTok{\textless{}=}\PreprocessorTok{ }\CharTok{\textquotesingle{}9\textquotesingle{}}\NormalTok{)}
  \DataTypeTok{char}\NormalTok{ buf[MAXSIZE], *p1, *p2;}
  \DataTypeTok{char}\NormalTok{ pbuf[MAXSIZE], *pp;}
\PreprocessorTok{\#if DEBUG}
\PreprocessorTok{\#else}
\NormalTok{  IO() : p1(buf), p2(buf), pp(pbuf) \{\}}
\NormalTok{  \textasciitilde{}IO() \{ fwrite(pbuf, }\DecValTok{1}\NormalTok{, pp {-} pbuf, stdout); \}}
\PreprocessorTok{\#endif}
  \KeywordTok{inline} \DataTypeTok{char}\NormalTok{ gc() \{}
\PreprocessorTok{\#if DEBUG  }\CommentTok{//调试，可显示字符}
    \ControlFlowTok{return}\NormalTok{ getchar();}
\PreprocessorTok{\#endif}
    \ControlFlowTok{if}\NormalTok{ (p1 == p2) p2 = (p1 = buf) + fread(buf, }\DecValTok{1}\NormalTok{, MAXSIZE, stdin);}
    \ControlFlowTok{return}\NormalTok{ p1 == p2 ? }\CharTok{\textquotesingle{} \textquotesingle{}}\NormalTok{ : *p1++;}
\NormalTok{  \}}
  \KeywordTok{inline} \DataTypeTok{bool}\NormalTok{ blank(}\DataTypeTok{char}\NormalTok{ ch) \{}
    \ControlFlowTok{return}\NormalTok{ ch == }\CharTok{\textquotesingle{} \textquotesingle{}}\NormalTok{ || ch == }\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{ || ch == }\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}r}\CharTok{\textquotesingle{}}\NormalTok{ || ch == }\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}t}\CharTok{\textquotesingle{}}\NormalTok{;}
\NormalTok{  \}}
  \KeywordTok{template}\NormalTok{ \textless{}}\KeywordTok{class}\NormalTok{ T\textgreater{}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ read(T \&x) \{}
    \AttributeTok{register} \DataTypeTok{double}\NormalTok{ tmp = }\DecValTok{1}\NormalTok{;}
    \AttributeTok{register} \DataTypeTok{bool}\NormalTok{ sign = }\DecValTok{0}\NormalTok{;}
\NormalTok{    x = }\DecValTok{0}\NormalTok{;}
    \AttributeTok{register} \DataTypeTok{char}\NormalTok{ ch = gc();}
    \ControlFlowTok{for}\NormalTok{ (; !isdigit(ch); ch = gc())}
      \ControlFlowTok{if}\NormalTok{ (ch == }\CharTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{) sign = }\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (; isdigit(ch); ch = gc()) x = x * }\DecValTok{10}\NormalTok{ + (ch {-} }\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{ (ch == }\CharTok{\textquotesingle{}.\textquotesingle{}}\NormalTok{)}
      \ControlFlowTok{for}\NormalTok{ (ch = gc(); isdigit(ch); ch = gc())}
\NormalTok{        tmp /= }\FloatTok{10.0}\NormalTok{, x += tmp * (ch {-} }\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{ (sign) x = {-}x;}
\NormalTok{  \}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ read(}\DataTypeTok{char}\NormalTok{ *s) \{}
    \AttributeTok{register} \DataTypeTok{char}\NormalTok{ ch = gc();}
    \ControlFlowTok{for}\NormalTok{ (; blank(ch); ch = gc())}
\NormalTok{      ;}
    \ControlFlowTok{for}\NormalTok{ (; !blank(ch); ch = gc()) *s++ = ch;}
\NormalTok{    *s = }\DecValTok{0}\NormalTok{;}
\NormalTok{  \}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ read(}\DataTypeTok{char}\NormalTok{ \&c) \{}
    \ControlFlowTok{for}\NormalTok{ (c = gc(); blank(c); c = gc())}
\NormalTok{      ;}
\NormalTok{  \}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ push(}\AttributeTok{const} \DataTypeTok{char}\NormalTok{ \&c) \{}
\PreprocessorTok{\#if DEBUG  }\CommentTok{//调试，可显示字符}
\NormalTok{    putchar(c);}
\PreprocessorTok{\#else}
    \ControlFlowTok{if}\NormalTok{ (pp {-} pbuf == MAXSIZE) fwrite(pbuf, }\DecValTok{1}\NormalTok{, MAXSIZE, stdout), pp = pbuf;}
\NormalTok{    *pp++ = c;}
\PreprocessorTok{\#endif}
\NormalTok{  \}}
  \KeywordTok{template}\NormalTok{ \textless{}}\KeywordTok{class}\NormalTok{ T\textgreater{}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ write(T x) \{}
    \ControlFlowTok{if}\NormalTok{ (x \textless{} }\DecValTok{0}\NormalTok{) x = {-}x, push(}\CharTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{);  }\CommentTok{// 负数输出}
    \AttributeTok{static}\NormalTok{ T sta[}\DecValTok{35}\NormalTok{];}
\NormalTok{    T top = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{do}\NormalTok{ \{}
\NormalTok{      sta[top++] = x \% }\DecValTok{10}\NormalTok{, x /= }\DecValTok{10}\NormalTok{;}
\NormalTok{    \} }\ControlFlowTok{while}\NormalTok{ (x);}
    \ControlFlowTok{while}\NormalTok{ (top) push(sta[{-}{-}top] + }\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{);}
\NormalTok{  \}}
  \KeywordTok{template}\NormalTok{ \textless{}}\KeywordTok{class}\NormalTok{ T\textgreater{}}
  \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ write(T x, }\DataTypeTok{char}\NormalTok{ lastChar) \{}
\NormalTok{    write(x), push(lastChar);}
\NormalTok{  \}}
\NormalTok{\} io;}
\end{Highlighting}
\end{Shaded}

\hypertarget{fread}{%
\subsection{fread}\label{fread}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ ibuf[}\DecValTok{40000000}\NormalTok{], *ih = ibuf, obuf[}\DecValTok{15000000}\NormalTok{], *oh = obuf;}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ read( }\DataTypeTok{int}\NormalTok{ \&x ) }\CommentTok{//fread(ibuf,1,40000000,stdin);}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ f=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (; !isdigit( *ih ); ++ih )}\ControlFlowTok{if}\NormalTok{(*ih == }\CharTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{) f={-}}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ ( x = }\DecValTok{0}\NormalTok{; isdigit( *ih ); x = x * }\DecValTok{10}\NormalTok{ + *ih++ {-} }\DecValTok{48}\NormalTok{ );}
\NormalTok{    x*=f;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ out( LL x ) }\CommentTok{// fwrite( obuf, 1, oh {-} obuf, stdout );}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{ ( !x )\{*oh++ = }\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{; }\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{if}\NormalTok{(x\textless{}}\DecValTok{0}\NormalTok{)*oh++=}\CharTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{,x={-}x;}
    \AttributeTok{static} \DataTypeTok{int}\NormalTok{ buf[}\DecValTok{30}\NormalTok{]; }\DataTypeTok{int}\NormalTok{ xb = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (; x; x /= }\DecValTok{10}\NormalTok{ )}
\NormalTok{        buf[++xb] = x \% }\DecValTok{10}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (; xb; )}
\NormalTok{        *oh++ = buf[xb{-}{-}] | }\DecValTok{48}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6570ux636eux7ed3ux6784}{%
\section{数据结构}\label{ux6570ux636eux7ed3ux6784}}

\hypertarget{ux7ef4ux62a4ux6811ux4e0a-disu-ux4e4bux548c}{%
\subsection{维护树上 dis(*，u)
之和}\label{ux7ef4ux62a4ux6811ux4e0a-disu-ux4e4bux548c}}

\(dis(u,v) = d[u] + d[v] - d[lca(u,v)]\)，考虑维护所有点对的 \(lca\)
之和，加入一个点对它到根节点的链区间加，询问 \(dis(*,u)\) 时对 \(u\)
到根节点的链求和即为 \(d[lca(u,v)]\) 之和。

\hypertarget{ux7b1bux5361ux5c14ux6811-treap-ux7ebfux6027ux6784ux9020}{%
\subsection{笛卡尔树 \&\& Treap
线性构造}\label{ux7b1bux5361ux5c14ux6811-treap-ux7ebfux6027ux6784ux9020}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ stk[MAXN],top,root;}
\DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ p[])}
\NormalTok{\{}
\NormalTok{    top=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        ls[i]=rs[i]={-}}\DecValTok{1}\NormalTok{;}\ControlFlowTok{if}\NormalTok{(d[i]==p[i]\%}\DecValTok{10}\NormalTok{)}\ControlFlowTok{continue}\NormalTok{;}

        \ControlFlowTok{while}\NormalTok{(top\&\&p[i]\textless{}p[stk[top]])ls[i]=stk[top{-}{-}];}
        \ControlFlowTok{if}\NormalTok{(top)rs[stk[top]]=i;}
\NormalTok{        stk[++top]=i;}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{(!top)root={-}}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{else}\NormalTok{ root=stk[}\DecValTok{1}\NormalTok{];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{stdlist-o1-ux5408ux5e76}{%
\subsection{std::list O(1) 合并}\label{stdlist-o1-ux5408ux5e76}}

stl 链表 O(1) 合并

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    list\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} l1,l2;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,}\DecValTok{100000}\NormalTok{)l1.push\_back(i),l2.push\_back(i);}
\NormalTok{    l1.splice(l1.begin(),l2); }\CommentTok{//将 l2 接到 l1 后面 O(1)}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e76ux67e5ux96c6-ux5e26ux6743ux5e76ux67e5ux96c6}{%
\subsection{并查集 \&
带权并查集}\label{ux5e76ux67e5ux96c6-ux5e26ux6743ux5e76ux67e5ux96c6}}

\hypertarget{ux6570ux989cux8272}{%
\subsection{数颜色}\label{ux6570ux989cux8272}}

\hypertarget{ux83abux961f-nsqrtn}{%
\subsubsection{1.莫队 nsqrt(n)}\label{ux83abux961f-nsqrtn}}

\href{https://www.luogu.com.cn/problem/P1494}{小Z的袜子}

\hypertarget{ux4e3bux5e2dux6811-or-ux4e8cux7ef4ux6570ux70b9-mlogn}{%
\subsubsection{2.主席树 or 二维数点
mlogn}\label{ux4e3bux5e2dux6811-or-ux4e8cux7ef4ux6570ux70b9-mlogn}}

设 p{[}i{]} = max\{j\textbar j\textless i\&\&a{[}j{]}==a{[}i{]}\}
(不存在这样的 j 时p{[}i{]}=0)

那么区间不重复的个数等价于 {[}l,r{]} 范围内 p{[}i{]}\textless l
的i的个数，二维数点 or 主席树维护即可。

\hypertarget{ux4e3bux5e2dux6811}{%
\paragraph{主席树}\label{ux4e3bux5e2dux6811}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ cnt=}\DecValTok{0}\NormalTok{,s[MAXN*}\DecValTok{40}\NormalTok{],ls[MAXN*}\DecValTok{40}\NormalTok{],rs[MAXN*}\DecValTok{40}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!rt)rt=++cnt; s[rt]=s[pre]+}\DecValTok{1}\NormalTok{; }\ControlFlowTok{if}\NormalTok{(l==r)}\ControlFlowTok{return}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(val\textless{}=mid)update(ls[pre],ls[rt],l,mid,val),rs[rt]=rs[pre];}
    \ControlFlowTok{else}\NormalTok{ update(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,val),ls[rt]=ls[pre];}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!rt) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}\ControlFlowTok{return}\NormalTok{ s[rt]{-}s[pre];}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid)}\ControlFlowTok{return}\NormalTok{ query(ls[pre],ls[rt],l,mid,nl,nr);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) }\ControlFlowTok{return}\NormalTok{ query(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,nl,nr);}
    \ControlFlowTok{return}\NormalTok{ query(ls[pre],ls[rt],l,mid,nl,mid)+}
\NormalTok{        query(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
\NormalTok{    cout \textless{}\textless{} dbgs4(rt,l,r,s[rt]) \textless{}\textless{} endl;}
    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    debug(ls[rt],l,mid),debug(rs[rt],mid+}\DecValTok{1}\NormalTok{,r);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ a[MAXN],pre[MAXN],root[MAXN];}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)io.read(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)update(root[i{-}}\DecValTok{1}\NormalTok{],root[i],}\DecValTok{0}\NormalTok{,N,pre[a[i]]),pre[a[i]]=i;}
\NormalTok{    io.read(m);}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l,r; io.read(l),io.read(r);}
        \DataTypeTok{int}\NormalTok{ ans=query(root[l{-}}\DecValTok{1}\NormalTok{],root[r],}\DecValTok{0}\NormalTok{,N,}\DecValTok{0}\NormalTok{,l{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        io.write(ans),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux7ef4ux6570ux70b9ux79bbux7ebfsortux6811ux72b6ux6570ux7ec4}{%
\paragraph{二维数点(离线sort+树状数组)}\label{ux4e8cux7ef4ux6570ux70b9ux79bbux7ebfsortux6811ux72b6ux6570ux7ec4}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,head;}
\DataTypeTok{int}\NormalTok{ a[MAXN],c[MAXN],ans[MAXN];}
\DataTypeTok{int}\NormalTok{ pre[MAXN];}

\KeywordTok{namespace}\NormalTok{ BIT}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ c[MAXN];}
    \DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)\{x++;}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}MAXN;i+=lowbit(i))c[i]+=v;\}}
    \DataTypeTok{int}\NormalTok{ sum(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        x++;}
        \DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=lowbit(i))}
\NormalTok{            ans+=c[i];}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)\{}\ControlFlowTok{return}\NormalTok{ sum(r){-}sum(l{-}}\DecValTok{1}\NormalTok{);\}}
\NormalTok{\}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ BIT;}

\KeywordTok{struct}\NormalTok{ point }
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x,y,index,f;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ point \&t)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(x!=t.x) }\ControlFlowTok{return}\NormalTok{ x\textless{}t.x;}
        \ControlFlowTok{if}\NormalTok{(y!=t.y) }\ControlFlowTok{return}\NormalTok{ y\textgreater{}t.y;}
        \ControlFlowTok{return}\NormalTok{ index\textless{}t.index;}
\NormalTok{    \}}
\NormalTok{\}q[MAXN*}\DecValTok{2}\NormalTok{];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n);}\CommentTok{//,io.read(m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)io.read(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)::c[i]=pre[a[i]],pre[a[i]]=i,q[++head]=\{i,::c[i],}\DecValTok{0}\NormalTok{\};}
\NormalTok{    io.read(m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l,r; io.read(l),io.read(r);}
\NormalTok{        ans[i]={-}(r{-}l+}\DecValTok{1}\NormalTok{);}
        \CommentTok{//q[++head]=\{l{-}1,l,i,{-}1\};}
\NormalTok{        q[++head]=\{r,l,i, }\DecValTok{1}\NormalTok{\};}
\NormalTok{    \}}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+head);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,head)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(q[i].index) ans[q[i].index]+=q[i].f*query(q[i].y,n);}
        \ControlFlowTok{else}\NormalTok{ update(q[i].y,}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m) io.write({-}ans[i]),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
    \CommentTok{//fp(i,1,m)printf("\%d ",{-}ans[i]);printf("\textbackslash{}n");}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6811ux72b6ux6570ux7ec4-mlogn-ux5e38ux6570ux5c0fux4e14ux53efux7528ux4e3bux5e2dux6811ux7ef4ux62a4}{%
\subsubsection{3.树状数组 mlogn
(常数小，且可用主席树维护)}\label{ux6811ux72b6ux6570ux7ec4-mlogn-ux5e38ux6570ux5c0fux4e14ux53efux7528ux4e3bux5e2dux6811ux7ef4ux62a4}}

考虑对于每个 r 维护一个不重复的 a{[}i{]} 的集合，且 a{[}i{]}
重复出现时保留最靠右的。 那么对于固定 r 的询问 {[}l,r{]}
只需要求当前集合中下标在 {[}l,r{]} 范围内的数的个数，树状数组维护即可。
当需要保存每个 r 对应的集合时可以考虑用主席树维护。

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//换掉vector能更快}
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ l[MAXN],r[MAXN],a[MAXN],pre[MAXN],ans[MAXN],c[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q[MAXN];}
\DataTypeTok{void}\NormalTok{ up(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)\{}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}MAXN;i+=(i\&{-}i))c[i]+=v;\}}
\DataTypeTok{int}\NormalTok{ qr(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{)\{}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=(i\&{-}i))ans+=c[i];}\ControlFlowTok{return}\NormalTok{ ans;\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]);}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&l[i],\&r[i]),q[r[i]].pb(i);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(pre[a[i]])up(pre[a[i]],{-}}\DecValTok{1}\NormalTok{); up(i,}\DecValTok{1}\NormalTok{),pre[a[i]]=i;}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ j:q[i])ans[j]=qr(i){-}qr(l[j]{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans[i]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux73c2ux6735ux8389ux6811}{%
\subsection{珂朵莉树}\label{ux73c2ux6735ux8389ux6811}}

\hypertarget{ux8d44ux6599}{%
\subsubsection{资料}\label{ux8d44ux6599}}

\href{https://www.cnblogs.com/lyp-Bird/p/10310609.html}{我的数据结构不可能这么可爱！------珂朵莉树(ODT)详解}

\href{https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html}{珂朵莉树详解}

\hypertarget{ux4f8bux9898}{%
\subsubsection{例题}\label{ux4f8bux9898}}

\href{https://codeforces.com/problemset/problem/896/C}{CF896C}

维护一个数据结构，支持区间加法，区间赋值，区间k大，和区间幂次和
\(\sum_{i=l}^{r} {a_{i}^{x}}\)

将一段 \(a_{i}\)
相同的区间合并起来，用一个set来维护，在操作随机的情况下各种操作的复杂度为
\(log(n)\)

\hypertarget{ux6a21ux677f}{%
\subsubsection{模板}\label{ux6a21ux677f}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL vmax,seed;}
\NormalTok{LL rnd()}
\NormalTok{\{}
\NormalTok{    LL ret=seed;}
\NormalTok{    seed=(seed*}\DecValTok{7}\NormalTok{+}\DecValTok{13}\NormalTok{)\%(M);}
    \ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{\}}
\NormalTok{LL fpow(LL x,LL k,LL MOD)}
\NormalTok{\{}
\NormalTok{    x\%=MOD; LL ans=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\&}\DecValTok{1}\NormalTok{)ans=ans*x\%MOD;}
\NormalTok{        x=x*x\%MOD,k=k\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{LL a[MAXN];}
\KeywordTok{struct}\NormalTok{ node}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l,r;}
    \AttributeTok{mutable}\NormalTok{ LL t;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{\textless{}(}\AttributeTok{const}\NormalTok{ node \&t)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(l==t.l) }\ControlFlowTok{return}\NormalTok{ r\textless{}t.r;}
        \ControlFlowTok{return}\NormalTok{ l\textless{}t.l;}
\NormalTok{    \}}
\NormalTok{\};}
\NormalTok{set\textless{}node\textgreater{} s;}
\KeywordTok{typedef}\NormalTok{ set\textless{}node\textgreater{}::iterator I;}
\NormalTok{I split(}\DataTypeTok{int}\NormalTok{ pos)}
\NormalTok{\{}
\NormalTok{    I it=s.lb(\{pos,{-}}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{\});}
    \ControlFlowTok{if}\NormalTok{(it!=s.end()\&\&it{-}\textgreater{}l==pos)}\ControlFlowTok{return}\NormalTok{ it;}
\NormalTok{    it{-}{-}; }\DataTypeTok{int}\NormalTok{ l=it{-}\textgreater{}l,r=it{-}\textgreater{}r;LL t=it{-}\textgreater{}t;}
\NormalTok{    s.erase(it),s.insert(\{l,pos{-}}\DecValTok{1}\NormalTok{,t\});}
    \ControlFlowTok{return}\NormalTok{ s.insert(\{pos,r,t\}).fi;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ td(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,LL t)}
\NormalTok{\{}
\NormalTok{    I R=split(r+}\DecValTok{1}\NormalTok{),L=split(l); }\CommentTok{//先拆右边，防止迭代器失效}
\NormalTok{    s.erase(L,R),s.insert(\{l,r,t\});}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,LL v)}
\NormalTok{\{}
\NormalTok{    I R=split(r+}\DecValTok{1}\NormalTok{),L=split(l);}
    \ControlFlowTok{for}\NormalTok{(I it=L;it!=R;it++)it{-}\textgreater{}t+=v;}
\NormalTok{\}}
\NormalTok{vector\textless{}lpr\textgreater{} t;}
\DataTypeTok{void}\NormalTok{ kth(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
\NormalTok{    t.clear();}
\NormalTok{    I R=split(r+}\DecValTok{1}\NormalTok{),L=split(l);}
    \ControlFlowTok{for}\NormalTok{(I it=L;it!=R;it++)}
\NormalTok{        t.pb(\{it{-}\textgreater{}t,it{-}\textgreater{}r{-}it{-}\textgreater{}l+}\DecValTok{1}\NormalTok{\});}
\NormalTok{    sort(all(t));}
    \DataTypeTok{int}\NormalTok{ cnt=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:t)}
\NormalTok{    \{}
\NormalTok{        cnt+=x.se;}
        \ControlFlowTok{if}\NormalTok{(cnt\textgreater{}=k)\{printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,x.fi);}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ sum(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,LL x,LL MOD)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    I R=split(r+}\DecValTok{1}\NormalTok{),L=split(l);}
    \ControlFlowTok{for}\NormalTok{(I it=L;it!=R;it++)}
\NormalTok{        ans+=LL(it{-}\textgreater{}r{-}it{-}\textgreater{}l+}\DecValTok{1}\NormalTok{)*fpow(it{-}\textgreater{}t,x,MOD)\%MOD,ans\%=MOD;}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%lld\%lld}\StringTok{"}\NormalTok{,\&n,\&m,\&seed,\&vmax);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i]=rnd()\%vmax+}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ cnt=}\DecValTok{1}\NormalTok{,i=}\DecValTok{2}\NormalTok{;i\textless{}=n+}\DecValTok{1}\NormalTok{;i++)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(a[i]!=a[i{-}}\DecValTok{1}\NormalTok{]||i==n+}\DecValTok{1}\NormalTok{)}
\NormalTok{            s.insert(\{i{-}cnt,i{-}}\DecValTok{1}\NormalTok{,a[i{-}}\DecValTok{1}\NormalTok{]\}),cnt=}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ cnt++;}
\NormalTok{    \}}
\NormalTok{    s.insert(\{n+}\DecValTok{1}\NormalTok{,n+}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{\});}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ op=rnd()\%}\DecValTok{4}\NormalTok{+}\DecValTok{1}\NormalTok{,l=rnd()\%n+}\DecValTok{1}\NormalTok{,r=rnd()\%n+}\DecValTok{1}\NormalTok{,x,y;}
        \ControlFlowTok{if}\NormalTok{(l\textgreater{}r)swap(l,r);}
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{3}\NormalTok{)x=(rnd()\%(r{-}l+}\DecValTok{1}\NormalTok{))+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ x=(rnd()\%vmax)+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{4}\NormalTok{)y=(rnd()\%vmax)+}\DecValTok{1}\NormalTok{;}
        
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{1}\NormalTok{)add(l,r,x);}
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{2}\NormalTok{)td(l,r,x);}
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{3}\NormalTok{)kth(l,r,x);}
        \ControlFlowTok{if}\NormalTok{(op==}\DecValTok{4}\NormalTok{)sum(l,r,(LL)x,(LL)y);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6811ux72b6ux6570ux7ec4}{%
\subsection{树状数组}\label{ux6811ux72b6ux6570ux7ec4}}

\hypertarget{ux8d44ux6599-1}{%
\subsubsection{资料}\label{ux8d44ux6599-1}}

\href{https://www.cnblogs.com/RabbitHu/p/BIT.html}{``高级''数据结构------树状数组！}

\hypertarget{ux4e8cux7ef4ux6811ux72b6ux6570ux7ec4}{%
\subsubsection{二维树状数组}\label{ux4e8cux7ef4ux6811ux72b6ux6570ux7ec4}}

\hypertarget{ux5355ux70b9ux4feeux6539-ux77e9ux9635ux6c42ux548c}{%
\paragraph{单点修改
矩阵求和}\label{ux5355ux70b9ux4feeux6539-ux77e9ux9635ux6c42ux548c}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{LL c[MAXN][MAXN];}

\DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}=n;i+=lowbit(i))}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=y;j\textless{}=m;j+=lowbit(j))}
\NormalTok{            c[i][j]+=v;}
\NormalTok{\}}
\NormalTok{LL sum(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,LL ans=}\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=lowbit(i))}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=y;j;j{-}=lowbit(j))}
\NormalTok{            ans+=c[i][j];}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\NormalTok{LL query(}\DataTypeTok{int}\NormalTok{ x1,}\DataTypeTok{int}\NormalTok{ y1,}\DataTypeTok{int}\NormalTok{ x2,}\DataTypeTok{int}\NormalTok{ y2)}
\NormalTok{\{}
\NormalTok{    x1{-}{-},y1{-}{-};}
    \ControlFlowTok{return}\NormalTok{ sum(x2,y2)+sum(x1,y1){-}sum(x1,y2){-}sum(x2,y1);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
    \DataTypeTok{int}\NormalTok{ opt,a,b,c,d;}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&opt)==}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&a,\&b,\&c);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{) update(a,b,c);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{2}\NormalTok{) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&d),printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,query(a,b,c,d));}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux77e9ux5f62ux4feeux6539-ux5355ux70b9ux6c42ux503c}{%
\paragraph{矩形修改
单点求值}\label{ux77e9ux5f62ux4feeux6539-ux5355ux70b9ux6c42ux503c}}

考虑维护差分数组

\[
d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]
\]

给矩形 \((x1,y1)\) \((x2,y2)\) 加上某个值等价于

\[d[x1][y1]+=v,d[x2+1][y1]-=v;\] \[d[x1][y2+1]-=v,d[x2+1][y2+1]+=v;\]

单点求值

\[a[i][j]=\sum_{i=1}^{n}\sum_{j=1}^{m}d[i][j]\]

用普通的二维树状数组维护即可

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ bit}
\NormalTok{\{}
\NormalTok{    LL c[MAXN][MAXN];}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}MAXN;i+=(i\&{-}i))}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=y;j\textless{}MAXN;j+=(j\&{-}j))}
\NormalTok{                c[i][j]+=val;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ x1,}\DataTypeTok{int}\NormalTok{ y1,}\DataTypeTok{int}\NormalTok{ x2,}\DataTypeTok{int}\NormalTok{ y2,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{    \{}
\NormalTok{        x2++,y2++;}
\NormalTok{        update(x1,y1, val);}
\NormalTok{        update(x2,y1,{-}val);}
\NormalTok{        update(x1,y2,{-}val);}
\NormalTok{        update(x2,y2, val);}
\NormalTok{    \}}
\NormalTok{    LL query(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=(i\&{-}i))}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=y;j;j{-}=(j\&{-}j))}
\NormalTok{                s+=c[i][j];}
        \ControlFlowTok{return}\NormalTok{ s;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux77e9ux5f62ux4feeux6539-ux77e9ux5f62ux6c42ux548cux5f85ux8865}{%
\subsubsection{矩形修改
矩形求和(待补))}\label{ux77e9ux5f62ux4feeux6539-ux77e9ux5f62ux6c42ux548cux5f85ux8865}}

\hypertarget{ux7ebfux6bb5ux6811}{%
\subsection{线段树}\label{ux7ebfux6bb5ux6811}}

\hypertarget{ux674eux8d85ux6811}{%
\subsubsection{李超树}\label{ux674eux8d85ux6811}}

给出 \(m\) 条直线 \(y=kx+b\) 询问在整点 \(x'\) 上最大的 \(y'\) 是多少。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ K[N*}\DecValTok{4}\NormalTok{],B[N*}\DecValTok{4}\NormalTok{];}
\DataTypeTok{bool}\NormalTok{ cov[N*}\DecValTok{4}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    cov[cnt]=K[cnt]=B[cnt]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    build(l,mid,ls);}
\NormalTok{    build(mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{double}\NormalTok{ nk,}\DataTypeTok{double}\NormalTok{ nb,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!cov[cnt])\{cov[cnt]=}\DecValTok{1}\NormalTok{,K[cnt]=nk,B[cnt]=nb;}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{if}\NormalTok{(nk\textgreater{}K[cnt]) swap(nk,K[cnt]),swap(nb,B[cnt]);}
    \ControlFlowTok{if}\NormalTok{(K[cnt]*mid+B[cnt]\textgreater{}nk*mid+nb)}
\NormalTok{        \{}\ControlFlowTok{if}\NormalTok{(l!=r) insert(l,mid,nk,nb,ls);\}}
    \ControlFlowTok{else}
\NormalTok{    \{}
\NormalTok{        swap(nk,K[cnt]),swap(nb,B[cnt]);}
        \ControlFlowTok{if}\NormalTok{(l!=r) insert(mid+}\DecValTok{1}\NormalTok{,r,nk,nb,rs);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{double}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \DataTypeTok{double}\NormalTok{ Y=K[cnt]*x+B[cnt];}
    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{ Y;}
    \ControlFlowTok{if}\NormalTok{(x\textless{}=mid) }\ControlFlowTok{return}\NormalTok{ max(Y,query(l,mid,x,ls));}
    \ControlFlowTok{if}\NormalTok{(x\textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ max(Y,query(mid+}\DecValTok{1}\NormalTok{,r,x,rs));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux626bux63cfux7ebf}{%
\subsubsection{扫描线}\label{ux626bux63cfux7ebf}}

\hypertarget{ux626bux63cfux7ebfux6c42ux77e9ux5f62ux9762ux79efux4ea4}{%
\paragraph{1.扫描线求矩形面积交}\label{ux626bux63cfux7ebfux6c42ux77e9ux5f62ux9762ux79efux4ea4}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} Y;}

\CommentTok{//线段树中第i个点表示 Y[i]\textasciitilde{}Y[i+1] 这条线段}
\NormalTok{LL sum[MAXN*}\DecValTok{4}\NormalTok{];}
\DataTypeTok{int}\NormalTok{ cov[MAXN*}\DecValTok{4}\NormalTok{]; }\CommentTok{//标记永久化}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(cov[cnt]\textgreater{}}\DecValTok{0}\NormalTok{) sum[cnt]=Y[r+}\DecValTok{1}\NormalTok{]{-}Y[l];}
    \ControlFlowTok{else}\NormalTok{ sum[cnt]=sum[ls]+sum[rs];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ f,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}
\NormalTok{    \{}
\NormalTok{        cov[cnt]+=f;}
        \ControlFlowTok{if}\NormalTok{(cov[cnt]\textgreater{}}\DecValTok{0}\NormalTok{) sum[cnt]=(Y[r+}\DecValTok{1}\NormalTok{]{-}Y[l]);}
        \ControlFlowTok{else}\NormalTok{ sum[cnt]=sum[ls]+sum[rs];}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) update(l,mid,nl,nr,f,ls);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) update(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,f,rs);}
    \ControlFlowTok{else}\NormalTok{ update(l,mid,nl,mid,f,ls),update(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,f,rs);}
\NormalTok{    pushup(l,r,cnt);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ n;}
\KeywordTok{struct}\NormalTok{ line}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x,y1,y2,f;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ line \&t)}\AttributeTok{const}\NormalTok{\{}\ControlFlowTok{return}\NormalTok{ x\textless{}t.x;\}}
\NormalTok{\};}
\NormalTok{vector\textless{}line\textgreater{} L;}
\NormalTok{LL ans=}\DecValTok{0}\NormalTok{;}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    n=read();}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x1=read(),y1=read(); }\CommentTok{//左下}
        \DataTypeTok{int}\NormalTok{ x2=read(),y2=read(); }\CommentTok{//右上}
\NormalTok{        Y.pb(y1),Y.pb(y2);}
\NormalTok{        L.pb(\{x1,y1,y2, }\DecValTok{1}\NormalTok{\});}
\NormalTok{        L.pb(\{x2,y1,y2,{-}}\DecValTok{1}\NormalTok{\});}
\NormalTok{    \}}
\NormalTok{    sort(all(Y)),unq(Y),sort(all(L));}

    \DataTypeTok{int}\NormalTok{ m=Y.size(){-}}\DecValTok{2}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}L.size();i++)}
\NormalTok{    \{}
\NormalTok{        L[i].y1=lower\_bound(all(Y),L[i].y1){-}Y.begin();}
\NormalTok{        L[i].y2=lower\_bound(all(Y),L[i].y2){-}Y.begin();}
        \ControlFlowTok{if}\NormalTok{(i) ans+=LL(L[i].x{-}L[i{-}}\DecValTok{1}\NormalTok{].x)*sum[}\DecValTok{1}\NormalTok{];}
\NormalTok{        update(}\DecValTok{0}\NormalTok{,m,L[i].y1,L[i].y2{-}}\DecValTok{1}\NormalTok{,L[i].f,}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ write(ans),putchar(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6bb5ux6811ux5408ux5e76}{%
\subsubsection{线段树合并}\label{ux7ebfux6bb5ux6811ux5408ux5e76}}

多用于权值线段树，均摊 \(logn\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(x*y==}\DecValTok{0}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ x+y; }
    \ControlFlowTok{if}\NormalTok{(l==r)\{mx[x]+=mx[y];}\ControlFlowTok{return}\NormalTok{ x;\}}
\NormalTok{    ls[x]=merge(ls[x],ls[y],l,mid);}
\NormalTok{    rs[x]=merge(rs[x],rs[y],mid+}\DecValTok{1}\NormalTok{,r);}
\NormalTok{    up(x);}\ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6bb5ux6811ux5206ux88c2}{%
\subsubsection{线段树分裂}\label{ux7ebfux6bb5ux6811ux5206ux88c2}}

\hypertarget{ux7ebfux6bb5ux6811ux4f18ux5316ux5efaux56fe}{%
\subsubsection{线段树优化建图}\label{ux7ebfux6bb5ux6811ux4f18ux5316ux5efaux56fe}}

\([a,b]\) 的点到 \([c,d]\) 的点有边权为 \(w\) 的边

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//点数 n*4*2+m*2*2}
\CommentTok{//边数 n*4*2+n+(1+2*logn)*m*2}
\NormalTok{EDGE(N,M);}
\DataTypeTok{int}\NormalTok{ n,m,S,node=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ in[MAXN*}\DecValTok{4}\NormalTok{],out[MAXN*}\DecValTok{4}\NormalTok{],dis[N];}
\DataTypeTok{bool}\NormalTok{ v[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q1,q2;}
\DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    in[cnt]=++node,out[cnt]=++node;}
    \ControlFlowTok{if}\NormalTok{(cnt/}\DecValTok{2}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        addedge(in[cnt/}\DecValTok{2}\NormalTok{],in[cnt],}\DecValTok{0}\NormalTok{);}
\NormalTok{        addedge(out[cnt],out[cnt/}\DecValTok{2}\NormalTok{],}\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(l==r)\{addedge(in[cnt],out[cnt],}\DecValTok{0}\NormalTok{);}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{else}\NormalTok{ build(l,mid,ls),build(mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ id[],vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} \&v,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)\{v.pb(id[cnt]);}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid)query(l,mid,nl,nr,id,v,ls);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid)query(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,id,v,rs);}
    \ControlFlowTok{else}\NormalTok{ query(l,mid,nl,mid,id,v,ls),query(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,id,v,rs);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ link(}\DataTypeTok{int}\NormalTok{ a,}\DataTypeTok{int}\NormalTok{ b,}\DataTypeTok{int}\NormalTok{ c,}\DataTypeTok{int}\NormalTok{ d)}
\NormalTok{\{}
\NormalTok{    query(}\DecValTok{1}\NormalTok{,n,a,b,out,q1,}\DecValTok{1}\NormalTok{),query(}\DecValTok{1}\NormalTok{,n,c,d,in,q2,}\DecValTok{1}\NormalTok{);}
    \DataTypeTok{int}\NormalTok{ t1=++node,t2=++node;}
\NormalTok{    addedge(t1,t2,}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:q1)addedge(x,t1,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:q2)addedge(t2,x,}\DecValTok{0}\NormalTok{);}
\NormalTok{    q1.clear(),q2.clear();}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ bfs()}
\NormalTok{\{}
\NormalTok{    query(}\DecValTok{1}\NormalTok{,n,S,S,in,q1,}\DecValTok{1}\NormalTok{); S=q1.back();}
\NormalTok{    deque\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q; mst(dis,{-}}\DecValTok{1}\NormalTok{); dis[S]=}\DecValTok{0}\NormalTok{,q.pb(S);}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q.front(); q.ppf();}
        \ControlFlowTok{if}\NormalTok{(v[u])}\ControlFlowTok{continue}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ v[u]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(dis[v]=={-}}\DecValTok{1}\NormalTok{||dis[u]+w\textless{}dis[v])}
\NormalTok{            dis[v]=dis[u]+w,(w?q.pb(v):q.pf(v));}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ print(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==r)\{printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,dis[in[cnt]]);}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    print(l,mid,ls),print(mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m,\&S);}
\NormalTok{    build(}\DecValTok{1}\NormalTok{,n,}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ a,b,c,d;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d\%d}\StringTok{"}\NormalTok{,\&a,\&b,\&c,\&d);}
\NormalTok{        link(a,b,c,d),link(c,d,a,b);}
\NormalTok{    \}}
\NormalTok{    bfs(),print(}\DecValTok{1}\NormalTok{,n,}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865zkwux7ebfux6bb5ux6811}{%
\subsubsection{(待补)ZKW线段树}\label{ux5f85ux8865zkwux7ebfux6bb5ux6811}}

\hypertarget{segment-tree-beatsux5409ux53f8ux673aux7ebfux6bb5ux6811}{%
\subsubsection{Segment Tree
Beats(吉司机线段树)}\label{segment-tree-beatsux5409ux53f8ux673aux7ebfux6bb5ux6811}}

\href{http://c-sunshine.blog.uoj.ac/blog/1270}{Segment Tree Beats!}

\hypertarget{ux533aux95f4kux7684ux6570ux53d8ux6210k}{%
\paragraph{1.区间\textgreater=k的数变成k}\label{ux533aux95f4kux7684ux6570ux53d8ux6210k}}

HDU5306

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL fimax[MAXN*}\DecValTok{4}\NormalTok{],semax[MAXN*}\DecValTok{4}\NormalTok{],num[MAXN*}\DecValTok{4}\NormalTok{],sum[MAXN*}\DecValTok{4}\NormalTok{];}
\NormalTok{LL setmax[MAXN*}\DecValTok{4}\NormalTok{];}

\DataTypeTok{void}\NormalTok{ doSetMax(}\DataTypeTok{int}\NormalTok{ cnt,LL v)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(fimax[cnt]\textgreater{}v)}
\NormalTok{    \{}
\NormalTok{        setmax[cnt] =min(setmax[cnt],v);}
\NormalTok{        sum   [cnt]{-}=(fimax[cnt]{-}v)*num[cnt];}
\NormalTok{        fimax [cnt] =v;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    sum[cnt]=sum[ls]+sum[rs];}
    \ControlFlowTok{if}\NormalTok{(fimax[ls]\textgreater{}fimax[rs])}
\NormalTok{    \{}
\NormalTok{        fimax[cnt]=fimax[ls];}
\NormalTok{        semax[cnt]=max(fimax[rs],semax[ls]);}
\NormalTok{        num  [cnt]=num  [ls];}
\NormalTok{    \}}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(fimax[rs]\textgreater{}fimax[ls])}
\NormalTok{    \{}
\NormalTok{        fimax[cnt]=fimax[rs];}
\NormalTok{        semax[cnt]=max(fimax[ls],semax[rs]);}
\NormalTok{        num  [cnt]=num  [rs];}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
\NormalTok{        fimax[cnt]=fimax[ls];}
\NormalTok{        num  [cnt]=num[ls]+num[rs];}
\NormalTok{        semax[cnt]=max(semax[ls],semax[rs]);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(setmax[cnt]!=linf)}
\NormalTok{    \{}
\NormalTok{        doSetMax(ls,setmax[cnt]);}
\NormalTok{        doSetMax(rs,setmax[cnt]);}
\NormalTok{        setmax[cnt]=linf;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ build(LL a[],}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    setmax[cnt]=linf;}
    \ControlFlowTok{if}\NormalTok{(l==r)}
\NormalTok{    \{}
\NormalTok{        fimax[cnt]=sum[cnt]=a[l];}
\NormalTok{        num  [cnt]= }\DecValTok{1}\NormalTok{;}
\NormalTok{        semax[cnt]={-}}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    build(a,l,mid,ls);}
\NormalTok{    build(a,mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{    pushup(cnt);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,LL v,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(v\textgreater{}=fimax[cnt]) }\ControlFlowTok{return}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(v\textgreater{}semax[cnt]\&\&v\textless{}fimax[cnt])}
\NormalTok{            \{doSetMax(cnt,v);}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    \}}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) update(l,mid,nl,nr,v,ls);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) update(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,v,rs);}
    \ControlFlowTok{else}\NormalTok{ update(l,mid,nl,mid,v,ls),update(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,v,rs);}
\NormalTok{    pushup(cnt);}
\NormalTok{\}}
\NormalTok{LL querySum(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr) }\ControlFlowTok{return}\NormalTok{ sum[cnt];}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) }\ControlFlowTok{return}\NormalTok{ querySum(l,mid,nl,nr,ls);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ querySum(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,rs);}
    \ControlFlowTok{return}\NormalTok{ querySum(l,mid,nl,mid,ls)+querySum(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,rs);}
\NormalTok{\}}
\NormalTok{LL queryMax(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr) }\ControlFlowTok{return}\NormalTok{ fimax[cnt];}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) }\ControlFlowTok{return}\NormalTok{ queryMax(l,mid,nl,nr,ls);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ queryMax(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,rs);}
    \ControlFlowTok{return}\NormalTok{ max(queryMax(l,mid,nl,mid,ls),queryMax(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,rs));}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\CommentTok{/*}
\CommentTok{    int fimax[MAXN*4],semax[MAXN*4],num[MAXN*4],sum[MAXN*4];}
\CommentTok{    int setmax[MAXN*4];}
\CommentTok{*/}
\NormalTok{    cout \textless{}\textless{} dbgs3(l,r,cnt) \textless{}\textless{} endl;}
\NormalTok{    cout \textless{}\textless{} dbgs4(fimax[cnt],semax[cnt],num[cnt],sum[cnt]) \textless{}\textless{} }\StringTok{" "}\NormalTok{ \textless{}\textless{} dbgs(setmax[cnt]) \textless{}\textless{}endl;}
    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    debug(l,mid,ls);}
\NormalTok{    debug(mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ T,n,m;}
\NormalTok{LL  a[MAXN];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
\NormalTok{        io.read(n),io.read(m);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) io.read(a[i]);}
\NormalTok{        build(a,}\DecValTok{1}\NormalTok{,n,}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ t,x,y,v;}
\NormalTok{            io.read(t),io.read(x),io.read(y);}
            \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{0}\NormalTok{)}
\NormalTok{                io.read(v),update(}\DecValTok{1}\NormalTok{,n,x,y,v,}\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{1}\NormalTok{) io.write(queryMax(}\DecValTok{1}\NormalTok{,n,x,y,}\DecValTok{1}\NormalTok{));}
                \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{2}\NormalTok{) io.write(querySum(}\DecValTok{1}\NormalTok{,n,x,y,}\DecValTok{1}\NormalTok{));}
\NormalTok{                io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{            \}}
            \CommentTok{//cout \textless{}\textless{} dbgs(m) \textless{}\textless{} endl \textless{}\textless{} endl;}
            \CommentTok{//debug(1,n,1);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux533aux95f4or-ux533aux95f4and-ux533aux95f4max}{%
\paragraph{2.区间or 区间and
区间max}\label{ux533aux95f4or-ux533aux95f4and-ux533aux95f4max}}

当区间内所有数受影响的位上相同时可以直接打标记，维护区间内共同1的位置和0的位置和区间max

注意下标记关系，\&类似于乘法，\textbar 类似于加法

(a\&b\textbar c)\&d = a\&(b\&d)\textbar(c\&d)

(a\&b\textbar c)\textbar d = a\&b\textbar(c\textbar d)

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}  \DataTypeTok{int}\NormalTok{ \_all1 = ((}\DecValTok{1}\NormalTok{\textless{}\textless{}}\DecValTok{21}\NormalTok{){-}}\DecValTok{1}\NormalTok{);}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ flip(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{  \_all1 \^{} x;\}}

\CommentTok{//all1 区间内所有数1的共同位置}
\CommentTok{//all0 区间内所有数0的共同位置}
\DataTypeTok{int}\NormalTok{ n,m,a[MAXN];}
\DataTypeTok{int}\NormalTok{ mx[MAXN*}\DecValTok{4}\NormalTok{],all1[MAXN*}\DecValTok{4}\NormalTok{],all0[MAXN*}\DecValTok{4}\NormalTok{];}
\DataTypeTok{int}\NormalTok{ orTag[MAXN*}\DecValTok{4}\NormalTok{],andTag[MAXN*}\DecValTok{4}\NormalTok{];}

\CommentTok{//a\&b|c a*b+c}
\DataTypeTok{void}\NormalTok{ doAnd(}\DataTypeTok{int}\NormalTok{ cnt,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
\NormalTok{    all1[cnt]\&=v;}
\NormalTok{    all0[cnt]|=flip(v);}
\NormalTok{    mx[cnt]\&=v,andTag[cnt]\&=v,orTag[cnt]\&=v;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ doOr(}\DataTypeTok{int}\NormalTok{ cnt,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
\NormalTok{    all1[cnt]|=v;}
\NormalTok{    all0[cnt]\&=flip(v);}
\NormalTok{    mx[cnt]|=v,orTag[cnt]|=v;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    mx[cnt]=max(mx[ls],mx[rs]);}
\NormalTok{    all1[cnt]=all1[ls]\&all1[rs];}
\NormalTok{    all0[cnt]=all0[ls]\&all0[rs];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(andTag[cnt]!=\_all1)}
\NormalTok{    \{}
\NormalTok{        doAnd(ls,andTag[cnt]);}
\NormalTok{        doAnd(rs,andTag[cnt]);}
\NormalTok{        andTag[cnt]=\_all1;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(orTag[cnt])}
\NormalTok{    \{}
\NormalTok{        doOr(ls,orTag[cnt]);}
\NormalTok{        doOr(rs,orTag[cnt]);}
\NormalTok{        orTag[cnt]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
\NormalTok{    andTag[cnt]=\_all1;}
\NormalTok{    orTag [cnt]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(l==r)}
\NormalTok{    \{}
\NormalTok{        mx  [cnt]=a[l];}
\NormalTok{        all1[cnt]=a[l];}
\NormalTok{        all0[cnt]=flip(a[l]);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    build(l,mid,ls);}
\NormalTok{    build(mid+}\DecValTok{1}\NormalTok{,r,rs);}
\NormalTok{    pushup(cnt);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr) }\ControlFlowTok{return}\NormalTok{ mx[cnt];}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) }\ControlFlowTok{return}\NormalTok{ query(l,mid,nl,nr,ls);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ query(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,rs);}
    \ControlFlowTok{return}\NormalTok{ max(query(l,mid,nl,mid,ls),query(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,rs));}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ updateAnd(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(((all1[cnt]|all0[cnt])\&flip(v))==flip(v))}
\NormalTok{            \{doAnd(cnt,v);}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    \}}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) updateAnd(l,mid,nl,nr,v,ls);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) updateAnd(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,v,rs);}
    \ControlFlowTok{else}\NormalTok{ updateAnd(l,mid,nl,mid,v,ls),updateAnd(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,v,rs);}
\NormalTok{    pushup(cnt);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ updateOr(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ cnt)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(((all1[cnt]|all0[cnt])\&v)==v)}
\NormalTok{            \{doOr(cnt,v);}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    \}}
\NormalTok{    pushdown(cnt);}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) updateOr(l,mid,nl,nr,v,ls);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) updateOr(mid+}\DecValTok{1}\NormalTok{,r,nl,nr,v,rs);}
    \ControlFlowTok{else}\NormalTok{ updateOr(l,mid,nl,mid,v,ls),updateOr(mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,v,rs);}
\NormalTok{    pushup(cnt);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux53efux6301ux4e45ux5316ux7ebfux6bb5ux6811ux4e3bux5e2dux6811}{%
\subsection{可持久化线段树(主席树)}\label{ux53efux6301ux4e45ux5316ux7ebfux6bb5ux6811ux4e3bux5e2dux6811}}

\hypertarget{ux6a21ux677f-1}{%
\subsubsection{模板}\label{ux6a21ux677f-1}}

\hypertarget{ux9759ux6001ux533aux95f4kth}{%
\paragraph{1.静态区间Kth}\label{ux9759ux6001ux533aux95f4kth}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,cnt=}\DecValTok{0}\NormalTok{,a[N+}\DecValTok{5}\NormalTok{],b[N+}\DecValTok{5}\NormalTok{];}
\DataTypeTok{int}\NormalTok{ root[MAXN],ls[MAXN],rs[MAXN],s[MAXN];}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ cnt)\{s[cnt]=s[ls[cnt]]+s[rs[cnt]];\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
\NormalTok{    rt=++cnt;}
    \ControlFlowTok{if}\NormalTok{(l==r)\{s[rt]=s[pre]+}\DecValTok{1}\NormalTok{;}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{if}\NormalTok{(v\textless{}=mid) rs[rt]=rs[pre],update(ls[pre],ls[rt],l,mid,v);}
    \ControlFlowTok{else}\NormalTok{ ls[rt]=ls[pre],update(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,v);}
\NormalTok{    pushup(rt);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ lcnt,}\DataTypeTok{int}\NormalTok{ rcnt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{ l;}
    \DataTypeTok{int}\NormalTok{ sum=s[ls[rcnt]]{-}s[ls[lcnt]];}
    \ControlFlowTok{if}\NormalTok{(k\textless{}=sum) }\ControlFlowTok{return}\NormalTok{ query(ls[lcnt],ls[rcnt],l,mid,k);}
    \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ query(rs[lcnt],rs[rcnt],mid+}\DecValTok{1}\NormalTok{,r,k{-}sum);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) b[i]=a[i];}
\NormalTok{    sort(b+}\DecValTok{1}\NormalTok{,b+}\DecValTok{1}\NormalTok{+n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) a[i]=lower\_bound(b+}\DecValTok{1}\NormalTok{,b+}\DecValTok{1}\NormalTok{+n,a[i]){-}b;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
\NormalTok{    n=read(),m=read();}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) a[i]=read();}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) update(root[i{-}}\DecValTok{1}\NormalTok{],root[i],}\DecValTok{0}\NormalTok{,N,a[i]);}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l=read(),r=read(),k=read();}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,b[query(root[l{-}}\DecValTok{1}\NormalTok{],root[r],}\DecValTok{0}\NormalTok{,N,k)]);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865-2.ux533aux95f4ux4feeux6539ux6807ux8bb0ux6c38ux4e45ux5316-ux5386ux53f2ux7248ux672cux8be2ux95ee-hdu4348}{%
\paragraph{(待补) 2.区间修改(标记永久化) \& 历史版本询问
hdu4348}\label{ux5f85ux8865-2.ux533aux95f4ux4feeux6539ux6807ux8bb0ux6c38ux4e45ux5316-ux5386ux53f2ux7248ux672cux8be2ux95ee-hdu4348}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}cstdio\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}algorithm\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}cmath\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}cstring\textgreater{}}
\PreprocessorTok{\#define N }\DecValTok{100005}
\PreprocessorTok{\#define MAXN }\NormalTok{(}\DecValTok{100005}\NormalTok{*}\DecValTok{50}\NormalTok{)}
\PreprocessorTok{\#define mid }\NormalTok{((l+r)\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{)}
\PreprocessorTok{\#define LL }\DataTypeTok{long}\PreprocessorTok{ }\DataTypeTok{long}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ std;}
\DataTypeTok{int}\NormalTok{ n,m,cnt=}\DecValTok{0}\NormalTok{,a[N],T=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ root[N+}\DecValTok{5}\NormalTok{],ls[MAXN],rs[MAXN];}
\NormalTok{LL s[MAXN],add[MAXN];}
\DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
\NormalTok{    rt=++cnt;}
    \ControlFlowTok{if}\NormalTok{(l==r)\{s[rt]=a[l];}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    build(ls[rt],l,mid);}
\NormalTok{    build(rs[rt],mid+}\DecValTok{1}\NormalTok{,r);}
\NormalTok{    s[rt]=s[ls[rt]]+s[rs[rt]];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,LL v)}
\NormalTok{\{}
\NormalTok{    rt=++cnt;}
\NormalTok{    s[rt]=s[pre]+(LL)(nr{-}nl+}\DecValTok{1}\NormalTok{)*v;}
\NormalTok{    add[rt]=add[pre];}\CommentTok{//！！继承标记}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}
\NormalTok{    \{}
\NormalTok{        ls[rt]=ls[pre];}
\NormalTok{        rs[rt]=rs[pre];}
\NormalTok{        add[rt]+=v;}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) ls[rt]=ls[pre],update(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,nl,nr,v);}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) rs[rt]=rs[pre],update(ls[pre],ls[rt],l,mid,nl,nr,v);}
    \ControlFlowTok{else}\NormalTok{ update(ls[pre],ls[rt],l,mid,nl,mid,v),update(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr,v);}
\NormalTok{\}}
\NormalTok{LL query(}\DataTypeTok{int}\NormalTok{ rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr) }\ControlFlowTok{return}\NormalTok{ s[rt];}
\NormalTok{    LL tmp=(LL)add[rt]*(nr{-}nl+}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{}mid) }\ControlFlowTok{return}\NormalTok{ query(rs[rt],mid+}\DecValTok{1}\NormalTok{,r,nl,nr)+tmp;}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid) }\ControlFlowTok{return}\NormalTok{ query(ls[rt],l,mid,nl,nr)+tmp;}
    \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ query(ls[rt],l,mid,nl,mid)+query(rs[rt],mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr)+tmp;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    cnt=T=}\DecValTok{0}\NormalTok{;}
\NormalTok{    memset(root,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(root));}
\NormalTok{    memset(ls,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(ls));}
\NormalTok{    memset(rs,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(rs));}
\NormalTok{    memset(add,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(add));}
\NormalTok{    memset(s,}\DecValTok{0}\NormalTok{,}\KeywordTok{sizeof}\NormalTok{(s));}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
    \DataTypeTok{bool}\NormalTok{ f=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m)!=EOF)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(f) f=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),init();}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]);}
\NormalTok{        build(root[}\DecValTok{0}\NormalTok{],}\DecValTok{1}\NormalTok{,n);}
        \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{        \{}
            \DataTypeTok{char}\NormalTok{ t[}\DecValTok{5}\NormalTok{]; scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,t);}
            \ControlFlowTok{if}\NormalTok{(t[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{)}
\NormalTok{            \{}
\NormalTok{                T++;}
                \DataTypeTok{int}\NormalTok{ l,r,v; scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&l,\&r,\&v);}
\NormalTok{                update(root[T{-}}\DecValTok{1}\NormalTok{],root[T],}\DecValTok{1}\NormalTok{,n,l,r,v);}
\NormalTok{            \}}
            \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(t[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}B\textquotesingle{}}\NormalTok{) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&T);}
            \ControlFlowTok{else} 
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ l,r,h; scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&l,\&r);}
                \ControlFlowTok{if}\NormalTok{(t[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{) printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,query(root[T],}\DecValTok{1}\NormalTok{,n,l,r));}
                \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(t[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}H\textquotesingle{}}\NormalTok{) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&h),printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,query(root[h],}\DecValTok{1}\NormalTok{,n,l,r));}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux53efux6301ux4e45ux5316-trie}{%
\subsection{可持久化 Trie}\label{ux53efux6301ux4e45ux5316-trie}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,root[MAXN],a[MAXN];}
\DataTypeTok{int}\NormalTok{ ls[MAXN*}\DecValTok{35}\NormalTok{],rs[MAXN*}\DecValTok{35}\NormalTok{],s[MAXN*}\DecValTok{35}\NormalTok{],cnt;}
\DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ i)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!rt) rt=++cnt,s[rt]=s[pre]; s[rt]++;}
    \ControlFlowTok{if}\NormalTok{(i=={-}}\DecValTok{1}\NormalTok{) }\ControlFlowTok{return}\NormalTok{;}
    \DataTypeTok{bool}\NormalTok{ v=((}\DecValTok{1}\NormalTok{\textless{}\textless{}i)\&x);}
    \ControlFlowTok{if}\NormalTok{(v) ls[rt]=ls[pre],insert(rs[rt],rs[pre],x,i{-}}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{else}\NormalTok{ rs[rt]=rs[pre],insert(ls[rt],ls[pre],x,i{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ lcnt,}\DataTypeTok{int}\NormalTok{ rcnt,}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ i)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(i=={-}}\DecValTok{1}\NormalTok{||s[rcnt]{-}s[lcnt]==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}i)\&x)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ sum=s[ls[rcnt]]{-}s[ls[lcnt]];}
        \ControlFlowTok{if}\NormalTok{(!sum) }\ControlFlowTok{return}\NormalTok{ query(rs[lcnt],rs[rcnt],x,i{-}}\DecValTok{1}\NormalTok{)+(}\DecValTok{1}\NormalTok{\textless{}\textless{}i);}
        \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ query(ls[lcnt],ls[rcnt],x,i{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ sum=s[rs[rcnt]]{-}s[rs[lcnt]];}
        \ControlFlowTok{if}\NormalTok{(sum) }\ControlFlowTok{return}\NormalTok{ query(rs[lcnt],rs[rcnt],x,i{-}}\DecValTok{1}\NormalTok{)+(}\DecValTok{1}\NormalTok{\textless{}\textless{}i);}
        \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ query(ls[lcnt],ls[rcnt],x,i{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e73ux8861ux6811}{%
\subsection{平衡树}\label{ux5e73ux8861ux6811}}

\hypertarget{ux5e26ux5220ux9664ux4f18ux5148ux961fux5217}{%
\subsection{带删除优先队列}\label{ux5e26ux5220ux9664ux4f18ux5148ux961fux5217}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ que}
\NormalTok{\{}
\NormalTok{    heap\textless{}}\DataTypeTok{int}\NormalTok{,vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{},less\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{}\textgreater{} a,b;}
    \DataTypeTok{int}\NormalTok{ size()\{}\ControlFlowTok{return}\NormalTok{ a.size(){-}b.size();\}}
    \DataTypeTok{bool}\NormalTok{ empty()\{}\ControlFlowTok{return}\NormalTok{ size()==}\DecValTok{0}\NormalTok{;\}}
    \DataTypeTok{void}\NormalTok{ push(}\DataTypeTok{int}\NormalTok{ x)\{a.push(x);\}}
    \DataTypeTok{void}\NormalTok{ del(}\DataTypeTok{int}\NormalTok{ x)\{b.push(x);\}}
    \DataTypeTok{void}\NormalTok{ clear()\{}\ControlFlowTok{while}\NormalTok{(!b.empty()\&\&a.top()==b.top())a.pop(),b.pop();\}}
    \DataTypeTok{int}\NormalTok{ top()\{clear();}\ControlFlowTok{return}\NormalTok{ a.top();\}}
    \DataTypeTok{void}\NormalTok{ pop()\{clear();a.pop();\}}
    \DataTypeTok{int}\NormalTok{ setop()}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ temp=}\KeywordTok{this}\NormalTok{{-}\textgreater{}top(),ans; }\KeywordTok{this}\NormalTok{{-}\textgreater{}pop();}
\NormalTok{        ans=}\KeywordTok{this}\NormalTok{{-}\textgreater{}top(); }\KeywordTok{this}\NormalTok{{-}\textgreater{}push(temp);}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
\NormalTok{\}q;}
\end{Highlighting}
\end{Shaded}

\hypertarget{splay}{%
\subsubsection{1.Splay}\label{splay}}

\hypertarget{treap}{%
\subsubsection{2.Treap}\label{treap}}

\hypertarget{fhq_treapux975eux65cbtreap}{%
\subsubsection{3.FHQ\_treap(非旋Treap)}\label{fhq_treapux975eux65cbtreap}}

\hypertarget{ux6392ux540dux5206ux88c2}{%
\paragraph{排名分裂}\label{ux6392ux540dux5206ux88c2}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ fhq}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ cnt,root;}
    \DataTypeTok{int}\NormalTok{ ch[MAXN][}\DecValTok{2}\NormalTok{],fix[MAXN],siz[MAXN];}
\NormalTok{    LL add[MAXN],val[MAXN],mx[MAXN];}
    \DataTypeTok{bool}\NormalTok{ rev[MAXN];}
    \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ x=root)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls) debug(ls);}
\NormalTok{        cout \textless{}\textless{} dbgs4(x,ls,rs,fix[x]) \textless{}\textless{} endl;}
\NormalTok{        cout \textless{}\textless{} dbgs3(val[x],siz[x],mx[x]) \textless{}\textless{} endl;}
        \ControlFlowTok{if}\NormalTok{(rs) debug(rs);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x=++cnt;}
\NormalTok{        val[x]=mx[x]=}\DecValTok{0}\NormalTok{,siz[x]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fix[x]=rand();}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        siz[x]=siz[ls]+siz[rs]+}\DecValTok{1}\NormalTok{;}
\NormalTok{        mx[x]=val[x];}
        \ControlFlowTok{if}\NormalTok{(ls) mx[x]=max(mx[x],mx[ls]);}
        \ControlFlowTok{if}\NormalTok{(rs) mx[x]=max(mx[x],mx[rs]);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ doAdd(}\DataTypeTok{int}\NormalTok{ x,LL v)\{add[x]+=v,val[x]+=v,mx[x]+=v;\}}
    \DataTypeTok{void}\NormalTok{ doRev(}\DataTypeTok{int}\NormalTok{ x)\{rev[x]\^{}=}\DecValTok{1}\NormalTok{,swap(ls,rs);\}}
    \DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(rev[x])}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(ls) doRev(ls);}
            \ControlFlowTok{if}\NormalTok{(rs) doRev(rs);}
\NormalTok{            rev[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(add[x])}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(ls) doAdd(ls,add[x]);}
            \ControlFlowTok{if}\NormalTok{(rs) doAdd(rs,add[x]);}
\NormalTok{            add[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    pr split(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) }\ControlFlowTok{return}\NormalTok{ \{}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\};}
\NormalTok{        pr t; pushdown(x);}
        \ControlFlowTok{if}\NormalTok{(siz[ls]\textgreater{}=k) t=split(ls,k),ls=t.se,t.se=x;}
        \ControlFlowTok{else}\NormalTok{ t=split(rs,k{-}siz[ls]{-}}\DecValTok{1}\NormalTok{),rs=t.fi,t.fi=x;}
\NormalTok{        pushup(x); }\ControlFlowTok{return}\NormalTok{ t;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(x*y==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ x+y;}
\NormalTok{        pushdown(x),pushdown(y);}
        \ControlFlowTok{if}\NormalTok{(fix[x]\textless{}fix[y])\{ch[x][}\DecValTok{1}\NormalTok{]=merge(ch[x][}\DecValTok{1}\NormalTok{],y);pushup(x);}\ControlFlowTok{return}\NormalTok{ x;\}}
        \ControlFlowTok{else}\NormalTok{\{ch[y][}\DecValTok{0}\NormalTok{]=merge(x,ch[y][}\DecValTok{0}\NormalTok{]);pushup(y);}\ControlFlowTok{return}\NormalTok{ y;\}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,LL v)}
\NormalTok{    \{}
\NormalTok{        pr t1=split(root,l{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        pr t2=split(t1.se,r{-}l+}\DecValTok{1}\NormalTok{);}
\NormalTok{        doAdd(t2.fi,v),pushup(t2.fi);}
\NormalTok{        root=merge(t1.fi,merge(t2.fi,t2.se));}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ reverse(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
\NormalTok{        pr t1=split(root,l{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        pr t2=split(t1.se,r{-}l+}\DecValTok{1}\NormalTok{);}
\NormalTok{        doRev(t2.fi),pushup(t2.fi);}
\NormalTok{        root=merge(t1.fi,merge(t2.fi,t2.se));}
\NormalTok{    \}}
\NormalTok{    LL query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
\NormalTok{        pr t1=split(root,l{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        pr t2=split(t1.se,r{-}l+}\DecValTok{1}\NormalTok{);}
\NormalTok{        LL ans=mx[t2.fi];}
\NormalTok{        root=merge(t1.fi,merge(t2.fi,t2.se));}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) root=merge(root,newnode());}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6743ux503cux5206ux88c2}{%
\paragraph{权值分裂}\label{ux6743ux503cux5206ux88c2}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ fhq}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,node\_cnt;}
    \DataTypeTok{int}\NormalTok{ ch[MAXN][}\DecValTok{2}\NormalTok{],val[MAXN],siz[MAXN],add[MAXN],cnt[MAXN],fix[MAXN];}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} rec;}

    \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ x=root)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls) debug(ls);}
\NormalTok{        cout \textless{}\textless{} dbgs3(x,ls,rs) \textless{}\textless{} }\StringTok{" "}\NormalTok{ \textless{}\textless{} dbgs4(val[x],siz[x],add[x],cnt[x]) \textless{}\textless{} endl;}
        \ControlFlowTok{if}\NormalTok{(rs) debug(rs);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x;}
        \ControlFlowTok{if}\NormalTok{(!rec.empty()) x=rec.back(),rec.ppb();}
        \ControlFlowTok{else}\NormalTok{ x=++node\_cnt;}
\NormalTok{        ls=rs=add[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        siz[x]=cnt[x]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fix[x]=rand();}
\NormalTok{        val[x]=v;}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ doAdd(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)\{val[x]+=v,add[x]+=v;\}}
    \DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(add[x])}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(ls) doAdd(ls,add[x]);}
            \ControlFlowTok{if}\NormalTok{(rs) doAdd(rs,add[x]);}
\NormalTok{            add[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)\{siz[x]=siz[ls]+siz[rs]+cnt[x];\}}
\NormalTok{    pr split(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v) }\CommentTok{//分裂出\textless{}=v的}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) }\ControlFlowTok{return}\NormalTok{ \{}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\};}
\NormalTok{        pr t; pushdown(x);}
        \ControlFlowTok{if}\NormalTok{(val[x]\textless{}=v) t=split(rs,v),rs=t.fi,t.fi=x;}
        \ControlFlowTok{else}\NormalTok{ t=split(ls,v),ls=t.se,t.se=x;}
\NormalTok{        pushup(x);}
        \ControlFlowTok{return}\NormalTok{ t;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(x*y==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ x+y;}
\NormalTok{        pushdown(x),pushdown(y);}
        \ControlFlowTok{if}\NormalTok{(fix[x]\textless{}fix[y])\{ch[x][}\DecValTok{1}\NormalTok{]=merge(ch[x][}\DecValTok{1}\NormalTok{],y);pushup(x);}\ControlFlowTok{return}\NormalTok{ x;\}}
        \ControlFlowTok{else}\NormalTok{\{ch[y][}\DecValTok{0}\NormalTok{]=merge(x,ch[y][}\DecValTok{0}\NormalTok{]);pushup(y);}\ControlFlowTok{return}\NormalTok{ y;\}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
\NormalTok{        pr x=split(root,v);}
\NormalTok{        pr y=split(x.fi,v{-}}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{(y.se)}
\NormalTok{        \{}
\NormalTok{            cnt[y.se]++,pushup(y.se);}
\NormalTok{            root=merge(merge(y.fi,y.se),x.se);}
            \ControlFlowTok{return}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ root=merge(merge(y.fi,newnode(v)),x.se);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ del(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{        rec.pb(x);}
        \ControlFlowTok{if}\NormalTok{(ls) del(ls);}
        \ControlFlowTok{if}\NormalTok{(rs) del(rs);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ kth(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{    \{}
\NormalTok{        pushdown(x);}
        \ControlFlowTok{if}\NormalTok{(k\textgreater{}siz[ls]\&\&k\textless{}=siz[ls]+cnt[x]) }\ControlFlowTok{return}\NormalTok{ val[x];}
        \ControlFlowTok{if}\NormalTok{(siz[ls]\textgreater{}=k) }\ControlFlowTok{return}\NormalTok{ kth(ls,k);}
        \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ kth(rs,k{-}siz[ls]{-}cnt[x]);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ remove(}\DataTypeTok{int}\NormalTok{ line)}
\NormalTok{    \{}
\NormalTok{        pr x=split(root,line{-}}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{(x.fi) ans+=siz[x.fi];}
\NormalTok{        del(x.fi),root=x.se;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux66ffux7f6aux7f8aux6811}{%
\subsubsection{4.替罪羊树}\label{ux66ffux7f6aux7f8aux6811}}

当插入后某颗子树不平衡，就重构这颗子树

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ Scapegoat}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{double}\NormalTok{ alpha = }\FloatTok{0.75}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ root,node\_cnt,last=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ ch[MAXN][}\DecValTok{2}\NormalTok{],fa[MAXN];}
    \DataTypeTok{int}\NormalTok{ siz[MAXN],cnt[MAXN],val[MAXN];}
    \DataTypeTok{int}\NormalTok{ realsiz[MAXN];}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} rec;}

    \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ x=root)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls) debug(ls);}
\NormalTok{        cout \textless{}\textless{} dbgs4(x,val[x],siz[x],cnt[x]) \textless{}\textless{} }\StringTok{" "}\NormalTok{  \textless{}\textless{} dbgs3(ls,rs,fa[x]) \textless{}\textless{} endl;}
        \ControlFlowTok{if}\NormalTok{(rs) debug(rs);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x;}
        \ControlFlowTok{if}\NormalTok{(!rec.empty()) x=rec.back(),rec.ppb();}
        \ControlFlowTok{else}\NormalTok{ x=++node\_cnt;}
\NormalTok{        realsiz[x]=cnt[x]=siz[x]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        ls=rs=}\DecValTok{0}\NormalTok{,val[x]=v,fa[x]=par;}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        siz[x]=siz[ls]+cnt[x]+siz[rs];}
\NormalTok{        realsiz[x]=realsiz[ls]+realsiz[rs]+}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{bool}\NormalTok{ balance(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{return}\NormalTok{ realsiz[ls]\textless{}=realsiz[x]*alpha\&\&realsiz[rs]\textless{}=realsiz[x]*alpha;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{node\_cnt=}\DecValTok{0}\NormalTok{;rec.clear();\}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x)\{x=newnode(v,par);}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(val[x]==v)\{cnt[x]++,siz[x]++;}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(v\textless{}val[x]) insert(ls,v,x);}
        \ControlFlowTok{else}\NormalTok{ insert(rs,v,x);}
\NormalTok{        pushup(x); }\ControlFlowTok{if}\NormalTok{(!balance(x)) last=x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ remove(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(val[x]==v)\{}\ControlFlowTok{if}\NormalTok{(cnt[x])cnt[x]{-}{-},siz[x]{-}{-};}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(v\textless{}val[x]) remove(ls,v);}
        \ControlFlowTok{else}\NormalTok{ remove(rs,v);}
\NormalTok{        pushup(x);}
\NormalTok{    \}}
    \KeywordTok{inline} \DataTypeTok{bool}\NormalTok{ chk(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ ch[fa[x]][}\DecValTok{1}\NormalTok{]==x;\}}
    \DataTypeTok{int}\NormalTok{ seq[MAXN],n=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls) dfs(ls);}
        \ControlFlowTok{if}\NormalTok{(cnt[x]) seq[++n]=x;}
        \ControlFlowTok{else}\NormalTok{ rec.pb(x);}
        \ControlFlowTok{if}\NormalTok{(rs) dfs(rs);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(r\textless{}l) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \DataTypeTok{int}\NormalTok{ x=seq[mid];}
\NormalTok{        ls=build(l,mid{-}}\DecValTok{1}\NormalTok{,x);}
\NormalTok{        rs=build(mid+}\DecValTok{1}\NormalTok{,r,x);}
\NormalTok{        fa[x]=par,pushup(x);}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ rebuild()}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!last) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{        n=}\DecValTok{0}\NormalTok{,dfs(last);}
        \ControlFlowTok{if}\NormalTok{(!fa[last]) root=build(}\DecValTok{1}\NormalTok{,n,}\DecValTok{0}\NormalTok{);}
        \ControlFlowTok{else}\NormalTok{ ch[fa[last]][chk(last)]=build(}\DecValTok{1}\NormalTok{,n,fa[last]);}
\NormalTok{        last=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}

    \DataTypeTok{int}\NormalTok{ rank(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(val[x]==v) }\ControlFlowTok{return}\NormalTok{ siz[ls];}
        \ControlFlowTok{if}\NormalTok{(v\textless{}val[x]) }\ControlFlowTok{return}\NormalTok{ rank(ls,v);}
        \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ siz[ls]+cnt[x]+rank(rs,v);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ kth(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\textgreater{}siz[ls]\&\&k\textless{}=siz[ls]+cnt[x]) }\ControlFlowTok{return}\NormalTok{ val[x];}
        \ControlFlowTok{if}\NormalTok{(siz[ls]\textgreater{}=k) }\ControlFlowTok{return}\NormalTok{ kth(ls,k);}
        \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ kth(rs,k{-}siz[ls]{-}cnt[x]);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ pre(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ k=rank(root,v);}
        \ControlFlowTok{return}\NormalTok{ kth(root,k);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ aft(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ k=rank(root,v+}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{return}\NormalTok{ kth(root,k+}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Scapegoat;}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    init();}
    \DataTypeTok{int}\NormalTok{ T;}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ opt,x; scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&opt,\&x);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{) insert(root,x,}\DecValTok{0}\NormalTok{),rebuild();}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{2}\NormalTok{) remove(root,x);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{3}\NormalTok{) printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,Scapegoat::rank(root,x)+}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{4}\NormalTok{) printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,kth(root,x));}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{5}\NormalTok{) printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,pre(x));}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{6}\NormalTok{) printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,aft(x));}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux88655.ux53efux6301ux4e45ux5316ux5e73ux8861ux6811}{%
\subsubsection{(待补)5.可持久化平衡树}\label{ux5f85ux88655.ux53efux6301ux4e45ux5316ux5e73ux8861ux6811}}

\hypertarget{lct}{%
\subsection{LCT}\label{lct}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ls}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{ch[x][}\DecValTok{0}\NormalTok{]}
\PreprocessorTok{\#define rs}\NormalTok{(x)}\PreprocessorTok{ }\NormalTok{ch[x][}\DecValTok{1}\NormalTok{]}
\DataTypeTok{bool}\NormalTok{ rev[MAXN];}
\DataTypeTok{int}\NormalTok{ fa[MAXN],ch[MAXN][}\DecValTok{2}\NormalTok{],val[MAXN],sum[MAXN];}
\DataTypeTok{int}\NormalTok{ h,q[MAXN];}
\DataTypeTok{bool}\NormalTok{ isroot(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ !fa[x]||(ls(fa[x])!=x\&\&rs(fa[x])!=x);\}}
\DataTypeTok{void}\NormalTok{ dorev(}\DataTypeTok{int}\NormalTok{ x)\{rev[x]\^{}=}\DecValTok{1}\NormalTok{,swap(ls(x),rs(x));\}}
\DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(rev[x])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls(x))dorev(ls(x));}
        \ControlFlowTok{if}\NormalTok{(rs(x))dorev(rs(x));}
\NormalTok{        rev[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{   }
\NormalTok{    sum[x]=val[x];}
    \ControlFlowTok{if}\NormalTok{(ls(x))sum[x]\^{}=sum[ls(x)];}
    \ControlFlowTok{if}\NormalTok{(rs(x))sum[x]\^{}=sum[rs(x)];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ rotate(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ y=fa[x],z=fa[y],w=(ch[y][}\DecValTok{1}\NormalTok{]==x);}
\NormalTok{    ch[y][w]=ch[x][w\^{}}\DecValTok{1}\NormalTok{];}
    \ControlFlowTok{if}\NormalTok{(ch[x][w\^{}}\DecValTok{1}\NormalTok{])fa[ch[x][w\^{}}\DecValTok{1}\NormalTok{]]=y;}
    \ControlFlowTok{if}\NormalTok{(z)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls(z)==y)ls(z)=x;}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(rs(z)==y)rs(z)=x;}
\NormalTok{    \}}
\NormalTok{    fa[x]=fa[y],fa[y]=x,ch[x][w\^{}}\DecValTok{1}\NormalTok{]=y;}
\NormalTok{    up(y),up(x);}\ControlFlowTok{if}\NormalTok{(z)up(z);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ splay(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ t=x; }\ControlFlowTok{while}\NormalTok{(!isroot(t)) q[++h]=t,t=fa[t]; q[++h]=t;}
    \ControlFlowTok{while}\NormalTok{(h) pushdown(q[h{-}{-}]);}
    \ControlFlowTok{while}\NormalTok{(!isroot(x))}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ y=fa[x];}
        \ControlFlowTok{if}\NormalTok{(!isroot(y))}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{((ls(fa[y])==y)\^{}(ls(y)==x))rotate(x);}
            \ControlFlowTok{else}\NormalTok{ rotate(y);}
\NormalTok{        \}}
\NormalTok{        rotate(x);}
\NormalTok{    \}}
\NormalTok{    pushup(x);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ access(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ y=}\DecValTok{0}\NormalTok{;x;y=x,x=fa[x])splay(x),rs(x)=y,pushup(x);\}}
\DataTypeTok{void}\NormalTok{ makeroot(}\DataTypeTok{int}\NormalTok{ x)\{access(x),splay(x),dorev(x);\}}
\DataTypeTok{int}\NormalTok{ findroot(}\DataTypeTok{int}\NormalTok{ x)\{access(x),splay(x);}\ControlFlowTok{while}\NormalTok{(ls(x))x=ls(x);}\ControlFlowTok{return}\NormalTok{ x;\}}
\DataTypeTok{void}\NormalTok{ link(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)\{makeroot(x);}\ControlFlowTok{if}\NormalTok{(findroot(y)==x)}\ControlFlowTok{return}\NormalTok{;fa[x]=y,access(x);\}}
\DataTypeTok{void}\NormalTok{ cutfa(}\DataTypeTok{int}\NormalTok{ x)\{access(x),splay(x);fa[ls(x)]=}\DecValTok{0}\NormalTok{,ls(x)=}\DecValTok{0}\NormalTok{,pushup(x);\}}
\DataTypeTok{void}\NormalTok{ cut(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)\{makeroot(x),access(y),splay(y);}\ControlFlowTok{if}\NormalTok{(ls(y)!=x)}\ControlFlowTok{return}\NormalTok{;cutfa(y);\}}
\DataTypeTok{void}\NormalTok{ change(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)\{splay(x),val[x]=v;\}}
\DataTypeTok{void}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)\{makeroot(x),access(y),splay(y);printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,sum[y]);\} }\CommentTok{//别忘记splay}
\end{Highlighting}
\end{Shaded}

用法总结参考自：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \href{https://www.cnblogs.com/flashhu/p/9498517.html}{LCT总结------应用篇（附题单）（LCT）FlashHu}
\item
  \href{https://blog.csdn.net/snowy_smile/article/details/79120055}{LCT模板
  LCT题型大荟萃 snowy\_smile}
\end{enumerate}

虚边 u-\textgreater v(fa{[}u{]}=v\&\&ls(v)!=u\&\&rs(v)!=u)
对应树上的边为 findroot(u) -\textgreater{} v

\hypertarget{lct-ux7ef4ux62a4ux8fb9ux53cc}{%
\subsubsection{LCT 维护边双}\label{lct-ux7ef4ux62a4ux8fb9ux53cc}}

BZOJ2959

\hypertarget{lct-ux7ef4ux62a4ux5185ux5411ux57faux73afux6811}{%
\subsubsection{LCT
维护内向基环树}\label{lct-ux7ef4ux62a4ux5185ux5411ux57faux73afux6811}}

\hypertarget{lct-ux7ef4ux62a4ux865aux5b50ux6811ux4fe1ux606f}{%
\subsubsection{LCT
维护虚子树信息}\label{lct-ux7ef4ux62a4ux865aux5b50ux6811ux4fe1ux606f}}

假设维护树的大小 \(siz[x]\)，为每个点新增一个 \(\_siz[x]\)
表示所有虚儿子的 \(siz\) 之和

对 \(LCT\) 的模板操作进行一些修改：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(pushup\): \(siz[x]=siz[ls]+siz[rs]+\_siz[x]\)
\item
  \(splay\): 无影响，不改变虚边连接，信息会经由 \(pushup\) 正确更新
\item
  \(access\): x-\textgreater rs(x) 虚变实, x-\textgreater y 实变虚
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ access(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ y=}\DecValTok{0}\NormalTok{;x;y=x,x=fa[x])}
\NormalTok{    \{}
\NormalTok{        splay(x);}
\NormalTok{        \_siz[x]+=siz[rs(x)];}
\NormalTok{        \_siz[x]{-}=siz[y];}
\NormalTok{        rs(x)=y,up(x);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  \(makeroot\)：无影响
\item
  \(findroot\)：无影响
\item
  \(link\)：x-\textgreater y 会使 \(y\) 新增一个虚儿子，注意要把 \(y\)
  转到根(\(access+splay\))，不然会对 \(y\) 到根的路径上的 \(siz\) 与
  \(\_siz\) 产生影响
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ link(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{\{}
\NormalTok{    makeroot(x),makeroot(y),}
\NormalTok{    splay(y),}
\NormalTok{    fa[x]=y,}
\NormalTok{    \_siz[y]+=siz[x],}
\NormalTok{    up(y),}
\NormalTok{    access(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  \(cut\): x-\textgreater y 断掉一条实边，\(pushup\)即可
\end{enumerate}

若维护的是最大值等信息，则需用 \(set\)
等数据结构来维护虚儿子的答案，复杂度多一个 \(log\)

\hypertarget{lct-ux7ef4ux62a4ux6811ux4e0aux8defux5f84ux4fe1ux606f}{%
\subsubsection{LCT
维护树上路径信息}\label{lct-ux7ef4ux62a4ux6811ux4e0aux8defux5f84ux4fe1ux606f}}

\hypertarget{lct-ux7ef4ux62a4ux540cux8272ux8054ux901aux5757}{%
\subsubsection{LCT
维护同色联通块}\label{lct-ux7ef4ux62a4ux540cux8272ux8054ux901aux5757}}

\hypertarget{ux5de6ux504fux6811ux53efux5e76ux5806}{%
\subsection{左偏树(可并堆)}\label{ux5de6ux504fux6811ux53efux5e76ux5806}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,v;}
\KeywordTok{struct}\NormalTok{ \{}\DataTypeTok{int}\NormalTok{ dis,val,ch[}\DecValTok{2}\NormalTok{],rt;\}t[MAXN];}
\DataTypeTok{int}\NormalTok{ find(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ t[x].rt==x?x:t[x].rt=find(t[x].rt);\}}
\DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(x*y==}\DecValTok{0}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ x+y;}
    \ControlFlowTok{if}\NormalTok{((t[x].val\textgreater{}t[y].val)||(t[x].val==t[y].val\&\&x\textgreater{}y))swap(x,y);}
\NormalTok{    rs=merge(rs,y);}
    \ControlFlowTok{if}\NormalTok{(t[ls].dis\textless{}t[rs].dis)swap(ls,rs);}
\NormalTok{    t[x].dis=t[rs].dis+}\DecValTok{1}\NormalTok{,t[ls].rt=t[rs].rt=x;}
    \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ pop(}\DataTypeTok{int}\NormalTok{ x)\{t[x].val={-}}\DecValTok{1}\NormalTok{,t[ls].rt=ls,t[rs].rt=rs,t[x].rt=merge(ls,rs);\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m),t[}\DecValTok{0}\NormalTok{].dis={-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&v),t[i].rt=i,t[i].val=v;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ opt,x,y;scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&opt);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&x,\&y);}
            \ControlFlowTok{if}\NormalTok{(t[x].val=={-}}\DecValTok{1}\NormalTok{||t[y].val=={-}}\DecValTok{1}\NormalTok{)}\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{            x=find(x),y=find(y);}
            \ControlFlowTok{if}\NormalTok{(x!=y)t[x].rt=t[y].rt=merge(x,y);}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{2}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&x);}
            \ControlFlowTok{if}\NormalTok{(t[x].val=={-}}\DecValTok{1}\NormalTok{)puts(}\StringTok{"{-}1"}\NormalTok{);}
            \ControlFlowTok{else}\NormalTok{ x=find(x),printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,t[x].val),pop(x);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5355ux8c03ux6808-ux5355ux8c03ux961fux5217}{%
\subsection{单调栈 \&
单调队列}\label{ux5355ux8c03ux6808-ux5355ux8c03ux961fux5217}}

\hypertarget{ux6811ux94feux5256ux5206}{%
\subsection{树链剖分}\label{ux6811ux94feux5256ux5206}}

\hypertarget{ux91cdux94feux5256ux5206}{%
\subsubsection{1.重链剖分}\label{ux91cdux94feux5256ux5206}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,root;}
\NormalTok{LL  a[MAXN],w[MAXN];}
\DataTypeTok{int}\NormalTok{ pre[MAXN];}

\DataTypeTok{int}\NormalTok{ st[MAXN],ed[MAXN],cnt; }\CommentTok{//维护子树和}
\DataTypeTok{int}\NormalTok{ top[MAXN],deep[MAXN],fa[MAXN],son[MAXN],siz[MAXN];}

\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e = \{edge()\};}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{e.pb(\{u,v,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}

\DataTypeTok{void}\NormalTok{ dfs1(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    siz[u]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa[u])}
\NormalTok{    \{}
\NormalTok{        deep[v]=deep[u]+}\DecValTok{1}\NormalTok{,fa[v]=u,dfs1(v),siz[u]+=siz[v];}
        \ControlFlowTok{if}\NormalTok{(siz[v]\textgreater{}siz[son[u]]) son[u]=v;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs2(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ tp)}
\NormalTok{\{}
\NormalTok{    st[u]=++cnt,top[u]=tp;}
    \ControlFlowTok{if}\NormalTok{(!son[u])\{ed[u]=cnt;}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{    dfs2(son[u],tp);}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa[u]\&\&v!=son[u])dfs2(v,v);}
\NormalTok{    ed[u]=  cnt;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ fu=top[u],fv=top[v];}
    \ControlFlowTok{while}\NormalTok{(fu!=fv)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(deep[fu]\textless{}deep[fv])}
\NormalTok{            swap(u,v),swap(fu,fv);}
\NormalTok{        ans+=sgt::query(}\DecValTok{1}\NormalTok{,n,st[fu],st[u],}\DecValTok{1}\NormalTok{),ans\%=MOD;}
\NormalTok{        u=fa[fu],fu=top[u];}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(st[u]\textgreater{}st[v]) swap(u,v);}
\NormalTok{    io.write((ans+sgt::query(}\DecValTok{1}\NormalTok{,n,st[u],st[v],}\DecValTok{1}\NormalTok{))\%MOD),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,LL add)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ fu=top[u],fv=top[v];}
    \ControlFlowTok{while}\NormalTok{(fu!=fv)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(deep[fu]\textless{}deep[fv])}
\NormalTok{            swap(u,v),swap(fu,fv);}
\NormalTok{        sgt::update(}\DecValTok{1}\NormalTok{,n,st[fu],st[u],add,}\DecValTok{1}\NormalTok{);}
\NormalTok{        u=fa[fu],fu=top[u];}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(st[u]\textgreater{}st[v]) swap(u,v);}
\NormalTok{    sgt::update(}\DecValTok{1}\NormalTok{,n,st[u],st[v],add,}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    deep[root]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    dfs1(root),dfs2(root,root);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) w[st[i]]=a[i];}
\NormalTok{    sgt::build(w,}\DecValTok{1}\NormalTok{,n,}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(m),io.read(root),io.read(MOD);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) io.read(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{        io.read(u),io.read(v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    init();}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ opt,x,y; LL z;}
\NormalTok{        io.read(opt);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{) io.read(x),io.read(y),io.read(z),update(x,y,z);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{2}\NormalTok{) io.read(x),io.read(y),query(x,y);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{3}\NormalTok{) io.read(x),io.read(z),sgt::update(}\DecValTok{1}\NormalTok{,n,st[x],ed[x],z,}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{4}\NormalTok{) io.read(x),io.write(sgt::query(}\DecValTok{1}\NormalTok{,n,st[x],ed[x],}\DecValTok{1}\NormalTok{)),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}

    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{dsu-on-tree}{%
\subsubsection{2.dsu on tree}\label{dsu-on-tree}}

树上启发式合并 用来解决一类子树询问问题

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{int}\NormalTok{ d[MAXN],sz[MAXN],son[MAXN],c[MAXN];}
\NormalTok{LL ans[MAXN];}
\DataTypeTok{bool}\NormalTok{ big[MAXN];}
\DataTypeTok{void}\NormalTok{ getson(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    sz[u]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
\NormalTok{        getson(v,u),sz[u]+=sz[v];}
        \ControlFlowTok{if}\NormalTok{(sz[v]\textgreater{}sz[son[u]])son[u]=v;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ MX,cnt[MAXN];LL num;}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{\{}
\NormalTok{    cnt[c[u]]+=val;}
    \ControlFlowTok{if}\NormalTok{(cnt[c[u]]\textgreater{}MX) MX=cnt[c[u]],num=c[u];}
    \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(cnt[c[u]]==MX) num+=c[u];}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
        \ControlFlowTok{if}\NormalTok{(v!=fa\&\&!big[v])}
\NormalTok{            add(v,u,val);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa,}\DataTypeTok{bool}\NormalTok{ keep)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
        \ControlFlowTok{if}\NormalTok{(v!=fa\&\&v!=son[u])}
\NormalTok{            solve(v,u,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{(son[u]) solve(son[u],u,}\DecValTok{1}\NormalTok{),big[son[u]]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    add(u,fa,}\DecValTok{1}\NormalTok{),big[son[u]]=}\DecValTok{0}\NormalTok{,ans[u]=num;}
    \ControlFlowTok{if}\NormalTok{(!keep) add(u,fa,{-}}\DecValTok{1}\NormalTok{),MX=num=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&c[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        G[u].pb(v),G[v].pb(u);}
\NormalTok{    \}}
\NormalTok{    getson(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{),solve(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{ "}\NormalTok{,ans[i]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{rmq-ux4e8cux7ef4rmq-stux8868}{%
\subsection{RMQ \& 二维RMQ (ST表)}\label{rmq-ux4e8cux7ef4rmq-stux8868}}

\hypertarget{ux4e00ux7ef4stux8868}{%
\subsubsection{1.一维ST表}\label{ux4e00ux7ef4stux8868}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,a[MAXN],f[MAXN][}\DecValTok{20}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ init\_st()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) f[i][}\DecValTok{0}\NormalTok{]=a[i];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;(}\DecValTok{1}\NormalTok{\textless{}\textless{}j)\textless{}=n;j++)}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}j){-}}\DecValTok{1}\NormalTok{\textless{}=n;i++)}
\NormalTok{            f[i][j]=max(f[i][j{-}}\DecValTok{1}\NormalTok{],f[i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}(j{-}}\DecValTok{1}\NormalTok{))][j{-}}\DecValTok{1}\NormalTok{]);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ k=log2(r{-}l+}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{return}\NormalTok{ max(f[l][k],f[r{-}(}\DecValTok{1}\NormalTok{\textless{}\textless{}k)+}\DecValTok{1}\NormalTok{][k]);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux7ef4stux8868}{%
\subsubsection{2.二维ST表}\label{ux4e8cux7ef4stux8868}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//询问矩形内最大值}
\DataTypeTok{int}\NormalTok{ n,m,q;}
\DataTypeTok{int}\NormalTok{ a[MAXN][MAXN];}
\DataTypeTok{int}\NormalTok{ f[MAXN][MAXN][}\DecValTok{9}\NormalTok{][}\DecValTok{9}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ init\_st()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=m;j++)}
\NormalTok{            f[i][j][}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]=a[i][j];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x=}\DecValTok{0}\NormalTok{;(}\DecValTok{1}\NormalTok{\textless{}\textless{}x)\textless{}=n;x++)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ y=}\DecValTok{0}\NormalTok{;(}\DecValTok{1}\NormalTok{\textless{}\textless{}y)\textless{}=m;y++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(x+y==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{continue}\NormalTok{;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}x){-}}\DecValTok{1}\NormalTok{\textless{}=n;i++)}
\NormalTok{            \{}
                \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j+(}\DecValTok{1}\NormalTok{\textless{}\textless{}y){-}}\DecValTok{1}\NormalTok{\textless{}=m;j++)}
\NormalTok{                \{}
                    \ControlFlowTok{if}\NormalTok{(x) f[i][j][x][y]=max(f[i][j][x{-}}\DecValTok{1}\NormalTok{][y],}
\NormalTok{                        f[i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}(x{-}}\DecValTok{1}\NormalTok{))][j][x{-}}\DecValTok{1}\NormalTok{][y]);}
                    \ControlFlowTok{else}\NormalTok{ f[i][j][x][y]=max(f[i][j][x][y{-}}\DecValTok{1}\NormalTok{],}
\NormalTok{                       f[i][j+(}\DecValTok{1}\NormalTok{\textless{}\textless{}(y{-}}\DecValTok{1}\NormalTok{))][x][y{-}}\DecValTok{1}\NormalTok{]);}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ x1,}\DataTypeTok{int}\NormalTok{ y1,}\DataTypeTok{int}\NormalTok{ x2,}\DataTypeTok{int}\NormalTok{ y2)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x=log2(x2{-}x1+}\DecValTok{1}\NormalTok{),y=log2(y2{-}y1+}\DecValTok{1}\NormalTok{);}
\NormalTok{    x2=x2{-}(}\DecValTok{1}\NormalTok{\textless{}\textless{}x)+}\DecValTok{1}\NormalTok{;}
\NormalTok{    y2=y2{-}(}\DecValTok{1}\NormalTok{\textless{}\textless{}y)+}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ max(max(f[x1][y1][x][y],f[x2][y1][x][y]),}
\NormalTok{       max(f[x1][y2][x][y],f[x2][y2][x][y]));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux83abux961f}{%
\subsection{莫队}\label{ux83abux961f}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ MO}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{int}\NormalTok{ SZ = }\DecValTok{1500}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ id(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ (x{-}}\DecValTok{1}\NormalTok{)/SZ + }\DecValTok{1}\NormalTok{;\}}
    \KeywordTok{struct}\NormalTok{ query}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l,r,index,ans;}
        \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ query \&t)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(id(l)!=id(t.l)) }\ControlFlowTok{return}\NormalTok{ id(l)\textless{}id(t.l);}
            \ControlFlowTok{if}\NormalTok{(id(l)\&}\DecValTok{1}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ r\textless{}t.r;}
            \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ r\textgreater{}t.r; }
\NormalTok{        \}}
\NormalTok{    \}q[MAXN];}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m);}
        \DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,r=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(r\textless{}q[i].r) update(a[r+}\DecValTok{1}\NormalTok{],}\DecValTok{1}\NormalTok{),r++;}
            \ControlFlowTok{while}\NormalTok{(r\textgreater{}q[i].r) update(a[r], {-}}\DecValTok{1}\NormalTok{),r{-}{-};}
            \ControlFlowTok{while}\NormalTok{(l\textless{}q[i].l) update(a[l], {-}}\DecValTok{1}\NormalTok{),l++;}
            \ControlFlowTok{while}\NormalTok{(l\textgreater{}q[i].l) update(a[l{-}}\DecValTok{1}\NormalTok{],}\DecValTok{1}\NormalTok{),l{-}{-};}
\NormalTok{            q[i].ans=Div::query();}
\NormalTok{        \}}
\NormalTok{        sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m,[](query \&a,query \&b)\{}\ControlFlowTok{return}\NormalTok{ a.index\textless{}b.index;\});}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m) io.write(q[i].ans),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}    }
\NormalTok{\}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ MO;}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e26ux4feeux83abux961f}{%
\subsubsection{带修莫队}\label{ux5e26ux4feeux83abux961f}}

考虑在莫队的基础上再增加一维时间，修改相当于时间维度的变化

\(O(n^{\frac{5}{3}})\)，块大小取 \(n^{\frac{2}{3}}\)

带修数颜色

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,tim,k,ans;}
\DataTypeTok{int}\NormalTok{ a[MAXN],cnt[N];}
\DataTypeTok{int}\NormalTok{ BLOCK;}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ id(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ x/BLOCK;    }
\NormalTok{\}}
\KeywordTok{struct}\NormalTok{ update\{}\DataTypeTok{int}\NormalTok{ x,from,to;\}b[MAXN];}
\KeywordTok{struct}\NormalTok{ query}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l,r,t;}
    \DataTypeTok{int}\NormalTok{ i,ans;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(query \&x)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(id(l)!=id(x.l))}\ControlFlowTok{return}\NormalTok{ id(l)\textless{}id(x.l);}
        \ControlFlowTok{if}\NormalTok{(id(r)!=id(x.r))}\ControlFlowTok{return}\NormalTok{ id(r)\textless{}id(x.r);}
        \ControlFlowTok{return}\NormalTok{ t\textless{}x.t;}
\NormalTok{    \}}
\NormalTok{\}q[MAXN];}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ val,}\DataTypeTok{int}\NormalTok{ f)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(cnt[val]==}\DecValTok{0}\NormalTok{\&\&f== }\DecValTok{1}\NormalTok{)ans++;}
    \ControlFlowTok{if}\NormalTok{(cnt[val]==}\DecValTok{1}\NormalTok{\&\&f=={-}}\DecValTok{1}\NormalTok{)ans{-}{-};}
\NormalTok{    cnt[val]+=f;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m); BLOCK = max(}\DecValTok{1}\NormalTok{,(}\DataTypeTok{int}\NormalTok{)pow(n,}\FloatTok{2.0}\NormalTok{/}\FloatTok{3.0}\NormalTok{));}
    \CommentTok{//O(n\^{}(5/3)) BLOCK = n\^{}(2/3)}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{char}\NormalTok{ s[}\DecValTok{5}\NormalTok{];}\DataTypeTok{int}\NormalTok{ x,y;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%s\%d\%d}\StringTok{"}\NormalTok{,s,\&x,\&y);}
        \ControlFlowTok{if}\NormalTok{(s[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{)q[++k]=\{x,y,tim,i\};}
        \ControlFlowTok{if}\NormalTok{(s[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}R\textquotesingle{}}\NormalTok{)b[++tim]=\{x,a[x],y\},a[x]=y;}
\NormalTok{    \}}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+k);}
\NormalTok{    rg }\DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,r=}\DecValTok{0}\NormalTok{,cur=tim;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,k)}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(r\textless{}q[i].r)r++,add(a[r],}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{while}\NormalTok{(l\textgreater{}q[i].l)l{-}{-},add(a[l],}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{while}\NormalTok{(r\textgreater{}q[i].r)add(a[r],{-}}\DecValTok{1}\NormalTok{),r{-}{-};}
        \ControlFlowTok{while}\NormalTok{(l\textless{}q[i].l)add(a[l],{-}}\DecValTok{1}\NormalTok{),l++;}
        \ControlFlowTok{while}\NormalTok{(cur\textless{}q[i].t)}
\NormalTok{        \{}
\NormalTok{            cur++;}
            \ControlFlowTok{if}\NormalTok{(b[cur].x\textgreater{}=l\&\&b[cur].x\textless{}=r)}
\NormalTok{                add(b[cur].from,{-}}\DecValTok{1}\NormalTok{),add(b[cur].to,}\DecValTok{1}\NormalTok{);}
\NormalTok{            a[b[cur].x]=b[cur].to;}
\NormalTok{        \}}
        \ControlFlowTok{while}\NormalTok{(cur\textgreater{}q[i].t)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(b[cur].x\textgreater{}=l\&\&b[cur].x\textless{}=r)}
\NormalTok{                add(b[cur].from,}\DecValTok{1}\NormalTok{),add(b[cur].to,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{            a[b[cur].x]=b[cur].from;}
\NormalTok{            cur{-}{-};}
\NormalTok{        \}}
\NormalTok{        q[i].ans=ans;}
\NormalTok{    \}}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+k,[](query \&a,query \&b)\{}\ControlFlowTok{return}\NormalTok{ a.i\textless{}b.i;\});}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,k)printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,q[i].ans);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6811ux4e0aux83abux961f}{%
\subsubsection{树上莫队}\label{ux6811ux4e0aux83abux961f}}

树上数颜色

王室联邦分块

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ B = }\DecValTok{500}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ par[MAXN];}
\DataTypeTok{int}\NormalTok{ bel[MAXN],block\_cnt;}
\DataTypeTok{int}\NormalTok{ s[MAXN],top;}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u=}\DecValTok{1}\NormalTok{,}\DataTypeTok{int}\NormalTok{ fa=}\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ bottom = top; par[u]=fa;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
\NormalTok{        dfs(v,u);}
        \ControlFlowTok{if}\NormalTok{(top{-}bottom\textgreater{}=B)}
\NormalTok{        \{}
\NormalTok{            block\_cnt++;            }
\NormalTok{            fp(i,bottom+}\DecValTok{1}\NormalTok{,top)}
\NormalTok{                bel[s[i]]=block\_cnt;}
\NormalTok{            top=bottom;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    s[++top]=u;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ a[MAXN],cnt[MAXN],cur\_ans;}
\DataTypeTok{bool}\NormalTok{ v[MAXN];}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ f=v[u]?{-}}\DecValTok{1}\NormalTok{:}\DecValTok{1}\NormalTok{,x=a[u];}
    \ControlFlowTok{if}\NormalTok{(cnt[x]==}\DecValTok{0}\NormalTok{\&\&f== }\DecValTok{1}\NormalTok{)cur\_ans++;}
    \ControlFlowTok{if}\NormalTok{(cnt[x]==}\DecValTok{1}\NormalTok{\&\&f=={-}}\DecValTok{1}\NormalTok{)cur\_ans{-}{-};}
\NormalTok{    cnt[x]+=f,v[u]\^{}=}\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ move(}\DataTypeTok{int}\NormalTok{ cl,}\DataTypeTok{int}\NormalTok{ tl)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l=lca::query(cl,tl);}
    \ControlFlowTok{while}\NormalTok{(cl!=l)add(cl),cl=par[cl];}
    \ControlFlowTok{while}\NormalTok{(tl!=l)add(tl),tl=par[tl];}
\NormalTok{\}}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ init()\{mst(cnt,}\DecValTok{0}\NormalTok{),mst(v,}\DecValTok{0}\NormalTok{),cur\_ans=block\_cnt=}\DecValTok{0}\NormalTok{,X.clear();\}}
\KeywordTok{struct}\NormalTok{ query\{}\DataTypeTok{int}\NormalTok{ l,r,i,ans;\}q[MAXN];}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m)!=EOF)}
\NormalTok{    \{}
\NormalTok{        init();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]),X.pb(a[i]);}
\NormalTok{        sort(all(X)),unq(X);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)a[i]=lb(all(X),a[i]){-}X.begin()+}\DecValTok{1}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{            addedge(u,v),addedge(v,u);}
\NormalTok{        \}}
\NormalTok{        dfs();block\_cnt++;}\ControlFlowTok{while}\NormalTok{(top)s[top{-}{-}]=block\_cnt;}
\NormalTok{        lca::init();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&q[i].l,\&q[i].r),q[i].i=i;}
\NormalTok{        sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m,[](}\AttributeTok{const}\NormalTok{ query \&x,}\AttributeTok{const}\NormalTok{ query \&y)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(bel[x.l]!=bel[y.l])}\ControlFlowTok{return}\NormalTok{ bel[x.l]\textless{}bel[y.l];}
            \ControlFlowTok{return}\NormalTok{ bel[x.r]\textless{}bel[y.r];}
\NormalTok{        \});}
        \DataTypeTok{int}\NormalTok{ cl=}\DecValTok{1}\NormalTok{,cr=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
\NormalTok{            move(cl,q[i].l),move(cr,q[i].r),cl=q[i].l,cr=q[i].r;}
            \DataTypeTok{int}\NormalTok{ l=lca::query(cl,cr); add(l),q[i].ans=cur\_ans,add(l);}
\NormalTok{        \}}
\NormalTok{        sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m,[](}\AttributeTok{const}\NormalTok{ query \&x,}\AttributeTok{const}\NormalTok{ query \&y)\{}\ControlFlowTok{return}\NormalTok{ x.i\textless{}y.i;\});}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,q[i].ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux56deux6edaux83abux961f}{%
\subsubsection{回滚莫队}\label{ux56deux6edaux83abux961f}}

\hypertarget{ux5177ux4f53ux6b65ux9aa4}{%
\paragraph{具体步骤}\label{ux5177ux4f53ux6b65ux9aa4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  对询问离线并排序，以左端点所在块号为第一关键字，右端点大小为第二关键字进行排序
\item
  以块号递增的顺序处理询问，每次只考虑左端点在该块内的询问
\item
  暴力回答所有左右端点都在块内的询问
\item
  记当前块号为 \(k\)，区间为
  \([st[k],ed[k]]\)，考虑剩下的询问，显然询问的右端点都大于 \(ed[k]\)
  并且递增
\item
  记当前已求得答案的区间为 \([l,r]\)，答案为
  \(pre\)，若该询问是该块内的第一次询问则初始化区间为
  \([l=ed[k]+1, r=ed[k]]\)
\item
  扩展 \(r\) 至当前询问的右边界，并更新答案 \(pre\)
\item
  建立临时变量 \(ans=pre\)，扩展 \(l\) 至当前询问的左边界，并更新答案
  \(ans\)，扩展完毕后用 \(ans\) 回答当前询问
\item
  回撤左端点 \(l\) 至 \(ed[k]+1\)，并\textbf{撤销扩展 \(l\)
  时对辅助变量的更改}，保留 \(pre\) 用于下次询问（即回撤区间至
  \([ed[k],r]\)）
\end{enumerate}

这样我们就实现了区间只增不减的莫队，步骤 8
中撤销左边界的具体实现视所用辅助变量而定，例如桶的话就
\(cnt[value]--\)，并查集的话用按秩合以支持撤销操作。

分析下复杂度，假定 \(n\) 和 \(m\) 同数量级，取块大小
\(B = \sqrt{n}\)，暴力处理块内询问
\(O(\sqrt{n})\)，每个块内右端点至多扩展 \(n\) 次
\(O(n\sqrt{n})\)，左端点每次最多扩展和撤销 \(\sqrt{n}\)
次，因此总复杂度仍为 \(O(n\sqrt{n})\)。

\hypertarget{ux6a21ux677f-2}{%
\paragraph{模板}\label{ux6a21ux677f-2}}

\href{https://www.luogu.com.cn/problem/AT1219}{AtCoder1219 历史研究}

扩展右端点：\texttt{cnt{[}x{]}++,pre=max(pre,cnt{[}x{]}*x)}

扩展右端点：\texttt{cnt{[}x{]}++,ans=max(ans,cnt{[}x{]}*x)}

回撤左端点：\texttt{cnt{[}x{]}-\/-}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ SZ = sqrt(MAXN);}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}
\DataTypeTok{int}\NormalTok{ n,m,z;}
\DataTypeTok{int}\NormalTok{ a[MAXN],b[MAXN],cnt[MAXN],id[MAXN],st[MAXN],ed[MAXN],t[MAXN];}
\KeywordTok{struct}\NormalTok{ query}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l,r,i; LL ans;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ query \&t)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(id[t.l]!=id[l])}\ControlFlowTok{return}\NormalTok{ id[l]\textless{}id[t.l];}
        \ControlFlowTok{return}\NormalTok{ r\textless{}t.r;}
\NormalTok{    \}}
\NormalTok{\}q[MAXN];}
\KeywordTok{inline}\NormalTok{ LL baoli(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,l,r)t[b[i]]++,ans=max(ans,}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*t[b[i]]*a[i]);}
\NormalTok{    fp(i,l,r)t[b[i]]{-}{-};}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]),X.pb(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)id[i]=(i{-}}\DecValTok{1}\NormalTok{)/SZ+}\DecValTok{1}\NormalTok{; z=id[n];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!st[id[i]])st[id[i]]=i;}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(!ed[id[i]])ed[id[i]]=i;}
\NormalTok{    sort(all(X)),unq(X);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)b[i]=lb(all(X),a[i]){-}X.begin()+}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&q[i].l,\&q[i].r),q[i].i=i;}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m);}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{,pre=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{,l,r;i\textless{}=m;i++)}
\NormalTok{    \{   }
        \DataTypeTok{int}\NormalTok{ k=id[q[i].l];}
        \ControlFlowTok{if}\NormalTok{(id[q[i].l]!=id[q[i{-}}\DecValTok{1}\NormalTok{].l])mst(cnt,}\DecValTok{0}\NormalTok{),ans=pre=}\DecValTok{0}\NormalTok{,r=ed[k],l=ed[k]+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(id[q[i].l]==id[q[i].r])q[i].ans=baoli(q[i].l,q[i].r);}
        \ControlFlowTok{else}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(l\textless{}=ed[k])cnt[b[l]]{-}{-},l++;}
            \ControlFlowTok{while}\NormalTok{(r\textless{}q[i].r)r++,cnt[b[r]]++,pre=max(pre,}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*cnt[b[r]]*a[r]);}
\NormalTok{            ans=pre;}
            \ControlFlowTok{while}\NormalTok{(l\textgreater{}q[i].l)l{-}{-},cnt[b[l]]++,ans=max(ans,}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*cnt[b[l]]*a[l]);}
\NormalTok{            q[i].ans=ans;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m,[](}\AttributeTok{const}\NormalTok{ query \&a,}\AttributeTok{const}\NormalTok{ query \&b)\{}\ControlFlowTok{return}\NormalTok{ a.i\textless{}b.i;\});}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,q[i].ans);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux6b21ux79bbux7ebfux83abux961f}{%
\subsubsection{二次离线莫队}\label{ux4e8cux6b21ux79bbux7ebfux83abux961f}}

求区间内满足某性质的 \(pair\) 数可以考虑

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ SZ = sqrt(MAXN);}
\DataTypeTok{int}\NormalTok{ n,m,k;}
\DataTypeTok{int}\NormalTok{ a[MAXN];}
\DataTypeTok{int}\NormalTok{ sa[MAXN],pa[MAXN],cnt[}\DecValTok{16384}\NormalTok{*}\DecValTok{8}\NormalTok{];}
\NormalTok{LL  res[MAXN],ans[MAXN];}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ id(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ (x{-}}\DecValTok{1}\NormalTok{)/SZ+}\DecValTok{1}\NormalTok{;\}}
\KeywordTok{struct}\NormalTok{ q1}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l,r,i;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ q1 \&t)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(id(l)!=id(t.l))}\ControlFlowTok{return}\NormalTok{ id(l)\textless{}id(t.l);}
        \ControlFlowTok{if}\NormalTok{(id(l)\&}\DecValTok{1}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ r\textless{}t.r;}
        \ControlFlowTok{return}\NormalTok{ r\textgreater{}t.r;}
\NormalTok{    \}}
\NormalTok{\}q[MAXN];}
\KeywordTok{struct}\NormalTok{ q2\{}\DataTypeTok{int}\NormalTok{ i,l,r,f;\};}
\NormalTok{vector\textless{}q2\textgreater{} pre[MAXN],suf[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} b;}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ insert\_pre(}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ f)\{}\ControlFlowTok{if}\NormalTok{(pos\textgreater{}=}\DecValTok{1}\NormalTok{\&\&pos\textless{}=n)pre[pos].pb(\{i,l,r,f\});\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ insert\_suf(}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ f)\{}\ControlFlowTok{if}\NormalTok{(pos\textgreater{}=}\DecValTok{1}\NormalTok{\&\&pos\textless{}=n)suf[pos].pb(\{i,l,r,f\});\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(m),io.read(k);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)io.read(a[i]);}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,}\DecValTok{16384}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(bitcount(i)==k)b.pb(i);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)io.read(q[i].l),io.read(q[i].r),q[i].i=i;}
\NormalTok{    sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+m);}
\NormalTok{    rg }\DataTypeTok{int}\NormalTok{ r=}\DecValTok{1}\NormalTok{,l=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(r\textless{}q[i].r)\{insert\_pre(i,l{-}}\DecValTok{1}\NormalTok{,r+}\DecValTok{1}\NormalTok{,q[i].r,{-}}\DecValTok{1}\NormalTok{);}\ControlFlowTok{while}\NormalTok{(r\textless{}q[i].r)++r,res[i]+=pa[r];\}}
        \ControlFlowTok{if}\NormalTok{(l\textgreater{}q[i].l)\{insert\_suf(i,r+}\DecValTok{1}\NormalTok{,q[i].l,l{-}}\DecValTok{1}\NormalTok{,{-}}\DecValTok{1}\NormalTok{);}\ControlFlowTok{while}\NormalTok{(l\textgreater{}q[i].l){-}{-}l,res[i]+=sa[l];\}}
        \ControlFlowTok{if}\NormalTok{(r\textgreater{}q[i].r)\{insert\_pre(i,l{-}}\DecValTok{1}\NormalTok{,q[i].r+}\DecValTok{1}\NormalTok{,r, }\DecValTok{1}\NormalTok{);}\ControlFlowTok{while}\NormalTok{(r\textgreater{}q[i].r)res[i]{-}=pa[r],{-}{-}r;\}}
        \ControlFlowTok{if}\NormalTok{(l\textless{}q[i].l)\{insert\_suf(i,r+}\DecValTok{1}\NormalTok{,l,q[i].l{-}}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{);}\ControlFlowTok{while}\NormalTok{(l\textless{}q[i].l)res[i]{-}=sa[l],++l;\}}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
\NormalTok{        pa[i]=cnt[a[i]];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:b)cnt[a[i]\^{}x]++;}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ q:pre[i])fp(j,q.l,q.r)}\ControlFlowTok{if}\NormalTok{(j)res[q.i]+=q.f*cnt[a[j]];}
\NormalTok{    \}}
\NormalTok{    mst(cnt,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        sa[i]=cnt[a[i]];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:b)cnt[a[i]\^{}x]++;}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ q:suf[i])fp(j,q.l,q.r)}\ControlFlowTok{if}\NormalTok{(j)res[q.i]+=q.f*cnt[a[j]];}
\NormalTok{    \}}
\NormalTok{    r=}\DecValTok{1}\NormalTok{,l=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(r\textless{}q[i].r)\{}\ControlFlowTok{while}\NormalTok{(r\textless{}q[i].r)++r,res[i]+=pa[r];\}}
        \ControlFlowTok{if}\NormalTok{(l\textgreater{}q[i].l)\{}\ControlFlowTok{while}\NormalTok{(l\textgreater{}q[i].l){-}{-}l,res[i]+=sa[l];\}}
        \ControlFlowTok{if}\NormalTok{(r\textgreater{}q[i].r)\{}\ControlFlowTok{while}\NormalTok{(r\textgreater{}q[i].r)res[i]{-}=pa[r],{-}{-}r;\}}
        \ControlFlowTok{if}\NormalTok{(l\textless{}q[i].l)\{}\ControlFlowTok{while}\NormalTok{(l\textless{}q[i].l)res[i]{-}=sa[l],++l;\}}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)res[i]+=res[i{-}}\DecValTok{1}\NormalTok{],ans[q[i].i]=res[i];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)io.write(ans[i]),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5206ux5757}{%
\subsection{分块}\label{ux5206ux5757}}

\hypertarget{ux8be2ux95eeux5206ux5757}{%
\subsubsection{询问分块}\label{ux8be2ux95eeux5206ux5757}}

区间加，区间求值：

考虑对询问分块，维护前缀和，每 \(\sqrt{n}\)
次修改便重建前缀数组，询问时暴力查询当前维护的修改对本次询问的影响。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n;}
\NormalTok{LL  a[MAXN],b[MAXN];}
\KeywordTok{struct}\NormalTok{ modify\{}\DataTypeTok{int}\NormalTok{ l,r;LL v;\};}
\NormalTok{vector\textless{}modify\textgreater{} v;}
\DataTypeTok{void}\NormalTok{ build()}
\NormalTok{\{}
\NormalTok{    mst(b,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:v)b[x.l]+=x.v,b[x.r+}\DecValTok{1}\NormalTok{]{-}=x.v;}
\NormalTok{    v.clear();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)b[i]+=b[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)b[i]+=b[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i]+=b[i];}
\NormalTok{\}}
\NormalTok{pr inter(}\DataTypeTok{int}\NormalTok{ a,}\DataTypeTok{int}\NormalTok{ b,}\DataTypeTok{int}\NormalTok{ c,}\DataTypeTok{int}\NormalTok{ d)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(b\textless{}c||a\textgreater{}d)}\ControlFlowTok{return}\NormalTok{ \{}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\};}
    \ControlFlowTok{return}\NormalTok{ \{max(a,c),min(b,d)\};}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ MOD)}
\NormalTok{\{}
\NormalTok{    LL ans=a[r]{-}a[l{-}}\DecValTok{1}\NormalTok{];}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:v)}
\NormalTok{    \{}
\NormalTok{        pr seg=inter(x.l,x.r,l,r);}
        \ControlFlowTok{if}\NormalTok{(seg.fi)ans+=}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*(seg.se{-}seg.fi+}\DecValTok{1}\NormalTok{)*x.v,ans\%=(MOD+}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{    ans\%=(MOD+}\DecValTok{1}\NormalTok{),printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{"}\NormalTok{,\&a[i]),a[i]+=a[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ t,l,r,c;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d\%d}\StringTok{"}\NormalTok{,\&t,\&l,\&r,\&c);}
        \ControlFlowTok{if}\NormalTok{(!t)\{v.pb(\{l,r,c\});}\ControlFlowTok{if}\NormalTok{(v.size()\textgreater{}=sqrt(n))build();\}}
        \ControlFlowTok{else}\NormalTok{ query(l,r,c);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ef4ux62a4-anskxy-ux7684ux6700ux5927ux503cxyux5e38ux6570ux4e14ux591aux4e2a-kux53efux53d8}{%
\subsubsection{维护 ans=kx+y 的最大值(x,y常数且多个
k可变)}\label{ux7ef4ux62a4-anskxy-ux7684ux6700ux5927ux503cxyux5e38ux6570ux4e14ux591aux4e2a-kux53efux53d8}}

将 (a,b) 看作是平面上的点

ans = kx + y

y = -kx + ans

相当于一条斜率固定的直线 从上向下平移碰到的第一个点即为ans的最大值
维护凸包即可

区间加：分块 块内维护凸包

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ convexhull }\CommentTok{//ans=kx+y, x y为常数,k可变(询问),求ans的最大值 }
\NormalTok{\{}
\NormalTok{    vector\textless{}lpr\textgreater{} p;}
    \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ clear()\{p.clear();\}}
    \KeywordTok{inline} \DataTypeTok{double}\NormalTok{ slope(lpr \&a,lpr \&b)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(b.fi==a.fi)}\ControlFlowTok{return} \FloatTok{1.0}\NormalTok{/}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return} \DataTypeTok{double}\NormalTok{(b.se{-}a.se)/}\DataTypeTok{double}\NormalTok{(b.fi{-}a.fi);}
\NormalTok{    \}}
    \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ insert(lpr x)\{p.pb(x);\}}
    \KeywordTok{inline}\NormalTok{ LL val(}\DataTypeTok{int}\NormalTok{ k,lpr \&x)\{}\ControlFlowTok{return} \DecValTok{1}\BuiltInTok{LL}\NormalTok{*k*x.fi+x.se;\}}
    \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ build() }\CommentTok{//构建凸包 需保证插入的点按x排好序且p非空}
\NormalTok{    \{}
        \CommentTok{//sort(all(p)),unq(p); }
\NormalTok{        vector\textless{}lpr\textgreater{} a; }\CommentTok{//swap(a,p);}

\NormalTok{        LL maxy=p.front().se;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,p.size())}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(i==p.size()||p[i].fi!=p[i{-}}\DecValTok{1}\NormalTok{].fi)}
\NormalTok{            \{}
\NormalTok{                a.pb(\{p[i{-}}\DecValTok{1}\NormalTok{].fi,maxy\});}
                \ControlFlowTok{if}\NormalTok{(i!=p.size())maxy=p[i].se;}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ maxy=max(maxy,p[i].se);}
\NormalTok{        \}}
\NormalTok{        p.clear();}

        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}a.size();i++)}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(p.size()\textgreater{}=}\DecValTok{2}\NormalTok{\&\&slope(p[p.size(){-}}\DecValTok{2}\NormalTok{],a[i])\textgreater{}}
\NormalTok{                slope(p[p.size(){-}}\DecValTok{2}\NormalTok{],p[p.size(){-}}\DecValTok{1}\NormalTok{]))}
\NormalTok{                    p.ppb();}
\NormalTok{            p.pb(a[i]);}
\NormalTok{        \}}
\NormalTok{        reverse(all(p));}
\NormalTok{    \}}
    \KeywordTok{inline}\NormalTok{ LL query(}\DataTypeTok{int}\NormalTok{ k) }\CommentTok{//询问}
\NormalTok{    \{}
        
        \ControlFlowTok{while}\NormalTok{(p.size()\textgreater{}=}\DecValTok{2}\NormalTok{\&\&val(k,p[p.size(){-}}\DecValTok{2}\NormalTok{])\textgreater{}val(k,p[p.size(){-}}\DecValTok{1}\NormalTok{]))}
\NormalTok{            p.ppb();}
        \ControlFlowTok{return}\NormalTok{ val(k,p.back());}
\CommentTok{/*      //斜率不单调时二分用}
\CommentTok{        if(p.size()==1)return val(k,p[0]);}
\CommentTok{        if(p.size()==2)return max(val(k,p[0]),val(k,p[1]));}
\CommentTok{        if(val(k,p[0])\textgreater{}=val(k,p[1]))return val(k,p[0]);}
\CommentTok{        if(val(k,p[p.size(){-}1])\textgreater{}=val(k,p[p.size(){-}2]))return val(k,p[p.size(){-}1]);}
\CommentTok{        int l=1,r=p.size(){-}1,ans=1;}
\CommentTok{        while(l\textless{}=r)}
\CommentTok{        \{}
\CommentTok{            if(val(k,p[mid])\textgreater{}=val(k,p[mid{-}1]))}
\CommentTok{                ans=mid,l=mid+1;}
\CommentTok{            else r=mid{-}1;}
\CommentTok{        \}}
\CommentTok{        return val(k,p[ans]);}
\CommentTok{*/}
\NormalTok{    \}}
\NormalTok{\};}

\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ l[MAXN],r[MAXN],num[MAXN],cnt;}
\NormalTok{LL sa[MAXN],sb[MAXN],a[MAXN],b[MAXN];}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    sa[u]+=a[u],sb[u]+=b[u],l[u]=++cnt,num[cnt]=u;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)sa[v]=sa[u],sb[v]=sb[u],dfs(v,u);}
\NormalTok{    r[u]=cnt;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ n,m,z;}
\DataTypeTok{int}\NormalTok{ id[MAXN],st[MAXN],ed[MAXN];}

\DataTypeTok{int}\NormalTok{ SZ;}
\NormalTok{LL add[MAXN];}
\NormalTok{convexhull h[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} v[MAXN];}

\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ rebuild(}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
\NormalTok{    h[k].clear(); }
\NormalTok{    fp(i,st[k],ed[k])sa[num[i]]+=add[k];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ t=v[k].size(){-}}\DecValTok{1}\NormalTok{;t\textgreater{}=}\DecValTok{0}\NormalTok{;t{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ i=v[k][t],u=num[i];}
\NormalTok{        h[k].insert(\{{-}sb[u],{-}sa[u]*sb[u]\});}
\NormalTok{    \}}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ t=}\DecValTok{0}\NormalTok{;t\textless{}v[k].size();t++)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ i=v[k][t],u=num[i];}
\NormalTok{        h[k].insert(\{sb[u],sa[u]*sb[u]\});}
\NormalTok{    \}}
\NormalTok{    h[k].build(),add[k]=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)id[i]=(i{-}}\DecValTok{1}\NormalTok{)/SZ+}\DecValTok{1}\NormalTok{; z=id[n];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!st[id[i]])st[id[i]]=i;}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(!ed[id[i]])ed[id[i]]=i;}
\NormalTok{    fp(k,}\DecValTok{1}\NormalTok{,z)}
\NormalTok{    \{}
\NormalTok{        fp(i,st[k],ed[k])v[k].pb(i);}
\NormalTok{        sort(all(v[k]),[](}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ j)}
\NormalTok{        \{}
            \ControlFlowTok{return}\NormalTok{ sb[num[i]]\textless{}sb[num[j]];}
\NormalTok{        \});}
\NormalTok{        rebuild(k);}
\NormalTok{    \}}
\NormalTok{\}}
\KeywordTok{inline}\NormalTok{ LL val(}\DataTypeTok{int}\NormalTok{ i)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ u=num[i],k=id[i];}
    \ControlFlowTok{return}\NormalTok{ abs(sa[u]+add[k])*sb[u];}
\NormalTok{\}}
\KeywordTok{inline}\NormalTok{ LL query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
\NormalTok{    LL ans={-}linf;}
    \ControlFlowTok{if}\NormalTok{(id[l]==id[r])}
\NormalTok{    \{}
\NormalTok{        fp(i,l,r)ans=max(ans,val(i));}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ L=id[l]+}\DecValTok{1}\NormalTok{,R=id[r]{-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,l,st[L]{-}}\DecValTok{1}\NormalTok{)ans=max(ans,val(i));}
\NormalTok{    fd(i,r,ed[R]+}\DecValTok{1}\NormalTok{)ans=max(ans,val(i));}
\NormalTok{    fp(k,L,R)ans=max(ans,h[k].query(add[k]));}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,LL v)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(id[l]==id[r])}
\NormalTok{    \{}
\NormalTok{        fp(i,l,r)sa[num[i]]+=v;}
\NormalTok{        rebuild(id[l]);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ L=id[l]+}\DecValTok{1}\NormalTok{,R=id[r]{-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,l,st[L]{-}}\DecValTok{1}\NormalTok{)sa[num[i]]+=v;}
\NormalTok{    fd(i,r,ed[R]+}\DecValTok{1}\NormalTok{)sa[num[i]]+=v;}
\NormalTok{    fp(k,L,R)add[k]+=v;}
\NormalTok{    rebuild(id[l]),rebuild(id[r]);}
\NormalTok{\}}

\NormalTok{FASTIO;}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(m);}
\NormalTok{    SZ=max(}\DecValTok{1}\NormalTok{,(}\DataTypeTok{int}\NormalTok{)sqrt(n/}\DecValTok{10}\NormalTok{));}
\NormalTok{    fp(i,}\DecValTok{2}\NormalTok{,n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ fa;}
\NormalTok{        io.read(fa);}
\NormalTok{        addedge(fa,i);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)io.read(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)io.read(b[i]);}
\NormalTok{    dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)sb[i]=abs(sb[i]);}
\NormalTok{    init();}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ t,x,y; io.read(t);}
        \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{1}\NormalTok{)io.read(x),io.read(y),update(l[x],r[x],y);}
        \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{2}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            io.read(x);}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,query(l[x],r[x]));}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux503cux57dfux5206ux5757}{%
\subsubsection{值域分块}\label{ux503cux57dfux5206ux5757}}

\(O(1)\)修改，\(O(sqrt(n))\)查询，有时可用于莫队

\hypertarget{ux6811ux5206ux5feb}{%
\subsection{树分快}\label{ux6811ux5206ux5feb}}

\hypertarget{ux968fux5373ux6563ux70b9}{%
\subsubsection{随即散点}\label{ux968fux5373ux6563ux70b9}}

从一个关键点跳到另一个关键点期望距离 \(\sqrt{n}\)

\hypertarget{ux738bux5ba4ux8054ux90a6}{%
\subsubsection{王室联邦}\label{ux738bux5ba4ux8054ux90a6}}

保证块的大小 \([B,3B]\)，直径和个数，不保证连通性

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,B;}
\DataTypeTok{int}\NormalTok{ s[MAXN],top;}
\DataTypeTok{int}\NormalTok{ bel[MAXN],root[MAXN],cnt;}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ bottom = top; }
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
\NormalTok{        dfs(v,u);}
        \ControlFlowTok{if}\NormalTok{(top{-}bottom\textgreater{}=B)}
\NormalTok{        \{}
\NormalTok{            cnt++,root[cnt]=u;}
            \ControlFlowTok{while}\NormalTok{(top!=bottom)}
\NormalTok{                bel[s[top{-}{-}]]=cnt;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    s[++top]=u;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&B);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}\ControlFlowTok{while}\NormalTok{(top)bel[s[top{-}{-}]]=cnt;}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,cnt);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,bel[i]);printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,root[i]);printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{heightux5206ux5757}{%
\subsubsection{height分块}\label{heightux5206ux5757}}

保证直径 联通

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ s[MAXN],h=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u=}\DecValTok{1}\NormalTok{,}\DataTypeTok{int}\NormalTok{ fa=}\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
\NormalTok{    d[u]=d[fa]+}\DecValTok{1}\NormalTok{,s[++h]=u,update(root[fa],root[u],a[u],d[u]),::fa[u]=fa;}
    \DataTypeTok{int}\NormalTok{ mx=d[u]; go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)mx=max(mx,dfs(v,u));}
    \ControlFlowTok{if}\NormalTok{(u==}\DecValTok{1}\NormalTok{||mx{-}d[u]\textgreater{}=H)}
\NormalTok{    \{}
\NormalTok{        ++tree\_block\_cnt;}
        \ControlFlowTok{while}\NormalTok{(s[h]!=u)bel[s[h]]=tree\_block\_cnt,h{-}{-};}
\NormalTok{        bel[u]=tree\_block\_cnt,h{-}{-},rt[tree\_block\_cnt]=u;}
        \ControlFlowTok{return}\NormalTok{ d[u]{-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ mx;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{cdqux5206ux6cbb}{%
\subsection{CDQ分治}\label{cdqux5206ux6cbb}}

\hypertarget{ux4e8cux7ef4ux504fux5e8f}{%
\subsubsection{1.二维偏序}\label{ux4e8cux7ef4ux504fux5e8f}}

一维sort cdq时用双指针统计答案

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ cdq}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n;}
    \KeywordTok{struct}\NormalTok{ opt}
\NormalTok{    \{}
\NormalTok{        LL x,y,val,f;}
        \DataTypeTok{bool}\NormalTok{ query;}
        \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{} (opt \& other)\{}\ControlFlowTok{return}\NormalTok{ y\textless{}other.y;\}}
        \DataTypeTok{void}\NormalTok{ print()}
\NormalTok{        \{}
\NormalTok{            cout \textless{}\textless{} dbgs3(x,y,query) \textless{}\textless{} endl;}
\NormalTok{            cout \textless{}\textless{} dbgs2(val,f) \textless{}\textless{} endl;}
\NormalTok{        \}}
\NormalTok{    \}q[MAXN];}

    \DataTypeTok{void}\NormalTok{ sort(opt a[],}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
        \AttributeTok{static}\NormalTok{ opt t[MAXN];}
        \DataTypeTok{int}\NormalTok{ head=}\DecValTok{0}\NormalTok{,i=l,j=mid+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&j\textless{}=r) t[++head]=a[i]\textless{}a[j]?a[i++]:a[j++];}
        \ControlFlowTok{while}\NormalTok{(i\textless{}=mid) t[++head]=a[i++];}
        \ControlFlowTok{while}\NormalTok{(j\textless{}=r  ) t[++head]=a[j++];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,head) a[l+i{-}}\DecValTok{1}\NormalTok{]=t[i];}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve(LL ans[],}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,}\DataTypeTok{int}\NormalTok{ r=n)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}

\NormalTok{        solve(ans,l,mid),solve(ans,mid+}\DecValTok{1}\NormalTok{,r);}
\CommentTok{/*}
\CommentTok{        cout \textless{}\textless{} dbgs2(l,r) \textless{}\textless{} endl;}
\CommentTok{        fp(i,l,r) q[i].print();}
\CommentTok{        cout \textless{}\textless{} endl;}
\CommentTok{*/}
        \DataTypeTok{int}\NormalTok{ i=l;}
\NormalTok{        LL sum=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(j,mid+}\DecValTok{1}\NormalTok{,r)}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&q[i].y\textless{}=q[j].y)}
\NormalTok{                sum+=q[i++].val;}
            \ControlFlowTok{if}\NormalTok{(q[j].query) ans[q[j].x]+=q[j].f*sum;}
\NormalTok{        \}}
\NormalTok{        sort(q,l,r);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ push(opt x)\{q[++n]=x;\}}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{LL a[MAXN],ans[MAXN];}
\DataTypeTok{bool}\NormalTok{ query[MAXN];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) scanf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{"}\NormalTok{,\&a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) a[i]+=a[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ opt,l,r;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&opt,\&l,\&r);}
        \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{) cdq::push(\{i,l,r,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\});}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            query[i]=}\DecValTok{1}\NormalTok{;}
\NormalTok{            ans[i]=a[r]{-}a[l{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{            cdq::push(\{i,r,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{\});}
\NormalTok{            cdq::push(\{i,l{-}}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{\});}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    cdq::solve(ans);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m) }\ControlFlowTok{if}\NormalTok{(query[i]) printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans[i]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e09ux7ef4ux504fux5e8f}{%
\subsubsection{2.三维偏序}\label{ux4e09ux7ef4ux504fux5e8f}}

\href{https://www.luogu.org/problem/P3810}{陌上花开}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ bit}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ c[N];}
\NormalTok{    vector\textless{}pr\textgreater{} q;}
    \DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
    \DataTypeTok{int}\NormalTok{ sum(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=lowbit(i)) s+=c[i];}
        \ControlFlowTok{return}\NormalTok{ s;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{bool}\NormalTok{ save=}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(save) q.pb(\{x,v\});}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}N;i+=lowbit(i)) c[i]+=v;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ undo()}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{            update(q.back().fi,{-}q.back().se,}\DecValTok{0}\NormalTok{),q.ppb();}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)\{}\ControlFlowTok{return}\NormalTok{ sum(r){-}sum(l{-}}\DecValTok{1}\NormalTok{);\}}
\NormalTok{\}}

\KeywordTok{namespace}\NormalTok{ cdq}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n,m;}
    \KeywordTok{struct}\NormalTok{ query}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x,y,z;}
        \DataTypeTok{int}\NormalTok{ index,cnt,ans;}
        \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ ==(}\AttributeTok{const}\NormalTok{ query \&t)}
\NormalTok{        \{}
            \ControlFlowTok{return}\NormalTok{ x==t.x\&\&y==t.y\&\&z==t.z;}
\NormalTok{        \}}
        \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{ \textless{}(}\AttributeTok{const}\NormalTok{ query \&t)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(y!=t.y) }\ControlFlowTok{return}\NormalTok{ y\textless{}t.y;}
            \ControlFlowTok{return}\NormalTok{ z\textless{}t.z;}
\NormalTok{        \}}
\NormalTok{    \}q[MAXN],t[MAXN];}

    \DataTypeTok{void}\NormalTok{ sort(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
        \AttributeTok{static}\NormalTok{ query t[MAXN];}
        \DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{,head=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&j\textless{}=r) t[++head]=(q[i]\textless{}q[j])?q[i++]:q[j++];}
        \ControlFlowTok{while}\NormalTok{(i\textless{}=mid) t[++head]=q[i++];}
        \ControlFlowTok{while}\NormalTok{(j\textless{}=  r) t[++head]=q[j++];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,head) q[l+i{-}}\DecValTok{1}\NormalTok{]=t[i];}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,}\DataTypeTok{int}\NormalTok{ r=n)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{        solve(l,mid),solve(mid+}\DecValTok{1}\NormalTok{,r);}
\CommentTok{/*}
\CommentTok{        cout \textless{}\textless{} dbgs2(l,r) \textless{}\textless{} endl;}
\CommentTok{        fp(i,l,r) cout \textless{}\textless{} dbgs4(i,q[i].x,q[i].y,q[i].z) \textless{}\textless{} dbgs(q[i].cnt) \textless{}\textless{} endl;}
\CommentTok{        cout \textless{}\textless{} endl;}
\CommentTok{*/}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{;j\textless{}=r;j++)}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&q[i].y\textless{}=q[j].y)}
\NormalTok{                bit::update(q[i].z,q[i].cnt),i++;}
\NormalTok{            q[j].ans+=bit::query(}\DecValTok{1}\NormalTok{,q[j].z);}
\NormalTok{        \}}

\NormalTok{        bit::undo(),sort(l,r);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ push(}\AttributeTok{const}\NormalTok{ query x)\{q[++n]=x;\}}
    \DataTypeTok{bool}\NormalTok{ cmp(}\AttributeTok{const}\NormalTok{ cdq::query \&a,}\AttributeTok{const}\NormalTok{ cdq::query \&b)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(a.x!=b.x) }\ControlFlowTok{return}\NormalTok{ a.x\textless{}b.x;}
        \ControlFlowTok{if}\NormalTok{(a.y!=b.y) }\ControlFlowTok{return}\NormalTok{ a.y\textless{}b.y;}
        \ControlFlowTok{return}\NormalTok{ a.z\textless{}b.z;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()}
\NormalTok{    \{}
        \BuiltInTok{std::}\NormalTok{sort(q+}\DecValTok{1}\NormalTok{,q+}\DecValTok{1}\NormalTok{+n,cmp);}
\NormalTok{        query cur=q[}\DecValTok{1}\NormalTok{];}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{,cnt=}\DecValTok{1}\NormalTok{;i\textless{}=n+}\DecValTok{1}\NormalTok{;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(i==n+}\DecValTok{1}\NormalTok{||!(q[i]==cur))}
\NormalTok{                cur.cnt=cnt,t[++m]=cur,cur=q[i],cnt=}\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{else}\NormalTok{ cnt++;}
\NormalTok{        \}}
\NormalTok{        swap(t,q),swap(n,m);}
\NormalTok{    \}}

\NormalTok{\};}

\DataTypeTok{int}\NormalTok{ n,k;}
\DataTypeTok{int}\NormalTok{ f[MAXN];}

\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(k);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ x,y,z;}
\NormalTok{        io.read(x),io.read(y),io.read(z);}
\NormalTok{        cdq::push(\{x,y,z,i,}\DecValTok{0}\NormalTok{\});}
\NormalTok{    \}}
\NormalTok{    cdq::init();}
\NormalTok{    cdq::solve();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cdq::n) f[cdq::q[i].ans+cdq::q[i].cnt{-}}\DecValTok{1}\NormalTok{]+=cdq::q[i].cnt;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{) io.write(f[i]),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux56dbux7ef4ux504fux5e8f-cdqux5957cdq}{%
\subsubsection{3.四维偏序
CDQ套CDQ}\label{ux56dbux7ef4ux504fux5e8f-cdqux5957cdq}}

solve1(l,r): 考虑处理完 solve1(l,mid) 与 solve2(mid+1,r) 后,仅有跨越 mid
的偏序关系尚未处理

因此可以将 (l,mid) 的点第一维都设为 0, (mid+1,r) 的点的第一维都设为 1,
继续 cdq 分治处理三维偏序即可

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ bit}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ c[N],vis[N],tim=}\DecValTok{1}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i\textless{}N;i+=lowbit(i))}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(vis[i]!=tim) c[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{            vis[i]=tim,c[i]+=v;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ sum(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=lowbit(i))}
            \ControlFlowTok{if}\NormalTok{(vis[i]==tim)}
\NormalTok{                s+=c[i];}
        \ControlFlowTok{return}\NormalTok{ s;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)\{}\ControlFlowTok{return}\NormalTok{ sum(r){-}sum(l{-}}\DecValTok{1}\NormalTok{);\}}
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ node}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ a,b,c,d,id,f;}
\NormalTok{\}a[MAXN],b[MAXN],t[MAXN];}

\DataTypeTok{int}\NormalTok{ n,ans[MAXN];}

\DataTypeTok{void}\NormalTok{ solve1(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r);}
\DataTypeTok{void}\NormalTok{ solve2(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r);}

\DataTypeTok{void}\NormalTok{ solve1(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}

    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    solve1(l,mid),solve1(mid+}\DecValTok{1}\NormalTok{,r);}

    \CommentTok{//cout \textless{}\textless{} "solve 1 " \textless{}\textless{} dbgs2(l,r) \textless{}\textless{} endl;}
    \CommentTok{//debug(a,l,r);}

\NormalTok{    fp(i,l,mid)   a[i].a=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(j,mid+}\DecValTok{1}\NormalTok{,r) a[j].a=}\DecValTok{1}\NormalTok{;}

    \DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{,head=l;}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&j\textless{}=r) b[head++]=(a[i].b\textless{}=a[j].b)?a[i++]:a[j++];}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid) b[head++]=a[i++];}
    \ControlFlowTok{while}\NormalTok{(j\textless{}=  r) b[head++]=a[j++];}
\CommentTok{/*}
\CommentTok{    fp(i,l,mid)   b[i].a=0;}
\CommentTok{    fp(j,mid+1,r) b[j].a=1;}
\CommentTok{*/}
\NormalTok{    fp(i,l,r) a[i]=b[i];}

\NormalTok{    solve2(l,r);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve2(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}

    \ControlFlowTok{if}\NormalTok{(l==r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    solve2(l,mid),solve2(mid+}\DecValTok{1}\NormalTok{,r);}

    \CommentTok{//cout \textless{}\textless{} "solve2 " \textless{}\textless{} dbgs2(l,r) \textless{}\textless{} endl;}
    \CommentTok{//debug(b,l,r);}

\NormalTok{    bit::tim++;}

    \DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{,head=l;}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&j\textless{}=r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(b[i].c\textless{}=b[j].c)}
\NormalTok{        \{}
\NormalTok{            t[head++]=b[i];}
            \ControlFlowTok{if}\NormalTok{(!b[i].a\&\&!b[i].f) bit::update(b[i].d,}\DecValTok{1}\NormalTok{);}
\NormalTok{            i++;}
\NormalTok{        \}}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            t[head++]=b[j];}
            \ControlFlowTok{if}\NormalTok{(b[j].a\&\&b[j].f) ans[b[j].id]+=b[j].f*bit::query(}\DecValTok{1}\NormalTok{,b[j].d);}
\NormalTok{            j++;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid) t[head++]=b[i++];}
    \ControlFlowTok{while}\NormalTok{(j\textless{}=r)}
\NormalTok{    \{}
\NormalTok{        t[head++]=b[j];}
        \ControlFlowTok{if}\NormalTok{(b[j].a\&\&b[j].f) ans[b[j].id]+=b[j].f*bit::query(}\DecValTok{1}\NormalTok{,b[j].d);}
\NormalTok{        j++;}
\NormalTok{    \}}
\NormalTok{    fp(i,l,r) b[i]=t[i];}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ T,q;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
\NormalTok{        bit::tim=n=}\DecValTok{0}\NormalTok{,X.clear();}
\NormalTok{        io.read(q);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,q)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ opt,x1,x2,y1,y2,z1,z2;}
\NormalTok{            io.read(opt);}
\NormalTok{            io.read(x1),io.read(y1),io.read(z1);}
            \ControlFlowTok{if}\NormalTok{(opt==}\DecValTok{1}\NormalTok{) a[++n]=\{i,x1,y1,z1,i,}\DecValTok{0}\NormalTok{\},ans[i]={-}}\DecValTok{1}\NormalTok{,X.pb(z1);}
            \ControlFlowTok{else}
\NormalTok{            \{}
\NormalTok{                io.read(x2),io.read(y2),io.read(z2);}
\NormalTok{                x1{-}{-},y1{-}{-},z1{-}{-};}
\NormalTok{                a[++n]=\{i,x1,y1,z1,i,{-}}\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x1,y2,z1,i, }\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x2,y1,z1,i, }\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x2,y2,z1,i,{-}}\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x1,y1,z2,i, }\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x1,y2,z2,i,{-}}\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x2,y1,z2,i,{-}}\DecValTok{1}\NormalTok{\};}
\NormalTok{                a[++n]=\{i,x2,y2,z2,i, }\DecValTok{1}\NormalTok{\};}
\NormalTok{                X.pb(z1),X.pb(z1+}\DecValTok{1}\NormalTok{),X.pb(z2);}
\NormalTok{                ans[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{            \}}
\NormalTok{        \}}

\NormalTok{        sort(all(X)),unq(X);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) a[i].d=lower\_bound(all(X),a[i].d){-}X.begin()+}\DecValTok{1}\NormalTok{;}
        \CommentTok{//debug(a,1,n);}

\NormalTok{        solve1(}\DecValTok{1}\NormalTok{,n);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,q) }\ControlFlowTok{if}\NormalTok{(ans[i]!={-}}\DecValTok{1}\NormalTok{) io.write(ans[i]),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e26ux63d2ux5165ux66fcux54c8ux987fux8dddux79bbux6700ux8fd1ux70b9ux5bf9ux5929ux4f7fux73a9ux5076}{%
\subsubsection{4.带插入曼哈顿距离最近点对(天使玩偶)}\label{ux5e26ux63d2ux5165ux66fcux54c8ux987fux8dddux79bbux6700ux8fd1ux70b9ux5bf9ux5929ux4f7fux73a9ux5076}}

Luogu P4169

插入:在二维平面上添加一个点，询问：给定一个点，查询已插入点中与他曼哈顿距离最近的点

SOL:假设有两个点 \((X_{i},Y_{i})\) 和 \((X_{j},Y_{j})\)，点 \(j\) 在 点
\(i\) 的左下方，则他们的曼哈顿距离为
\(X_{i}+Y_{j}-(X_{j}+Y_{j})\)，即对于每一个点 \(i\)
查询插入时间在他之前的，在他左下角的所有点 \(j\) 的 \(X_{j}+Y_{j}\)
的最大值，是个三维偏序问题。

其他方向的点(左上，右下，右上)可以通过坐标变换(沿 x/y 轴对称)转到左下角

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X,Y;}
\DataTypeTok{int}\NormalTok{ c[N],t[N],curt;}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ ans={-}inf;}
    \ControlFlowTok{for}\NormalTok{(rg }\DataTypeTok{int}\NormalTok{ i=x;i;i{-}=(i\&({-}i)))}
        \ControlFlowTok{if}\NormalTok{(t[i]==curt)}
\NormalTok{            ans=max(ans,c[i]);}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(rg }\DataTypeTok{int}\NormalTok{ i=x;i\textless{}N;i+=(i\&({-}i)))}
        \ControlFlowTok{if}\NormalTok{(t[i]!=curt)c[i]=v,t[i]=curt;}
        \ControlFlowTok{else}\NormalTok{ c[i]=max(c[i],v);}
    \CommentTok{//cout \textless{}\textless{} dbgs(v) \textless{}\textless{} endl;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ n,m,tim,h;}
\DataTypeTok{int}\NormalTok{ ans[MAXN];}
\KeywordTok{struct}\NormalTok{ point}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ t,x,y;}
    \DataTypeTok{bool}\NormalTok{ query;}
\NormalTok{\}p[MAXN],q[MAXN],a[MAXN];}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==r)}\ControlFlowTok{return}\NormalTok{; solve(l,mid),solve(mid+}\DecValTok{1}\NormalTok{,r);}
\NormalTok{    curt++;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{;j\textless{}=r;j++)}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&p[i].x\textless{}=p[j].x)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!p[i].query)update(p[i].y,p[i].x+p[i].y);}
\NormalTok{            i++;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(p[j].query)}
\NormalTok{        \{}
\NormalTok{            ans[p[j].t]=min(ans[p[j].t],p[j].x+p[j].y{-}query(p[j].y));}
            \CommentTok{//cout \textless{}\textless{} dbgs(query(p[j].y)) \textless{}\textless{} endl;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ i=l,j=mid+}\DecValTok{1}\NormalTok{,h=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid\&\&j\textless{}=r)q[++h]=(p[i].x\textless{}p[j].x)?p[i++]:p[j++];}
    \ControlFlowTok{while}\NormalTok{(i\textless{}=mid)q[++h]=p[i++];}
    \ControlFlowTok{while}\NormalTok{(j\textless{}=  r)q[++h]=p[j++];}
\NormalTok{    fp(i,l,r)p[i]=q[i{-}l+}\DecValTok{1}\NormalTok{];}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ gao()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
\NormalTok{        p[i]=a[i];}
        \ControlFlowTok{if}\NormalTok{(p[i].x\textless{}=}\DecValTok{0}\NormalTok{)p[i].x+=}\FloatTok{1e6}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(p[i].y\textless{}=}\DecValTok{0}\NormalTok{)p[i].y+=}\FloatTok{1e6}\NormalTok{;}
        \CommentTok{//cout \textless{}\textless{} dbgs4(p[i].t,p[i].x,p[i].y,p[i].query) \textless{}\textless{} endl;}
        \CommentTok{//p[i].x=lb(all(X),p[i].x){-}X.begin()+1;}
        \CommentTok{//p[i].y=lb(all(Y),p[i].y){-}Y.begin()+1;}
\NormalTok{    \}}
    \CommentTok{//cout \textless{}\textless{} endl;}
\NormalTok{    solve(}\DecValTok{1}\NormalTok{,n);}
\NormalTok{\}}
\NormalTok{FASTIO;}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x,y;io.read(x),io.read(y);}
\NormalTok{        a[++h]=\{++tim,x,y\};}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ t,x,y;io.read(t),io.read(x),io.read(y);}
        \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{1}\NormalTok{)a[++h]=\{++tim,x,y\};}
        \ControlFlowTok{if}\NormalTok{(t==}\DecValTok{2}\NormalTok{)a[++h]=\{++tim,x,y,}\DecValTok{1}\NormalTok{\};}
\NormalTok{    \}}

    \CommentTok{//for(auto x:X)printf("\%d ",x);printf("\textbackslash{}n");}
    \CommentTok{//for(auto x:Y)printf("\%d ",x);printf("\textbackslash{}n");}
    
\NormalTok{    n=h;fp(i,}\DecValTok{1}\NormalTok{,n)ans[i]=inf;gao();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i].x={-}a[i].x;gao();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i].y={-}a[i].y;gao();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i].x={-}a[i].x;gao();}
    
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(a[i].query)}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans[i]);}
    \CommentTok{//io.write(ans[i]),io.push(\textquotesingle{}\textbackslash{}n\textquotesingle{});}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865ux6574ux4f53ux4e8cux5206}{%
\subsection{(待补)整体二分}\label{ux5f85ux8865ux6574ux4f53ux4e8cux5206}}

\hypertarget{ux6811ux5957ux6811}{%
\subsection{树套树}\label{ux6811ux5957ux6811}}

\hypertarget{ux7ebfux6bb5ux6811ux5957ux7ebfux6bb5ux6811}{%
\subsubsection{1.线段树套线段树}\label{ux7ebfux6bb5ux6811ux5957ux7ebfux6bb5ux6811}}

\hypertarget{ux6811ux72b6ux6570ux7ec4ux5957ux52a8ux6001ux5f00ux70b9ux7ebfux6bb5ux6811}{%
\subsubsection{2.树状数组套动态开点线段树}\label{ux6811ux72b6ux6570ux7ec4ux5957ux52a8ux6001ux5f00ux70b9ux7ebfux6bb5ux6811}}

单点修改区间k大

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}

\KeywordTok{namespace}\NormalTok{ sgt}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ ls[MAXN*}\DecValTok{400}\NormalTok{],rs[MAXN*}\DecValTok{400}\NormalTok{],s[MAXN*}\DecValTok{400}\NormalTok{],cnt;}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ cnt)\{s[cnt]=s[ls[cnt]]+s[rs[cnt]];\}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!rt) rt=++cnt;}
        \ControlFlowTok{if}\NormalTok{(l==r)\{s[rt]+=v;}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(pos\textless{}=mid) update(ls[rt],l,mid,pos,v);}
        \ControlFlowTok{else}\NormalTok{ update(rs[rt],mid+}\DecValTok{1}\NormalTok{,r,pos,v);}
\NormalTok{        pushup(rt);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ n,m,root[MAXN],a[MAXN];}
\DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{bool}\NormalTok{ init=}\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!init)}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=pos;i\textless{}=n;i+=lowbit(i))}
\NormalTok{        sgt::update(root[i],}\DecValTok{1}\NormalTok{,X.size(),a[pos],{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    a[pos]=v;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=pos;i\textless{}=n;i+=lowbit(i))}
\NormalTok{        sgt::update(root[i],}\DecValTok{1}\NormalTok{,X.size(),a[pos], }\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} add,sub;}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ L,}\DataTypeTok{int}\NormalTok{ R,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
\NormalTok{    add.clear(),sub.clear();}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=R  ;i;i{-}=lowbit(i)) add.pb(root[i]);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=L{-}}\DecValTok{1}\NormalTok{;i;i{-}=lowbit(i)) sub.pb(root[i]);}
    \DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,r=X.size();}
    \ControlFlowTok{while}\NormalTok{(l!=r)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:add) s+=sgt::s[sgt::ls[x]];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:sub) s{-}=sgt::s[sgt::ls[x]];}
        \ControlFlowTok{if}\NormalTok{(s\textgreater{}=k)}
\NormalTok{        \{}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:add) x=sgt::ls[x];}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:sub) x=sgt::ls[x];}
\NormalTok{            r=mid;}
\NormalTok{        \}}
        \ControlFlowTok{else}
\NormalTok{        \{}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:add) x=sgt::rs[x];}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:sub) x=sgt::rs[x];}
\NormalTok{            k{-}=s,l=mid+}\DecValTok{1}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ X[l{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ L[MAXN],R[MAXN],K[MAXN];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]),X.pb(a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{char}\NormalTok{ t[}\DecValTok{5}\NormalTok{];}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,t);}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&L[i],\&R[i]);}
        \ControlFlowTok{if}\NormalTok{(t[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&K[i]);}
        \ControlFlowTok{else}\NormalTok{ K[i]=}\DecValTok{0}\NormalTok{,X.pb(R[i]);}
\NormalTok{    \}}
\NormalTok{    sort(all(X)),unq(X);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m) }\ControlFlowTok{if}\NormalTok{(!K[i]) R[i]=lower\_bound(all(X),R[i]){-}X.begin()+}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) a[i]=lower\_bound(all(X),a[i]){-}X.begin()+}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) update(i,a[i],}\DecValTok{1}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!K[i]) update(L[i],R[i]);}
        \ControlFlowTok{else}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,query(L[i],R[i],K[i]));}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6bb5ux6811ux5957ux5e73ux8861ux6811}{%
\subsubsection{3.线段树套平衡树}\label{ux7ebfux6bb5ux6811ux5957ux5e73ux8861ux6811}}

线段树套FHQ

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n, m, w[MAXN];}

\KeywordTok{namespace}\NormalTok{ fhq\_treap}
\NormalTok{\{}
\PreprocessorTok{\#define ls }\NormalTok{ch[x][}\DecValTok{0}\NormalTok{]}
\PreprocessorTok{\#define rs }\NormalTok{ch[x][}\DecValTok{1}\NormalTok{]}

\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} rec;}

    \DataTypeTok{int}\NormalTok{ cnt;}
    \DataTypeTok{int}\NormalTok{ ch[N][}\DecValTok{2}\NormalTok{], siz[N], fix[N], val[N];}

    \DataTypeTok{void}\NormalTok{ init() \{ srand(}\DecValTok{20000713}\NormalTok{), cnt = }\DecValTok{0}\NormalTok{, rec.clear(); \}}
    \DataTypeTok{int}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x;}
        \ControlFlowTok{if}\NormalTok{ (!rec.empty()) x = rec.back(), rec.pop\_back();}
        \ControlFlowTok{else}\NormalTok{ x = ++cnt;}
\NormalTok{        fix[x] = rand(), ls = rs = }\DecValTok{0}\NormalTok{;}
\NormalTok{        siz[x] = }\DecValTok{1}\NormalTok{, val[x] = v;}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}

    \KeywordTok{struct}\NormalTok{ fhq\_treap}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ root;}

        \DataTypeTok{void}\NormalTok{ init() \{ root = }\DecValTok{0}\NormalTok{; \}}
        \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x) \{ siz[x] = siz[ls] + siz[rs] + }\DecValTok{1}\NormalTok{; \}}
        \DataTypeTok{void}\NormalTok{ pushdown(}\DataTypeTok{int}\NormalTok{ x) \{\}}
\NormalTok{        fhq\_treap() \{ init(); \}}

\NormalTok{        pr split(}\DataTypeTok{int}\NormalTok{ x, }\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (!x) }\ControlFlowTok{return}\NormalTok{ \{ }\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{ \};}
\NormalTok{            pr t; pushdown(x);}
            \ControlFlowTok{if}\NormalTok{ (k \textless{}= siz[ls]) t = split(ls, k), ls = t.second, t.second = x;}
            \ControlFlowTok{else}\NormalTok{ t = split(rs, k {-} siz[ls] {-} }\DecValTok{1}\NormalTok{), rs = t.first, t.first = x;}
\NormalTok{            pushup(x); }\ControlFlowTok{return}\NormalTok{ t;}
\NormalTok{        \}}

        \DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x, }\DataTypeTok{int}\NormalTok{ y)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (x*y == }\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ x + y;}
\NormalTok{            pushdown(x), pushdown(y);}
            \ControlFlowTok{if}\NormalTok{ (fix[x] \textless{} fix[y]) \{ ch[x][}\DecValTok{1}\NormalTok{] = merge(ch[x][}\DecValTok{1}\NormalTok{], y), pushup(x); }\ControlFlowTok{return}\NormalTok{ x; \}}
            \ControlFlowTok{else}\NormalTok{ \{ ch[y][}\DecValTok{0}\NormalTok{] = merge(x, ch[y][}\DecValTok{0}\NormalTok{]), pushup(y); }\ControlFlowTok{return}\NormalTok{ y; \}}
\NormalTok{        \}}

        \DataTypeTok{int}\NormalTok{ rank(}\DataTypeTok{int}\NormalTok{ x, }\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (!x) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{            pushdown(x);}
            \ControlFlowTok{if}\NormalTok{ (val[x] \textless{} v) }\ControlFlowTok{return}\NormalTok{ siz[ls] + }\DecValTok{1}\NormalTok{ + rank(rs, v);}
            \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ rank(ls, v);}
\NormalTok{        \}}

        \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ k = rank(root, v);}
\NormalTok{            pr t = split(root, k);}
\NormalTok{            root = merge(merge(t.fi, newnode(v)), t.se);}
\NormalTok{        \}}

        \DataTypeTok{int}\NormalTok{ kth(}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{        \{}
\NormalTok{            pr a = split(root, k {-} }\DecValTok{1}\NormalTok{);}
\NormalTok{            pr b = split(a.se, }\DecValTok{1}\NormalTok{);}
\NormalTok{            root = merge(merge(a.fi, b.fi), b.se);}
            \ControlFlowTok{return}\NormalTok{ val[b.fi];}
\NormalTok{        \}}

        \DataTypeTok{void}\NormalTok{ remove(}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{        \{}
\NormalTok{            pr a = split(root, rank(root, v));}
\NormalTok{            pr b = split(a.se, }\DecValTok{1}\NormalTok{);}
\NormalTok{            root = merge(a.fi, b.se);}
\NormalTok{            rec.push\_back(b.fi);}
\NormalTok{        \}}

        \DataTypeTok{int}\NormalTok{ pre(}\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ kth(rank(root, v)); \}}
        \DataTypeTok{int}\NormalTok{ suc(}\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ kth(rank(root, v + }\DecValTok{1}\NormalTok{) + }\DecValTok{1}\NormalTok{); \}}

        \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (!x) }\ControlFlowTok{return}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{ (ls) debug(ls);}
\NormalTok{            cout \textless{}\textless{} dbgs2(x, val[x]) \textless{}\textless{} endl;}
            \ControlFlowTok{if}\NormalTok{ (rs) debug(rs);}
\NormalTok{        \}}

\NormalTok{    \}}\FunctionTok{tr}\NormalTok{[MAXN * }\DecValTok{4}\NormalTok{];}

\PreprocessorTok{\#undef ls}
\PreprocessorTok{\#undef rs}
\NormalTok{\}}

\KeywordTok{namespace}\NormalTok{ seg\_tree}
\NormalTok{\{}
\PreprocessorTok{\#define ls }\NormalTok{(x\textless{}\textless{}}\DecValTok{1}\NormalTok{)}
\PreprocessorTok{\#define rs }\NormalTok{((x\textless{}\textless{}}\DecValTok{1}\NormalTok{)|}\DecValTok{1}\NormalTok{)}
\PreprocessorTok{\#define mid }\NormalTok{((l+r)\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{)}

    \DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, }\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = l; i \textless{}= r; i++)}
\NormalTok{            fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].insert(w[i]);}
        \ControlFlowTok{if}\NormalTok{ (l == r) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{        build(l, mid, ls), build(mid + }\DecValTok{1}\NormalTok{, r, rs);}
\NormalTok{    \}}

    \DataTypeTok{void}\NormalTok{ modify(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, }\DataTypeTok{int}\NormalTok{ pos, }\DataTypeTok{int}\NormalTok{ v, }\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].remove(w[pos]);}
\NormalTok{        fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].insert(v);}
        \ControlFlowTok{if}\NormalTok{ (l == r) }\ControlFlowTok{return}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{ (pos \textless{}= mid) modify(l, mid, pos, v, ls);}
        \ControlFlowTok{else}\NormalTok{ modify(mid + }\DecValTok{1}\NormalTok{, r, pos, v, rs);}
\NormalTok{    \}}

    \DataTypeTok{int}\NormalTok{ rank(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, }\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v, }\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{ (l == nl \&\& r == nr)}
            \ControlFlowTok{return}\NormalTok{ fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].rank(fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].root, v);}
        \ControlFlowTok{if}\NormalTok{ (nr \textless{}= mid) }\ControlFlowTok{return}\NormalTok{ rank(l, mid, nl, nr, v, ls);}
        \ControlFlowTok{if}\NormalTok{ (nl \textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ rank(mid + }\DecValTok{1}\NormalTok{, r, nl, nr, v, rs);}
        \ControlFlowTok{return}\NormalTok{ rank(l, mid, nl, mid, v, ls) + rank(mid + }\DecValTok{1}\NormalTok{, r, mid + }\DecValTok{1}\NormalTok{, nr, v, rs);}
\NormalTok{    \}}

    \DataTypeTok{int}\NormalTok{ pre(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, }\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v, }\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{ (l == nl \&\& r == nr)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ res = fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].pre(v);}
            \ControlFlowTok{return}\NormalTok{ res \textless{} v ? res : {-}inf;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{ (nr \textless{}= mid) }\ControlFlowTok{return}\NormalTok{ pre(l, mid, nl, nr, v, ls);}
        \ControlFlowTok{if}\NormalTok{ (nl \textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ pre(mid + }\DecValTok{1}\NormalTok{, r, nl, nr, v, rs);}
        \ControlFlowTok{return}\NormalTok{ max(pre(l, mid, nl, mid, v, ls), pre(mid + }\DecValTok{1}\NormalTok{, r, mid + }\DecValTok{1}\NormalTok{, nr, v, rs));}
\NormalTok{    \}}

    \DataTypeTok{int}\NormalTok{ suc(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, }\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v, }\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{ (l == nl \&\& r == nr)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ res = fhq\_treap::}\FunctionTok{tr}\NormalTok{[x].suc(v);}
            \ControlFlowTok{return}\NormalTok{ res \textgreater{} v ? res : inf;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{ (nr \textless{}= mid) }\ControlFlowTok{return}\NormalTok{ suc(l, mid, nl, nr, v, ls);}
        \ControlFlowTok{if}\NormalTok{ (nl \textgreater{} mid) }\ControlFlowTok{return}\NormalTok{ suc(mid + }\DecValTok{1}\NormalTok{, r, nl, nr, v, rs);}
        \ControlFlowTok{return}\NormalTok{ min(suc(l, mid, nl, mid, v, ls), suc(mid + }\DecValTok{1}\NormalTok{, r, mid + }\DecValTok{1}\NormalTok{, nr, v, rs));}
\NormalTok{    \}}

\PreprocessorTok{\#undef ls}
\PreprocessorTok{\#undef rs}
\PreprocessorTok{\#undef mid}
\NormalTok{\}}

\KeywordTok{inline} \DataTypeTok{int}\NormalTok{  rank(}\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ seg\_tree::rank(}\DecValTok{1}\NormalTok{, n, nl, nr, v, }\DecValTok{1}\NormalTok{) + }\DecValTok{1}\NormalTok{; \}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ modify(}\DataTypeTok{int}\NormalTok{ pos, }\DataTypeTok{int}\NormalTok{ v) \{ seg\_tree::modify(}\DecValTok{1}\NormalTok{, n, pos, v, }\DecValTok{1}\NormalTok{), w[pos] = v; \}}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{  pre(}\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ seg\_tree::pre(}\DecValTok{1}\NormalTok{, n, nl, nr, v, }\DecValTok{1}\NormalTok{); \}}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{  suc(}\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ seg\_tree::suc(}\DecValTok{1}\NormalTok{, n, nl, nr, v, }\DecValTok{1}\NormalTok{); \}}

\PreprocessorTok{\#define mid }\NormalTok{((l+r)\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{)}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{  kth(}\DataTypeTok{int}\NormalTok{ nl, }\DataTypeTok{int}\NormalTok{ nr, }\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ l = }\DecValTok{0}\NormalTok{, r = }\FloatTok{1e8}\NormalTok{, ans;}
    \ControlFlowTok{while}\NormalTok{ (l \textless{}= r)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ s = seg\_tree::rank(}\DecValTok{1}\NormalTok{, n, nl, nr, mid + }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{ (s \textgreater{}= k) ans = mid, r = mid {-} }\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ l = mid + }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\PreprocessorTok{\#undef mid}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    n = read(), m = read();}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i \textless{}= n; i++) w[i] = read();}
\NormalTok{    fhq\_treap::init();}
\NormalTok{    seg\_tree::build(}\DecValTok{1}\NormalTok{, n, }\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{while}\NormalTok{ (m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ opt = read(), l, r, k;}
        \ControlFlowTok{if}\NormalTok{ (opt == }\DecValTok{3}\NormalTok{) l = read(), r = read(), modify(l, r);}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            l = read(), r = read(), k = read();}
            \ControlFlowTok{switch}\NormalTok{ (opt)}
\NormalTok{            \{}
                \ControlFlowTok{case} \DecValTok{1}\NormalTok{:printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, ::rank(l, r, k)); }\ControlFlowTok{break}\NormalTok{;}
                \ControlFlowTok{case} \DecValTok{2}\NormalTok{:printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, ::kth(l, r, k)); }\ControlFlowTok{break}\NormalTok{;}
                \ControlFlowTok{case} \DecValTok{4}\NormalTok{:printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, ::pre(l, r, k)); }\ControlFlowTok{break}\NormalTok{;}
                \ControlFlowTok{case} \DecValTok{5}\NormalTok{:printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{, ::suc(l, r, k)); }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e73ux8861ux6811ux5957ux7ebfux6bb5ux6811}{%
\subsubsection{4.平衡树套线段树}\label{ux5e73ux8861ux6811ux5957ux7ebfux6bb5ux6811}}

\href{https://www.lydsy.com/JudgeOnline/problem.php?id=3065}{BZOJ3065
带插入区间K小值}

\hypertarget{ux66b4ux529bux91cdux6784onlogn3}{%
\paragraph{暴力重构O(nlogn\^{}3)}\label{ux66b4ux529bux91cdux6784onlogn3}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ls }\NormalTok{ch[x][}\DecValTok{0}\NormalTok{]}
\PreprocessorTok{\#define rs }\NormalTok{ch[x][}\DecValTok{1}\NormalTok{]}

\KeywordTok{namespace}\NormalTok{ segment\_tree}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ node\_cnt;}
    \DataTypeTok{int}\NormalTok{ s[}\DecValTok{20000010}\NormalTok{],ch[}\DecValTok{20000010}\NormalTok{][}\DecValTok{2}\NormalTok{];}
    \DataTypeTok{int}\NormalTok{ tre[MAXN];}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} rec;}
    \DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x;}
        \ControlFlowTok{if}\NormalTok{(!rec.empty()) x=rec.back(),rec.ppb();}
        \ControlFlowTok{else}\NormalTok{ x=++node\_cnt;}
\NormalTok{        s[x]=ls=rs=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ remove(}\DataTypeTok{int}\NormalTok{ \&x) }\CommentTok{//垃圾回收}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) }\ControlFlowTok{return}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(ls) remove(ls);}
        \ControlFlowTok{if}\NormalTok{(rs) remove(rs);}
\NormalTok{        rec.pb(x),x=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        s[x]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(ls) s[x]+=s[ls];}
        \ControlFlowTok{if}\NormalTok{(rs) s[x]+=s[rs];}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x) x=newnode();}
        \ControlFlowTok{if}\NormalTok{(l==r)\{s[x]+=v;}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(pos\textless{}=mid) update(ls,l,mid,pos,v);}
        \ControlFlowTok{else}\NormalTok{ update(rs,mid+}\DecValTok{1}\NormalTok{,r,pos,v);}
\NormalTok{        pushup(x); }\ControlFlowTok{if}\NormalTok{(!s[x]) remove(x);}
\NormalTok{    \}}
\CommentTok{/*}
\CommentTok{    void debug(int x,int l,int r)}
\CommentTok{    \{}
\CommentTok{        if(l==r)\{if(s[x])printf("\%d ",l);return;\}}
\CommentTok{        debug(ls,l,mid);}
\CommentTok{        debug(rs,mid+1,r);}
\CommentTok{    \}}
\CommentTok{*/}
\NormalTok{\};}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ segment\_tree;}

\KeywordTok{namespace}\NormalTok{ scapegoat}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{double}\NormalTok{ alpha = }\FloatTok{0.75}\NormalTok{;}

    \DataTypeTok{int}\NormalTok{ node\_cnt,root,last;}
    \DataTypeTok{int}\NormalTok{ siz[MAXN],val[MAXN],ch[MAXN][}\DecValTok{2}\NormalTok{],fa[MAXN];}
\CommentTok{/*}
\CommentTok{    void debug(int x=root)}
\CommentTok{    \{}
\CommentTok{        if(ls) debug(ls);}
\CommentTok{        //cout \textless{}\textless{} val[x] \textless{}\textless{} " ";}
\CommentTok{        //cout \textless{}\textless{} dbgs4(x,fa[x],ls,rs) \textless{}\textless{} " ";}
\CommentTok{        //cout \textless{}\textless{} dbgs3(val[x],siz[x],tre[x]) \textless{}\textless{} endl;}

\CommentTok{        if(rs) debug(rs);}
\CommentTok{    \}}
\CommentTok{*/}
    \DataTypeTok{int}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x=++node\_cnt;}
\NormalTok{        siz[x]=}\DecValTok{1}\NormalTok{,fa[x]=par,val[x]=v,ls=rs=}\DecValTok{0}\NormalTok{,tre[x]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)\{siz[x]=siz[ls]+siz[rs]+}\DecValTok{1}\NormalTok{;\}}
    \DataTypeTok{bool}\NormalTok{ balance(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ max(siz[ls],siz[rs])\textless{}=siz[x]*alpha;\}}
    \DataTypeTok{bool}\NormalTok{ chk(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ ch[fa[x]][}\DecValTok{1}\NormalTok{]==x;\}}
    \DataTypeTok{int}\NormalTok{ seq[MAXN],head;}
    \DataTypeTok{int}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(r\textless{}l) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \DataTypeTok{int}\NormalTok{ x=seq[mid];}
\NormalTok{        remove(tre[x]),tre[x]=segment\_tree::newnode();}
\NormalTok{        fp(i,l,r) update(tre[x],}\DecValTok{0}\NormalTok{,N,val[seq[i]],}\DecValTok{1}\NormalTok{);}
\NormalTok{        ls=build(l,mid{-}}\DecValTok{1}\NormalTok{,x);}
\NormalTok{        rs=build(mid+}\DecValTok{1}\NormalTok{,r,x);}
\NormalTok{        fa[x]=par,pushup(x);}
        \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ls) dfs(ls);}
\NormalTok{        seq[++head]=x;}
        \ControlFlowTok{if}\NormalTok{(rs) dfs(rs);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ rebuild()}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!last) }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{        head=}\DecValTok{0}\NormalTok{,dfs(last);}
        \ControlFlowTok{if}\NormalTok{(!fa[last]) root=build(}\DecValTok{1}\NormalTok{,head,}\DecValTok{0}\NormalTok{);}
        \ControlFlowTok{else}\NormalTok{ ch[fa[last]][chk(last)]=build(}\DecValTok{1}\NormalTok{,head,fa[last]);}
\NormalTok{        last=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ a[],}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{    \{}
\NormalTok{        node\_cnt+=n;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) val[i]=a[i],seq[i]=i;}
\NormalTok{        root=build(}\DecValTok{1}\NormalTok{,n,}\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ change(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(siz[ls]+}\DecValTok{1}\NormalTok{==pos)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ t=val[x]; val[x]=v;}
\NormalTok{            update(tre[x],}\DecValTok{0}\NormalTok{,N,t,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{            update(tre[x],}\DecValTok{0}\NormalTok{,N,v, }\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{return}\NormalTok{ t;}
\NormalTok{        \}}
        \DataTypeTok{int}\NormalTok{ pre;}
        \ControlFlowTok{if}\NormalTok{(siz[ls]\textgreater{}=pos) pre=change(ls,pos,v);}
        \ControlFlowTok{else}\NormalTok{ pre=change(rs,pos{-}siz[ls]{-}}\DecValTok{1}\NormalTok{,v);}
\NormalTok{        update(tre[x],}\DecValTok{0}\NormalTok{,N,pre,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        update(tre[x],}\DecValTok{0}\NormalTok{,N,v  , }\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{return}\NormalTok{ pre;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x)}
\NormalTok{        \{}
\NormalTok{            x=newnode(v,par);}
\NormalTok{            update(tre[x],}\DecValTok{0}\NormalTok{,N,v,}\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{return}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(siz[ls]\textgreater{}=pos) insert(ls,pos,v,x);}
        \ControlFlowTok{else}\NormalTok{ insert(rs,pos{-}siz[ls]{-}}\DecValTok{1}\NormalTok{,v,x);}
\NormalTok{        update(tre[x],}\DecValTok{0}\NormalTok{,N,v,}\DecValTok{1}\NormalTok{),pushup(x);}
        \ControlFlowTok{if}\NormalTok{(!balance(x)) last=x;}
\NormalTok{    \}}

\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} cnt,a;}
    \DataTypeTok{void}\NormalTok{ find(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x||l\textgreater{}r) }\ControlFlowTok{return}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(l==}\DecValTok{1}\NormalTok{\&\&r==siz[x])\{cnt.pb(tre[x]);}\ControlFlowTok{return}\NormalTok{;\}}
        \ControlFlowTok{if}\NormalTok{(r\textless{}=siz[ls]) find(ls,l,r);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(l\textgreater{}siz[ls]+}\DecValTok{1}\NormalTok{) find(rs,l{-}siz[ls]{-}}\DecValTok{1}\NormalTok{,r{-}siz[ls]{-}}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{else}\NormalTok{ a.pb(val[x]),find(ls,l,siz[ls]),find(rs,}\DecValTok{1}\NormalTok{,r{-}siz[ls]{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{    \{}
\NormalTok{        cnt.clear(),a.clear(),find(root,nl,nr),sort(all(a));}
        \DataTypeTok{int}\NormalTok{ l=}\DecValTok{0}\NormalTok{,r=N;}
        \ControlFlowTok{while}\NormalTok{(l\textless{}r)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ sum=}\DecValTok{0}\NormalTok{;}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:cnt) sum+=s[segment\_tree::ls];}
\NormalTok{            sum+=upper\_bound(all(a),mid){-}lower\_bound(all(a),l);}
            \ControlFlowTok{if}\NormalTok{(sum\textgreater{}=k)\{}\ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:cnt) cnt[i]=segment\_tree::ls;r=mid;\}}
            \ControlFlowTok{else}\NormalTok{\{}\ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&x:cnt)cnt[i]=segment\_tree::rs;\}k{-}=sum,l=mid+}\DecValTok{1}\NormalTok{;\}}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ l;}
\NormalTok{    \}}
\NormalTok{\}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ scapegoat;}

\DataTypeTok{int}\NormalTok{ n,m,ans=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ arry[MAXN];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&arry[i]);}
\NormalTok{    init(arry,n);}

\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&m);}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{char}\NormalTok{ s[}\DecValTok{5}\NormalTok{];}\DataTypeTok{int}\NormalTok{ x,y,k=}\DecValTok{0}\NormalTok{;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,s),scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&x,\&y),x\^{}=ans,y\^{}=ans;}
        \ControlFlowTok{if}\NormalTok{(s[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{) scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&k),k\^{}=ans,printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans=query(x,y,k));}
        \ControlFlowTok{if}\NormalTok{(s[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}M\textquotesingle{}}\NormalTok{) change(root,x,y);}
        \ControlFlowTok{if}\NormalTok{(s[}\DecValTok{0}\NormalTok{]==}\CharTok{\textquotesingle{}I\textquotesingle{}}\NormalTok{) insert(root,x{-}}\DecValTok{1}\NormalTok{,y,}\DecValTok{0}\NormalTok{),rebuild();}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6bb5ux6811ux5408ux5e76-1}{%
\paragraph{线段树合并}\label{ux7ebfux6bb5ux6811ux5408ux5e76-1}}

\hypertarget{kd-tree}{%
\subsection{KD-Tree}\label{kd-tree}}

\textbf{注意：除了矩阵覆盖以外的查询(邻域查询等)最坏复杂度都是 \(O(n)\)
的，需保证 随机数据 / 出题人想让考 kd-tree}

\hypertarget{ux901aux7528}{%
\subsubsection{通用}\label{ux901aux7528}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#define ls }\NormalTok{ch[x][}\DecValTok{0}\NormalTok{]}
\PreprocessorTok{\#define rs }\NormalTok{ch[x][}\DecValTok{1}\NormalTok{]}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ K = }\DecValTok{3}\NormalTok{; }\CommentTok{//维度}
\AttributeTok{const} \DataTypeTok{float}\NormalTok{ alpha = }\FloatTok{0.85}\NormalTok{; }\CommentTok{//平衡因子}
\DataTypeTok{int}\NormalTok{ n,m,last,root;}
\DataTypeTok{int}\NormalTok{ ch[MAXN][}\DecValTok{2}\NormalTok{],fa[MAXN],cmpd[MAXN]; }\CommentTok{//节点固有属性}
\DataTypeTok{int}\NormalTok{ siz[MAXN],mx[MAXN][K],mn[MAXN][K]; }\CommentTok{//pushup维护}

\DataTypeTok{bool}\NormalTok{ balance(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ siz[ls]\textless{}=siz[x]*alpha\&\&siz[rs]\textless{}=siz[x]*alpha;\}}
\DataTypeTok{int}\NormalTok{ cnt,h,rec[MAXN];}
\DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x=h?rec[h{-}{-}]:++cnt;}
\NormalTok{    ls=rs=fa[x]=cmpd[x]=siz[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{)mx[x][k]=mn[x][k]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{\}}
\KeywordTok{struct}\NormalTok{ point}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ d[K],num=}\DecValTok{1}\NormalTok{,v=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{==(}\AttributeTok{const}\NormalTok{ point \&t)}\AttributeTok{const}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{)}
            \ControlFlowTok{if}\NormalTok{(d[i]!=t.d[i])}
                \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{bool} \KeywordTok{operator}\NormalTok{!=(}\AttributeTok{const}\NormalTok{ point \&t)}\AttributeTok{const}\NormalTok{\{}\ControlFlowTok{return}\NormalTok{ !(*}\KeywordTok{this}\NormalTok{==t);\}}
\NormalTok{\}p[MAXN];}
\DataTypeTok{void}\NormalTok{ pushup(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
\NormalTok{    siz[x]=siz[ls]+siz[rs]+}\DataTypeTok{bool}\NormalTok{(p[x].num);}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(p[x].num)mx[x][k]=mn[x][k]=p[x].d[k];}
        \ControlFlowTok{else}\NormalTok{ mx[x][k]={-}inf,mn[x][k]=inf;}
        \ControlFlowTok{if}\NormalTok{(ls)}
\NormalTok{        \{}
\NormalTok{            mx[x][k]=max(mx[x][k],mx[ls][k]);}
\NormalTok{            mn[x][k]=min(mn[x][k],mn[ls][k]);}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(rs)}
\NormalTok{        \{}
\NormalTok{            mx[x][k]=max(mx[x][k],mx[rs][k]);}
\NormalTok{            mn[x][k]=min(mn[x][k],mn[rs][k]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ curd;}\DataTypeTok{bool}\NormalTok{ cmp(}\AttributeTok{const}\NormalTok{ point \&a,}\AttributeTok{const}\NormalTok{ point \&b)\{}\ControlFlowTok{return}\NormalTok{ a.d[curd]\textless{}b.d[curd];\}}
\DataTypeTok{int}\NormalTok{ build(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ par,point t[])}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l\textgreater{}r)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ x=newnode();}
    \CommentTok{//curd=cmpd[x]=(cmpd[par]+1)\%K; //交替选法 容易被卡}

    \CommentTok{//选方差大的一维}
\NormalTok{    db a[K]=\{}\DecValTok{0}\NormalTok{\},v[K]=\{}\DecValTok{0}\NormalTok{\};}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        fp(i,l,r)a[k]+=t[i].d[k];}
\NormalTok{        a[k]/=(r{-}l+}\DecValTok{1}\NormalTok{);}
\NormalTok{        fp(i,l,r)v[k]+=sqr(a[k]{-}t[i].d[k]);}
\NormalTok{    \}}
\NormalTok{    curd=cmpd[x]=(max\_element(v,v+K){-}v);}
    
\NormalTok{    fa[x]=par; }
\NormalTok{    nth\_element(t+l,t+mid,t+r+}\DecValTok{1}\NormalTok{,cmp),p[x]=t[mid];}
\NormalTok{    ls=build(l,mid{-}}\DecValTok{1}\NormalTok{,x,t);}
\NormalTok{    rs=build(mid+}\DecValTok{1}\NormalTok{,r,x,t);}
\NormalTok{    pushup(x);}
    \ControlFlowTok{return}\NormalTok{ x;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ init()\{cnt=root=last=h=}\DecValTok{0}\NormalTok{;\} }\CommentTok{//多组初始化}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux90bbux57dfux67e5ux8be2}{%
\subsubsection{邻域查询}\label{ux90bbux57dfux67e5ux8be2}}

查询 欧几里德/曼哈顿 最近/最远 点

\textbf{曼哈顿最近/最远点有能保证复杂度的 cdq 分治的解法，优先考虑}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//邻域查询 最坏O(n)}
\NormalTok{LL eudis(point a,point b)\{}\ControlFlowTok{return} \DecValTok{1}\BuiltInTok{LL}\NormalTok{*sqr(a.d[}\DecValTok{0}\NormalTok{]{-}b.d[}\DecValTok{0}\NormalTok{])+}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*sqr(a.d[}\DecValTok{1}\NormalTok{]{-}b.d[}\DecValTok{1}\NormalTok{]);\}}
\NormalTok{LL eumin(}\DataTypeTok{int}\NormalTok{ x,point q) }\CommentTok{//欧几里得下界}
\NormalTok{\{}
\NormalTok{    LL dis=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(q.d[k]\textless{}=mn[x][k])dis+=sqr(q.d[k]{-}mn[x][k]);}
        \ControlFlowTok{if}\NormalTok{(q.d[k]\textgreater{}=mx[x][k])dis+=sqr(q.d[k]{-}mx[x][k]);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ dis;}
\NormalTok{\}}
\NormalTok{LL eumax(}\DataTypeTok{int}\NormalTok{ x,point q) }\CommentTok{//欧几里得上界}
\NormalTok{\{}
\NormalTok{    LL dis=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)dis+=max(sqr(q.d[k]{-}mx[x][k]),sqr(q.d[k]{-}mn[x][k]));}
    \ControlFlowTok{return}\NormalTok{ dis;}
\NormalTok{\}}
\NormalTok{LL ans;}
\DataTypeTok{void}\NormalTok{ qeumin(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    LL ld=eumin(ls,q),rd=eumin(rs,q),d=eudis(p[x],q);}
    \ControlFlowTok{if}\NormalTok{(p[x].num)ans=min(ans,d);}
    \ControlFlowTok{if}\NormalTok{(ld\textless{}rd)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ld\textless{}ans)qeumin(ls,q);}
        \ControlFlowTok{if}\NormalTok{(rd\textless{}ans)qeumin(rs,q);}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(rd\textless{}ans)qeumin(rs,q);}
        \ControlFlowTok{if}\NormalTok{(ld\textless{}ans)qeumin(ls,q);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ qeumax(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    LL ld=eumax(ls,q),rd=eumax(rs,q),d=eudis(p[x],q);}
    \ControlFlowTok{if}\NormalTok{(p[x].num)ans=max(ans,d);}
    \ControlFlowTok{if}\NormalTok{(ld\textgreater{}rd)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ld\textgreater{}ans)qeumax(ls,q);}
        \ControlFlowTok{if}\NormalTok{(rd\textgreater{}ans)qeumax(rs,q);}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(rd\textgreater{}ans)qeumax(rs,q);}
        \ControlFlowTok{if}\NormalTok{(ld\textgreater{}ans)qeumax(ls,q);}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{//曼哈顿距离}
\NormalTok{LL mandis(point a,point b)\{}\ControlFlowTok{return}\NormalTok{ abs(a.d[}\DecValTok{0}\NormalTok{]{-}b.d[}\DecValTok{0}\NormalTok{])+abs(a.d[}\DecValTok{1}\NormalTok{]{-}b.d[}\DecValTok{1}\NormalTok{]);\}}
\NormalTok{LL manmin(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
\NormalTok{    LL dis=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(q.d[k]\textless{}=mn[x][k])dis+=abs(q.d[k]{-}mn[x][k]);}
        \ControlFlowTok{if}\NormalTok{(q.d[k]\textgreater{}=mx[x][k])dis+=abs(q.d[k]{-}mx[x][k]);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ dis;}
\NormalTok{\}}
\NormalTok{LL manmax(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
\NormalTok{    LL dis=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(k,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)dis+=max(abs(q.d[k]{-}mx[x][k]),abs(q.d[k]{-}mn[x][k]));}
    \ControlFlowTok{return}\NormalTok{ dis;}
\NormalTok{\}}
\CommentTok{//LL ans;}
\DataTypeTok{void}\NormalTok{ qmanmin(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    LL ld=manmin(ls,q),rd=manmin(rs,q),d=mandis(p[x],q);}
    \ControlFlowTok{if}\NormalTok{(p[x].num)ans=min(ans,d);}
    \ControlFlowTok{if}\NormalTok{(ld\textless{}rd)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ld\textless{}ans)qmanmin(ls,q);}
        \ControlFlowTok{if}\NormalTok{(rd\textless{}ans)qmanmin(rs,q);}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(rd\textless{}ans)qmanmin(rs,q);}
        \ControlFlowTok{if}\NormalTok{(ld\textless{}ans)qmanmin(ls,q);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ qmanmax(}\DataTypeTok{int}\NormalTok{ x,point q)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    LL ld=manmax(ls,q),rd=manmax(rs,q),d=mandis(p[x],q);}
    \ControlFlowTok{if}\NormalTok{(p[x].num)ans=max(ans,d);}
    \ControlFlowTok{if}\NormalTok{(ld\textgreater{}rd)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(ld\textgreater{}ans)qmanmax(ls,q);}
        \ControlFlowTok{if}\NormalTok{(rd\textgreater{}ans)qmanmax(rs,q);}
\NormalTok{    \}}
    \ControlFlowTok{else}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(rd\textgreater{}ans)qmanmax(rs,q);}
        \ControlFlowTok{if}\NormalTok{(ld\textgreater{}ans)qmanmax(ls,q);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e26ux63d2ux5165ux5220ux9664ux66ffux7f6aux7f8aux6811ux91cdux6784ux601dux60f3}{%
\subsubsection{带插入删除(替罪羊树重构思想)}\label{ux5e26ux63d2ux5165ux5220ux9664ux66ffux7f6aux7f8aux6811ux91cdux6784ux601dux60f3}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ par,point val) }\CommentTok{//val.num默认为1}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x) }\CommentTok{//开辟新节点}
\NormalTok{    \{}
\NormalTok{        x=newnode();}
\NormalTok{        p[x]=val;}
\NormalTok{        fa[x]=par;}
\NormalTok{        cmpd[x]=(cmpd[par]+}\DecValTok{1}\NormalTok{)\%K;}
\NormalTok{        pushup(x);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(val==p[x]) }\CommentTok{//处理重点}
\NormalTok{    \{}
\NormalTok{        p[x].v=val.v;}
\NormalTok{        p[x].num+=val.num;}
\NormalTok{        pushup(x);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    curd=cmpd[x];}
    \ControlFlowTok{if}\NormalTok{(cmp(val,p[x]))insert(ch[x][}\DecValTok{0}\NormalTok{],x,val);}
    \ControlFlowTok{else}\NormalTok{ insert(ch[x][}\DecValTok{1}\NormalTok{],x,val);}
\NormalTok{    pushup(x);}
    \ControlFlowTok{if}\NormalTok{(!balance(x))last=x;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ remove(}\DataTypeTok{int}\NormalTok{ x,point val) }\CommentTok{//删除节点 默认p[x].num{-}{-}}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(p[x]==val)}
\NormalTok{    \{}
\NormalTok{        p[x].num{-}=val.num;}
\NormalTok{        pushup(x);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    curd=cmpd[x];}
    \ControlFlowTok{if}\NormalTok{(cmp(val,p[x]))remove(ls,val);}
    \ControlFlowTok{else}\NormalTok{ remove(rs,val);}
\NormalTok{    pushup(x);}
    \ControlFlowTok{if}\NormalTok{(!balance(x))last=x;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ tail; point t[MAXN]; }
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(p[x].num)t[++tail]=p[x];}
\NormalTok{    rec[++h]=x;}
\NormalTok{    dfs(ls);}
\NormalTok{    dfs(rs);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ rebuild() }\CommentTok{//每次 insert 或 remove 后调用一下}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!last)}\ControlFlowTok{return}\NormalTok{;}
\NormalTok{    tail=}\DecValTok{0}\NormalTok{,dfs(last);}
    \DataTypeTok{int}\NormalTok{ x=fa[last],w=(ch[x][}\DecValTok{1}\NormalTok{]==last),\&p=x?ch[x][w]:root;}
\NormalTok{    p=build(}\DecValTok{1}\NormalTok{,tail,x,t);}
\NormalTok{    last=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux9ad8ux7ef4ux8be2ux95eeux4feeux6539}{%
\subsubsection{高维询问/修改}\label{ux9ad8ux7ef4ux8be2ux95eeux4feeux6539}}

复杂度 \(O(\log_{2}{n})\) \textasciitilde{} \(O(\sqrt{n})\)

询问矩阵和

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ X1,X2,Y1,Y2;}
\NormalTok{LL query(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(X1\textless{}=mn[x][}\DecValTok{0}\NormalTok{]\&\&X2\textgreater{}=mx[x][}\DecValTok{0}\NormalTok{]\&\&Y1\textless{}=mn[x][}\DecValTok{1}\NormalTok{]\&\&Y2\textgreater{}=mx[x][}\DecValTok{1}\NormalTok{])}\ControlFlowTok{return}\NormalTok{ sum[x];}
    \ControlFlowTok{if}\NormalTok{(X2\textless{}mn[x][}\DecValTok{0}\NormalTok{]||X1\textgreater{}mx[x][}\DecValTok{0}\NormalTok{]||Y1\textgreater{}mx[x][}\DecValTok{1}\NormalTok{]||Y2\textless{}mn[x][}\DecValTok{1}\NormalTok{])}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ (p[x].d[}\DecValTok{0}\NormalTok{]\textgreater{}=X1\&\&p[x].d[}\DecValTok{0}\NormalTok{]\textless{}=X2\&\&p[x].d[}\DecValTok{1}\NormalTok{]\textgreater{}=Y1\&\&p[x].d[}\DecValTok{1}\NormalTok{]\textless{}=Y2?p[x].v:}\DecValTok{0}\NormalTok{)+}
\NormalTok{        query(ls)+query(rs);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

区间修改(YY)：类似线段树/平衡树，维护懒标记

重构时注意 \(pushdown\)

\hypertarget{ux5b57ux7b26ux4e32}{%
\section{字符串}\label{ux5b57ux7b26ux4e32}}

单模式串 -\textgreater{} KMP

多模式串 -\textgreater{} AC自动机

单文本串 -\textgreater{} SA/SAM

多文本串 -\textgreater{} 广义SAM

\hypertarget{ux5b57ux7b26ux4e32ux54c8ux5e0c}{%
\subsection{字符串哈希}\label{ux5b57ux7b26ux4e32ux54c8ux5e0c}}

\hypertarget{ux6a21ux677f-3}{%
\subsubsection{模板}\label{ux6a21ux677f-3}}

\hypertarget{ux81eaux7136ux6ea2ux51fa}{%
\paragraph{1.自然溢出}\label{ux81eaux7136ux6ea2ux51fa}}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ ULL BASE = }\DecValTok{13331}\NormalTok{;}
\NormalTok{ULL p[MAXN];}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    p[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}MAXN;i++)}
\NormalTok{        p[i]=p[i{-}}\DecValTok{1}\NormalTok{]*BASE;}
\NormalTok{\}}

\KeywordTok{struct}\NormalTok{ myHash}
\NormalTok{\{}
\NormalTok{    ULL h[MAXN];}
\NormalTok{    hash(}\AttributeTok{const} \DataTypeTok{char}\NormalTok{ str[]) \{init(str);\}}
    \DataTypeTok{void}\NormalTok{ init(}\AttributeTok{const} \DataTypeTok{char}\NormalTok{ str[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=strlen(str);}
\NormalTok{        h[n]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n{-}}\DecValTok{1}\NormalTok{;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-}) }\CommentTok{//倒着hash i位为最低位 n为最高位 方便获取子串hash值}
\NormalTok{            h[i]=h[i+}\DecValTok{1}\NormalTok{]*BASE+str[i]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    ULL get\_hash(}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ length) }\CommentTok{//从下标i开始长度为length的字串的hash值}
\NormalTok{    \{}
        \ControlFlowTok{return}\NormalTok{ h[i]{-}h[i+length]*p[length];}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux7ef4ux77e9ux9635hash}{%
\paragraph{2.二维矩阵hash}\label{ux4e8cux7ef4ux77e9ux9635hash}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//二维hash 取两个base}
\CommentTok{//统计b矩阵在a矩阵中的出现次数}

\AttributeTok{const}\NormalTok{ ULL base1 = }\DecValTok{13331}\NormalTok{;}
\AttributeTok{const}\NormalTok{ ULL base2 = }\DecValTok{23333}\NormalTok{;}
\NormalTok{ULL p1[MAXN],p2[MAXN];}
\DataTypeTok{void}\NormalTok{ pre()}
\NormalTok{\{}
\NormalTok{    p1[}\DecValTok{0}\NormalTok{]=p2[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}MAXN;i++)}
\NormalTok{        p1[i]=p1[i{-}}\DecValTok{1}\NormalTok{]*base1,}
\NormalTok{        p2[i]=p2[i{-}}\DecValTok{1}\NormalTok{]*base2;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ T,n1,m1,n2,m2;}
\DataTypeTok{char}\NormalTok{ a[MAXN][MAXN],b[MAXN][MAXN];}
\NormalTok{ULL h[MAXN][MAXN];}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n1;i++)}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=m1;j++)}
\NormalTok{            h[i][j]=h[i][j{-}}\DecValTok{1}\NormalTok{]*base2+h[i{-}}\DecValTok{1}\NormalTok{][j]*base1}
\NormalTok{                {-}h[i{-}}\DecValTok{1}\NormalTok{][j{-}}\DecValTok{1}\NormalTok{]*base1*base2+(a[i][j]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\NormalTok{ULL get\_hash(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ lx,}\DataTypeTok{int}\NormalTok{ ly)}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{  +h[x+lx{-}}\DecValTok{1}\NormalTok{][y+ly{-}}\DecValTok{1}\NormalTok{]}
\NormalTok{            {-}h[x+lx{-}}\DecValTok{1}\NormalTok{][y{-}}\DecValTok{1}\NormalTok{]*p2[ly]}
\NormalTok{            {-}h[x{-}}\DecValTok{1}\NormalTok{][y+ly{-}}\DecValTok{1}\NormalTok{]*p1[lx]}
\NormalTok{            +h[x{-}}\DecValTok{1}\NormalTok{][y{-}}\DecValTok{1}\NormalTok{]*p1[lx]*p2[ly];}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    pre();}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n1,\&m1);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n1;i++) scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,a[i]+}\DecValTok{1}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n2,\&m2);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n2;i++) scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,b[i]+}\DecValTok{1}\NormalTok{);}

\NormalTok{        init();}

\NormalTok{        ULL t=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n2;i++)}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=m2;j++)}
\NormalTok{                t+=(b[i][j]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{)*p1[n2{-}i]*p2[m2{-}j];}\CommentTok{//注意下标}

        \DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n1{-}n2+}\DecValTok{1}\NormalTok{;i++)}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=m1{-}m2+}\DecValTok{1}\NormalTok{;j++)}
                \ControlFlowTok{if}\NormalTok{(get\_hash(i,j,n2,m2)==t)}
\NormalTok{                    ans++;}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux53cchash}{%
\paragraph{3.双hash}\label{ux53cchash}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//备用 模数\&base}
\CommentTok{//const ULL MOD1 = 1610612741;}
\CommentTok{//const ULL MOD2 = 1222827239;}

\CommentTok{//const ULL BASE1 = 1331;}
\CommentTok{//const ULL BASE2 = 131;}

\AttributeTok{const}\NormalTok{ ULL MOD1 = }\DecValTok{402653189}\NormalTok{;}
\AttributeTok{const}\NormalTok{ ULL MOD2 = }\DecValTok{805306457}\NormalTok{;}

\AttributeTok{const}\NormalTok{ ULL BASE1 = }\DecValTok{13331}\NormalTok{;}
\AttributeTok{const}\NormalTok{ ULL BASE2 = }\DecValTok{23333}\NormalTok{;}

\NormalTok{ULL p[MAXN][}\DecValTok{2}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    p[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]=p[}\DecValTok{0}\NormalTok{][}\DecValTok{1}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}MAXN;i++) p[i][}\DecValTok{0}\NormalTok{]=p[i{-}}\DecValTok{1}\NormalTok{][}\DecValTok{0}\NormalTok{]*BASE1\%MOD1;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}MAXN;i++) p[i][}\DecValTok{1}\NormalTok{]=p[i{-}}\DecValTok{1}\NormalTok{][}\DecValTok{1}\NormalTok{]*BASE2\%MOD2;}
\NormalTok{\}}
\KeywordTok{struct}\NormalTok{ myHash}
\NormalTok{\{}
\NormalTok{    ULL h[MAXN][}\DecValTok{2}\NormalTok{];}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{char}\NormalTok{ s[],}\DataTypeTok{int}\NormalTok{ n=}\DecValTok{0}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        n=strlen(s),h[n][}\DecValTok{0}\NormalTok{]=h[n][}\DecValTok{1}\NormalTok{]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n{-}}\DecValTok{1}\NormalTok{;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-}) h[i][}\DecValTok{0}\NormalTok{]=(h[i+}\DecValTok{1}\NormalTok{][}\DecValTok{0}\NormalTok{]*BASE1\%MOD1+s[i]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{)\%MOD1;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n{-}}\DecValTok{1}\NormalTok{;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-}) h[i][}\DecValTok{1}\NormalTok{]=(h[i+}\DecValTok{1}\NormalTok{][}\DecValTok{1}\NormalTok{]*BASE2\%MOD2+s[i]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{)\%MOD2;}
\NormalTok{    \}}
\NormalTok{    upr get\_hash(}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ length)}
\NormalTok{    \{}
        \ControlFlowTok{return}\NormalTok{ \{}
\NormalTok{            ((h[pos][}\DecValTok{0}\NormalTok{]{-}h[pos+length][}\DecValTok{0}\NormalTok{]*p[length][}\DecValTok{0}\NormalTok{]\%MOD1)+MOD1)\%MOD1,}
\NormalTok{            ((h[pos][}\DecValTok{1}\NormalTok{]{-}h[pos+length][}\DecValTok{1}\NormalTok{]*p[length][}\DecValTok{1}\NormalTok{]\%MOD2)+MOD2)\%MOD2}
\NormalTok{        \};}
\NormalTok{    \}}
\NormalTok{\};}
\NormalTok{upr make\_hash(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=strlen(s);}
\NormalTok{    upr ans;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n{-}}\DecValTok{1}\NormalTok{;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
\NormalTok{    \{}
\NormalTok{        ans.fi=(ans.fi*BASE1\%MOD1+s[i]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{)\%MOD1;}
\NormalTok{        ans.se=(ans.se*BASE2\%MOD2+s[i]{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{)\%MOD2;}
\NormalTok{    \}   }
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e8fux5217ux81eaux52a8ux673a}{%
\subsection{序列自动机}\label{ux5e8fux5217ux81eaux52a8ux673a}}

维护 \(nx[i][c]\) 表示在 \(i\) 之后的最近的字符 \(c\) 的下标

若将 \(i\) 看作是点，\(nx[i][c]\)
看作是转移边，那么原字符串的每一个子序列都对唯一对应着 DAG 上的一条路径

值域过大时可以考虑使用主席树来存边:
\href{https://www.luogu.com.cn/problem/P5826}{【模板】子序列自动机}

也可以使用 vector 存下所有元素出现的位置，贪心匹配

\hypertarget{ux957fux5ea6ux4e3a-k-ux7684ux672cux8d28ux4e0dux540cux5b50ux5e8fux5217ux4e2aux6570}{%
\subsubsection{\texorpdfstring{长度为 \(k\)
的本质不同子序列个数}{长度为 k 的本质不同子序列个数}}\label{ux957fux5ea6ux4e3a-k-ux7684ux672cux8d28ux4e0dux540cux5b50ux5e8fux5217ux4e2aux6570}}

DAG 上 dp

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,k;}
\DataTypeTok{int}\NormalTok{ nx[MAXN][}\DecValTok{26}\NormalTok{],t[}\DecValTok{26}\NormalTok{];}
\NormalTok{LL f[MAXN][MAXN],ans;}
\DataTypeTok{char}\NormalTok{ s[MAXN];}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&k);    }
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,s+}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{(k==}\DecValTok{0}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,}\DecValTok{25}\NormalTok{)t[i]=n+}\DecValTok{1}\NormalTok{;}
\NormalTok{    fd(i,n,}\DecValTok{0}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        memcpy(nx[i],t,}\KeywordTok{sizeof}\NormalTok{(t));}
        \ControlFlowTok{if}\NormalTok{(i)t[s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]=i;}
\NormalTok{    \}}
\NormalTok{    f[}\DecValTok{0}\NormalTok{][}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,n)fp(j,}\DecValTok{0}\NormalTok{,i)}\ControlFlowTok{if}\NormalTok{(f[i][j])}
\NormalTok{        fp(c,}\DecValTok{0}\NormalTok{,}\DecValTok{25}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(nx[i][c]\textless{}=n)}
\NormalTok{            f[nx[i][c]][j+}\DecValTok{1}\NormalTok{]+=f[i][j],}
\NormalTok{            f[nx[i][c]][j+}\DecValTok{1}\NormalTok{]\%=MOD;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)ans+=f[i][k],ans\%=MOD;}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6811ux72b6ux6570ux7ec4ux7ef4ux62a4ux5b57ux7b26ux4e32ux54c8ux5e0c}{%
\subsection{树状数组维护字符串哈希}\label{ux6811ux72b6ux6570ux7ec4ux7ef4ux62a4ux5b57ux7b26ux4e32ux54c8ux5e0c}}

支持单点修改，查询子串哈希值。

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ ULL BASE = }\DecValTok{4238197}\BuiltInTok{ll}\NormalTok{;}
\NormalTok{ULL p[N+}\DecValTok{5}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ init()\{p[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,N{-}}\DecValTok{1}\NormalTok{)p[i]=p[i{-}}\DecValTok{1}\NormalTok{]*BASE;\}}
\KeywordTok{namespace}\NormalTok{ BIT}
\NormalTok{\{}
\NormalTok{    ULL h[N];}
    \KeywordTok{inline} \DataTypeTok{int}\NormalTok{ lowbit(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ x\&{-}x;\}}
    \KeywordTok{inline} \DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,ULL v)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\AttributeTok{register} \DataTypeTok{int}\NormalTok{ i=x;i\textless{}N;i+=i\&{-}i)}
\NormalTok{            h[i]+=p[i{-}x]*v;}
\NormalTok{    \}}
    \KeywordTok{inline}\NormalTok{ ULL sum(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
\NormalTok{        ULL ans = }\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\AttributeTok{register} \DataTypeTok{int}\NormalTok{ i=x;i;i{-}=i\&{-}i)}
\NormalTok{            ans+=p[x{-}i]*h[i];}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
    \KeywordTok{inline}\NormalTok{ ULL query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(r\textless{}l) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ sum(r){-}sum(l{-}}\DecValTok{1}\NormalTok{)*p[r{-}l+}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{kmp}{%
\subsection{KMP}\label{kmp}}

\hypertarget{ux8d44ux6599-2}{%
\subsubsection{资料}\label{ux8d44ux6599-2}}

\href{https://oi-wiki.org/string/kmp/}{前缀函数与 KMP 算法 OI Wiki\\
} \#\#\# 模板 \#\#\#

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ kmp}
\NormalTok{\{}
\NormalTok{    string a;}
    \DataTypeTok{int}\NormalTok{ n,nx[MAXN];}
    \DataTypeTok{void}\NormalTok{ get\_nx(string \&str)}
\NormalTok{    \{}
\NormalTok{        a=str,n=str.length(),nx[}\DecValTok{0}\NormalTok{]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ j=nx[i{-}}\DecValTok{1}\NormalTok{];}
            \ControlFlowTok{while}\NormalTok{(j\&\&a[i]!=a[j]) j=nx[j{-}}\DecValTok{1}\NormalTok{];}
            \ControlFlowTok{if}\NormalTok{(a[i]==a[j]) j++;}
\NormalTok{            nx[i]=j;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} match(string \&b,vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} pos=\{\})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ m=b.length();}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{,j=}\DecValTok{0}\NormalTok{;i\textless{}m;i++)}
\NormalTok{        \{}
            \ControlFlowTok{while}\NormalTok{(j\&\&b[i]!=a[j]) j=nx[j{-}}\DecValTok{1}\NormalTok{];}
            \ControlFlowTok{if}\NormalTok{(b[i]==a[j]) j++;}
            \ControlFlowTok{if}\NormalTok{(j==n) pos.pb(i{-}n+}\DecValTok{1}\NormalTok{),j=nx[j{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ pos;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e94ux7528}{%
\subsubsection{应用}\label{ux5e94ux7528}}

\hypertarget{ux6c42ux5b57ux7b26ux4e32ux7684ux6700ux5c0fux5faaux73afux8282}{%
\paragraph{1.求字符串的最小循环节}\label{ux6c42ux5b57ux7b26ux4e32ux7684ux6700ux5c0fux5faaux73afux8282}}

设字符串长度为 \(N\) 下标从0开始，设 \(L=N-next[N-1]\)，若 \(N\) \%
\(L=0\)则存在最小循环节且长度为 \(L\)，否则最少需要补充 \(N-N\) \% \(L\)
个字符串使其存在循环节。

若求一个字符串的所有循环节则需要不断跳 \(nx[j-1]\) 直到 \(j\) 变为
\(0\)， 因为最小循环节不一定能构造出所有可行的循环节，如字符串
\(ababaaaabab\) 中 \(7\) 和 \(9\) 都是一个可行的循环节。 \#\#\#\#
2.求字符串 \(S\) 每一个前缀在字符串 \(T\) 中的出现次数 \#\#\#\#

将字符串 \(S\) 和 \(T\)
用不出现在两个字符串内的字符(如'\#')拼接起来，对于 \(i>=n+1\) 的
\(nx[i]\) 用以下代码计算。

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} ans(n + }\DecValTok{1}\NormalTok{);}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} n; i++) ans[nx[i]]++;}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = n {-} }\DecValTok{1}\NormalTok{; i \textgreater{} }\DecValTok{0}\NormalTok{; i{-}{-}) ans[nx[i {-} }\DecValTok{1}\NormalTok{]] += ans[i];}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{}= n; i++) ans[i]++;}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6269ux5c55kmp}{%
\subsection{扩展kmp}\label{ux6269ux5c55kmp}}

扩展kmp可在线性时间复杂度内求解字符串 \(S\) 的每一个后缀与字符串 \(T\)
的最长公共前缀。

\(next[i]\) 表示 \(T[1...i-1]\) 与 \(T[i...m-1]\) 的最长公共前缀

\(ext[i]\) 表示 \(S\) 的后缀 \(S[i...n-1]\) 与字符串 \(T\)
的最长公共前缀

\hypertarget{ux8d44ux6599-3}{%
\subsubsection{资料}\label{ux8d44ux6599-3}}

\href{https://segmentfault.com/a/1190000008663857}{扩展KMP算法}

\hypertarget{ux6a21ux677f-4}{%
\subsubsection{模板}\label{ux6a21ux677f-4}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ exkmp }\CommentTok{//字符串下标从0开始}
\NormalTok{\{}
\NormalTok{    string T;}
    \DataTypeTok{int}\NormalTok{ m,nx[MAXN],ext[MAXN];}
    \DataTypeTok{void}\NormalTok{ get\_nx(string \&str)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ a=}\DecValTok{0}\NormalTok{,p=}\DecValTok{0}\NormalTok{;}
\NormalTok{        m=str.length(),nx[}\DecValTok{0}\NormalTok{]=m,T=str;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}m;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(i\textgreater{}=p||i+nx[i{-}a]\textgreater{}=p)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(i\textgreater{}=p) p=i;}
                \ControlFlowTok{while}\NormalTok{(p\textless{}m\&\&T[p]==T[p{-}i]) p++;}
\NormalTok{                nx[i]=p{-}i,a=i;}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ nx[i]=nx[i{-}a];}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ get\_ext(string \&S)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ a=}\DecValTok{0}\NormalTok{,p=}\DecValTok{0}\NormalTok{,n=S.length();}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(i\textgreater{}=p||i+nx[i{-}a]\textgreater{}=p)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(i\textgreater{}=p) p=i;}
                \ControlFlowTok{while}\NormalTok{(p\textless{}n\&\&p{-}i\textless{}m\&\&S[p]==T[p{-}i]) p++;}
\NormalTok{                ext[i]=p{-}i,a=i;}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ ext[i]=nx[i{-}a];}
\NormalTok{        \}}

\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5b57ux7b26ux4e32ux6700ux5c0fux8868ux793aux6cd5}{%
\subsection{字符串最小表示法}\label{ux5b57ux7b26ux4e32ux6700ux5c0fux8868ux793aux6cd5}}

\hypertarget{ux5faaux73afux540cux6784}{%
\subsubsection{循环同构}\label{ux5faaux73afux540cux6784}}

当字符串 \(S\) 中可以选定一个位置 \(i\) 满足
\[ S[i...n] + S[1...i-1] = T \] 则称字符串 \(S\) 与 \(T\) 循环同构。

\hypertarget{ux6700ux5c0fux8868ux793a}{%
\subsubsection{最小表示}\label{ux6700ux5c0fux8868ux793a}}

与字符串 \(S\)
循环同构的字符串中字典序最小(大)的字符串，判断两个字符串是否循环同构时可以求出它们最小表示并比较。

\hypertarget{ux8d44ux6599-4}{%
\subsubsection{资料}\label{ux8d44ux6599-4}}

\href{https://oi-wiki.org/string/minimal-string/\#simple}{最小表示法 OI
Wiki}

\hypertarget{ux6a21ux677f-5}{%
\subsubsection{模板}\label{ux6a21ux677f-5}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ get\_min\_rep(string \&s)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=s.length();}
    \DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{,j=}\DecValTok{1}\NormalTok{,k=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(i\textless{}n\&\&j\textless{}n\&\&k\textless{}n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l=(i+k)\%n,r=(j+k)\%n;}
        \ControlFlowTok{if}\NormalTok{(s[l]==s[r]) k++;}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            s[l]\textgreater{}s[r]?(i+=k+}\DecValTok{1}\NormalTok{):(j+=k+}\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{if}\NormalTok{(i==j) j++;}
\NormalTok{            k=}\DecValTok{0}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ min(i,j);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ get\_max\_rep(string \&s)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=s.length();}
    \DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{,j=}\DecValTok{1}\NormalTok{,k=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(i\textless{}n\&\&j\textless{}n\&\&k\textless{}n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ l=(i+k)\%n,r=(j+k)\%n;}
        \ControlFlowTok{if}\NormalTok{(s[l]==s[r]) k++;}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            s[l]\textless{}s[r]?(i+=k+}\DecValTok{1}\NormalTok{):(j+=k+}\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{if}\NormalTok{(i==j) j++;}
\NormalTok{            k=}\DecValTok{0}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ min(i,j);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{manacher}{%
\subsection{manacher}\label{manacher}}

\(d1[i]\) 代表以 \(S[i]\) 为中心的最长奇回文的长度，\(d2[i]\) 代表以
\(S[i]\) \textasciitilde{} \(S[i+1]\) 中间的空位开始的最长偶回文的长度。

注意 \(d1\) \(d2\) 均代表的是回文串的长度，而非回文串的\emph{半径}。

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ manacher}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ p[MAXN*}\DecValTok{2}\NormalTok{];}
\NormalTok{    string a;}
    \DataTypeTok{void}\NormalTok{ run(string \&s,}\DataTypeTok{int}\NormalTok{ d1[],}\DataTypeTok{int}\NormalTok{ d2[])}
\NormalTok{    \{}
\NormalTok{        a.clear(),a.pb(}\CharTok{\textquotesingle{}$\textquotesingle{}}\NormalTok{),a.pb(}\CharTok{\textquotesingle{}\#\textquotesingle{}}\NormalTok{);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}s.size();i++)}
\NormalTok{            a.pb(s[i]),a.pb(}\CharTok{\textquotesingle{}\#\textquotesingle{}}\NormalTok{);}
\NormalTok{        a.pb(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}0}\CharTok{\textquotesingle{}}\NormalTok{);}
        \DataTypeTok{int}\NormalTok{ n=a.size(){-}}\DecValTok{1}\NormalTok{,id=}\DecValTok{0}\NormalTok{,mx=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(mx\textgreater{}i) p[i]=min(p[}\DecValTok{2}\NormalTok{*id{-}i],mx{-}i{-}}\DecValTok{1}\NormalTok{);}
            \ControlFlowTok{else}\NormalTok{ p[i]=}\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{while}\NormalTok{(a[i+p[i]]==a[i{-}p[i]]) p[i]++;}
            \ControlFlowTok{if}\NormalTok{(i+p[i]{-}}\DecValTok{1}\NormalTok{\textgreater{}mx) mx=i+p[i]{-}}\DecValTok{1}\NormalTok{,id=i;}
\NormalTok{        \}}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}s.size();i++)   d1[i]=p[(i+}\DecValTok{1}\NormalTok{)*}\DecValTok{2}\NormalTok{]{-}}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}s.size(){-}}\DecValTok{1}\NormalTok{;i++) d2[i]=p[(i+}\DecValTok{1}\NormalTok{)*}\DecValTok{2}\NormalTok{+}\DecValTok{1}\NormalTok{]{-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{acux81eaux52a8ux673a}{%
\subsection{AC自动机}\label{acux81eaux52a8ux673a}}

一个状态的 \(fail\) 连向的是这个状态在自动机(\(Trie\))上的最长真后缀。

\hypertarget{ux6c42ux4ee5ux6587ux672cux4e32ux6bcfux4e2aux4f4dux7f6eux5339ux914dux7684ux6a21ux5f0fux4e32ux4e2aux6570}{%
\subsubsection{1.求以文本串每个位置匹配的模式串个数}\label{ux6c42ux4ee5ux6587ux672cux4e32ux6bcfux4e2aux4f4dux7f6eux5339ux914dux7684ux6a21ux5f0fux4e32ux4e2aux6570}}

定义 \(f(i)\) 为文本串以 \(S[i]\)
为最后一个字符所能匹配到的模式串的个数，以下是求 \(f(i)\) 的模板。

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ ACM}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{int}\NormalTok{ SZ=}\DecValTok{26}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ root,cnt;}
    \DataTypeTok{int}\NormalTok{ nx[N][SZ],fail[N],s[N];}
    \CommentTok{//s表示该节点能匹配多少个模式串}

    \DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{    \{}
\NormalTok{        cnt++;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}SZ;i++)}
\NormalTok{            nx[cnt][i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fail[cnt]=s[cnt]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ cnt;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,root=newnode();\}}
    \DataTypeTok{void}\NormalTok{ insert(string \&s)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=s.length(),now=root;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!nx[now][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{])}
\NormalTok{                nx[now][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{]=newnode();}
\NormalTok{            now=nx[now][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{];}
\NormalTok{        \}}
\NormalTok{        s[now]++;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build()}
\NormalTok{    \{}
\NormalTok{        queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{        fail[root]=root;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}SZ;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!nx[root][i]) nx[root][i]=root;}
            \ControlFlowTok{else}\NormalTok{ fail[nx[root][i]]=root,q.push(nx[root][i]);}
\NormalTok{        \}}
        \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ now=q.front(); q.pop();}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}SZ;i++)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(nx[now][i])}
\NormalTok{                \{}
\NormalTok{                    fail[nx[now][i]]=nx[fail[now]][i];}
\NormalTok{                    s[nx[now][i]]+=s[fail[nx[now][i]]];}
                    \CommentTok{//继承fail的s(结尾)}
\NormalTok{                    q.push(nx[now][i]);}
\NormalTok{                \}}
                \ControlFlowTok{else}\NormalTok{ nx[now][i]=nx[fail[now]][i];}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \CommentTok{//f[i]代表以i为结尾能匹配的模式串的个数}
    \DataTypeTok{void}\NormalTok{ match(string \&s,LL f[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ now=root,n=s.length(),t;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
\NormalTok{            now=nx[now][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{];}
\NormalTok{            f[i]=s[t];}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6c42ux6bcfux4e2aux6a21ux5f0fux4e32ux7684ux51faux73b0ux6b21ux6570}{%
\subsubsection{2.求每个模式串的出现次数}\label{ux6c42ux6bcfux4e2aux6a21ux5f0fux4e32ux7684ux51faux73b0ux6b21ux6570}}

在自动机上记录每个状态能被文本串到达的次数，匹配完后让每个节点和他的
\(fail\) 节点连边建成 \(fail\)
树，统计作为模式串结尾的节点的子树中有多少次匹配。

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ K=}\DecValTok{26}\NormalTok{;}
\KeywordTok{namespace}\NormalTok{ ACM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt;}
    \DataTypeTok{int}\NormalTok{ nx[N][K],fail[N],add[N];}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} id[N];}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)}
\NormalTok{    \{}
\NormalTok{        x=++cnt;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}K;i++)}
\NormalTok{            nx[cnt][i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fail[cnt]=add[cnt]=}\DecValTok{0}\NormalTok{,id[cnt].clear();}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,newnode(root);\}}
    \DataTypeTok{void}\NormalTok{ insert(string \&s,}\DataTypeTok{int}\NormalTok{ index)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=s.length(),now=root;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ c=s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(!nx[now][c])}
\NormalTok{                newnode(nx[now][c]);}
\NormalTok{            now=nx[now][c];}
\NormalTok{        \}}
\NormalTok{        id[now].pb(index);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build()}
\NormalTok{    \{}
\NormalTok{        queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{        fail[root]=root;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}K;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!nx[root][i]) nx[root][i]=root;}
            \ControlFlowTok{else}\NormalTok{ fail[nx[root][i]]=root,q.push(nx[root][i]);}
\NormalTok{        \}}
        \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ now=q.front();q.pop();}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}K;i++)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(nx[now][i])}
\NormalTok{                    fail[nx[now][i]]=nx[fail[now]][i],q.push(nx[now][i]);}
                \ControlFlowTok{else}\NormalTok{ nx[now][i]=nx[fail[now]][i];}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ match(string \&s)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ now=root,n=s.length(),t;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
\NormalTok{            now=nx[now][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{];}
\NormalTok{            add[now]++;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{int}\NormalTok{ x=root,}\DataTypeTok{char}\NormalTok{ c=}\CharTok{\textquotesingle{}\#\textquotesingle{}}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        cout \textless{}\textless{} dbgs2(x,c) \textless{}\textless{} endl;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}K;i++)}
            \ControlFlowTok{if}\NormalTok{(nx[x][i])}
\NormalTok{                debug(nx[x][i],i+}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\};}

\DataTypeTok{int}\NormalTok{ n;}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e=\{edge()\};}
\DataTypeTok{int}\NormalTok{ pre[N];}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{e.pb(\{u,v,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ ans[])}
\NormalTok{\{}
\NormalTok{    go(u) dfs(v,ans),ACM::add[u]+=ACM::add[v];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i:ACM::id[u])}
\NormalTok{        ans[i]+=ACM::add[u];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ ans[])}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{;i\textless{}=ACM::cnt;i++)}
\NormalTok{        addedge(ACM::fail[i],i);}
\NormalTok{    dfs(ACM::root,ans);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ ans[MAXN];}
\NormalTok{string s;}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    cin \textgreater{}\textgreater{} n,ACM::init();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) cin \textgreater{}\textgreater{} s,ACM::insert(s,i);}
\NormalTok{    cin\textgreater{}\textgreater{}s,ACM::build(),ACM::match(s),solve(ans);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)cout \textless{}\textless{} ans[i] \textless{}\textless{} endl;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux540eux7f00ux6570ux7ec4}{%
\subsection{后缀数组}\label{ux540eux7f00ux6570ux7ec4}}

下标从 \(1\) 开始

用数字当字符时注意不要用 \(0\)

\hypertarget{ux6570ux7ec4ux542bux4e49}{%
\subsubsection{数组含义}\label{ux6570ux7ec4ux542bux4e49}}

\(sa[i]\) 排名为 \(i\) 的后缀的起始位置.

\(rk[i]\) 以\(i\)为起点的后缀的排名。

\(height[i]\) 排名为 \(i\) 的后缀和排名为 \(i-1\) 的后缀的 \(LCP\)。

\hypertarget{ux6027ux8d28}{%
\subsubsection{性质}\label{ux6027ux8d28}}

\[LCP(sa_{i},sa_{j})=min\{height_{i+1},...,height_{j}\}\]
即排名为i的后缀和排名为j的后缀的LCP为 \(height_{i+1},...,height_{j}\)
中的最小值

\hypertarget{ux6a21ux677f-6}{%
\subsubsection{模板}\label{ux6a21ux677f-6}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ SA}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n,m;}
    \DataTypeTok{int}\NormalTok{ sa[MAXN],c[MAXN],rk[MAXN],y[MAXN],t[MAXN];}
    \KeywordTok{inline} \DataTypeTok{bool}\NormalTok{ cmp(}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ j,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{    \{}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ a,b;}
\NormalTok{        a = i+k\textgreater{}n ? {-}}\DecValTok{1}\NormalTok{ : rk[i+k];}
\NormalTok{        b = j+k\textgreater{}n ? {-}}\DecValTok{1}\NormalTok{ : rk[j+k];}
        \ControlFlowTok{return}\NormalTok{ (a==b)\&\&(rk[i]==rk[j]);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
\NormalTok{        n=strlen(s+}\DecValTok{1}\NormalTok{),m=}\DecValTok{256}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) rk[i]=s[i];}

        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}=m;i++) c[i]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) c[rk[i]]++;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=m;i++) c[i]+=c[i{-}}\DecValTok{1}\NormalTok{];}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n;i;i{-}{-}) sa[c[rk[i]]{-}{-}]=i;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=}\DecValTok{1}\NormalTok{,p;k\textless{}n;k=k\textless{}\textless{}}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            p=}\DecValTok{0}\NormalTok{;}
            \CommentTok{//y[]用来暂存第二关键字排序的结果}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n;i\textgreater{}n{-}k;i{-}{-}) y[++p]=i;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) }\ControlFlowTok{if}\NormalTok{(sa[i]\textgreater{}k) y[++p]=sa[i]{-}k;}

            \CommentTok{//按第一关键字排序}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}=m;i++) c[i]=}\DecValTok{0}\NormalTok{;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) c[rk[i]]++;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=m;i++) c[i]+=c[i{-}}\DecValTok{1}\NormalTok{];}

            \CommentTok{//按y的逆序提取计数排序的结果}
            \CommentTok{//以保证第一关键字相同时第二关键字较小的在后面}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) t[i]=rk[y[i]];}
          
          
          
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n;i;i{-}{-}) sa[c[t[i]]{-}{-}]=y[i];}

            \CommentTok{//构建以本次排序为基准的新rk[]数组}
\NormalTok{            p=y[sa[}\DecValTok{1}\NormalTok{]]=}\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{                y[sa[i]]=cmp(sa[i],sa[i{-}}\DecValTok{1}\NormalTok{],k) ? p : ++p;}
\NormalTok{            swap(rk,y),m=p;}

            \ControlFlowTok{if}\NormalTok{(p==n) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ height[MAXN];}
    \CommentTok{//height[i]代表后缀rank[i]和后缀rank[i{-}1]的LCP lcp(sa[i],sa[i{-}1])}
    \DataTypeTok{void}\NormalTok{ get\_height(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ k=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(k) k{-}{-};}
            \DataTypeTok{int}\NormalTok{ j=sa[rk[i]{-}}\DecValTok{1}\NormalTok{];}
            \ControlFlowTok{while}\NormalTok{(s[i+k]==s[j+k]) k++;}
\NormalTok{            height[rk[i]]=k;}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ debug(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{        \{}
\NormalTok{            cout \textless{}\textless{} dbgs4(i,sa[i],rk[i],h[i]) \textless{}\textless{} endl;}
\NormalTok{            fp(j,sa[i],n)putchar(s[j]);putchar(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7edfux8ba1ux5b57ux7b26ux4e32ux4e2dux76f8ux540cux7684ux5b50ux4e32ux7684ux5bf9ux6570-ux6216-ux5b57ux7b26ux4e32ux4e2dux6bcfux4e00ux5bf9ux540eux7f00ux7684lcpux4e4bux548c}{%
\subsubsection{统计字符串中相同的子串的对数 或
字符串中每一对后缀的LCP之和}\label{ux7edfux8ba1ux5b57ux7b26ux4e32ux4e2dux76f8ux540cux7684ux5b50ux4e32ux7684ux5bf9ux6570-ux6216-ux5b57ux7b26ux4e32ux4e2dux6bcfux4e00ux5bf9ux540eux7f00ux7684lcpux4e4bux548c}}

若用 \(T_{i}\) 表示字符串从i开始的后缀，相同子串对数等价于求

\[\sum_{i=1}^{n}\sum_{j=1}^{i-1}lcp(T_{i},T_{j})\]

即字符串中任意两个后缀的 \(lcp\) 之和

考虑后缀 \(T_{sa_{i}}\) 和排名小于它的后缀的 \(lcp\) 之和 \(S_{sa_{i}}\)

\[S_{sa_{i}}=\sum_{j=1}^{i}min\{height_{j}...height_{i}\}\]

用单调栈维护以下每个 \(height_{j}\) 作为最小值的范围和它的贡献即可
\(O(n)\) 来求 \(\sum_{i=1}^{n}S_{sa_{i}}\)

\hypertarget{ux6a21ux677f-7}{%
\paragraph{模板}\label{ux6a21ux677f-7}}

配合上面的SA板子食用

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ myStack}
\NormalTok{\{}
\NormalTok{    stack\textless{}lpr\textgreater{} s1;}
\NormalTok{    stack\textless{}LL \textgreater{} s2;}
\NormalTok{    LL sum;}
    \DataTypeTok{void}\NormalTok{ push(lpr p)}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(p\textless{}s1.top())}
\NormalTok{        \{}
\NormalTok{            sum{-}=s2.top();}
\NormalTok{            s1.pop(),s2.pop();}
\NormalTok{        \}}
\NormalTok{        s2.push(p.fi*(p.se{-}s1.top().se));}
\NormalTok{        s1.push(p);}
\NormalTok{        sum+=s2.top();}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(!s1.empty())s1.pop();}
        \ControlFlowTok{while}\NormalTok{(!s2.empty())s2.pop();}
\NormalTok{        s1.push(\{}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\}),s2.push(}\DecValTok{0}\NormalTok{),sum=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}stk;}

\NormalTok{LL solve()}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    stk.init();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) stk.push(\{SA::height[i],i\}),ans+=stk.sum;}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5b57ux7b26ux4e32ux672cux8d28ux4e0dux540cux7684ux5b50ux4e32ux4e2aux6570}{%
\subsubsection{字符串本质不同的子串个数}\label{ux5b57ux7b26ux4e32ux672cux8d28ux4e0dux540cux7684ux5b50ux4e32ux4e2aux6570}}

\[ans=\sum_{i=1}^{n}n-sa[i]+1-height[i]\]

\hypertarget{ux540eux7f00ux81eaux52a8ux673a}{%
\subsection{后缀自动机}\label{ux540eux7f00ux81eaux52a8ux673a}}

\hypertarget{ux8d44ux6599-5}{%
\subsubsection{资料}\label{ux8d44ux6599-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{https://wenku.baidu.com/view/fa02d3fff111f18582d05a81?ivk_sa=1023194j}{陈立杰冬令营SAM讲稿}
\item
  \href{https://ouuan.github.io/\%E5\%90\%8E\%E7\%BC\%80\%E8\%87\%AA\%E5\%8A\%A8\%E6\%9C\%BA\%EF\%BC\%88SAM\%EF\%BC\%89\%E5\%AD\%A6\%E4\%B9\%A0\%E7\%AC\%94\%E8\%AE\%B0/}{后缀自动机（SAM）学习笔记
  ouuan}
\item
  \href{https://oi-wiki.org/string/sam/}{OI wiki SAM}
\item
  \href{https://oi.men.ci/suffix-automaton-notes/}{后缀自动机学习笔记
  Menci}
\end{enumerate}

\hypertarget{ux7b14ux8bb0}{%
\subsubsection{笔记}\label{ux7b14ux8bb0}}

后缀自动机上每个点代表的是一些 \(endpos\)
相同且长度连续的一些字符串，设状态 \(u\) 表示的字符串的长度范围为
\([min(u),max(v)]\)

每个结点的 \(par\) 是所有满足 \(endpos[u] \in endpos[v]\) 的 \(v\) 中且
\(endpos[v]\) 大小最小的 \(v\)。

有关 \(par\) 的一些性质：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(min(u)=max(par[u])+1\)
\item
  \(par[u]\) 所表示的字符串都是 \(u\) 的后缀。
\end{enumerate}

自动机接受的字符串为 \(S\) 的所有子串。

表示字符串前缀 \(Pre\) 的状态 \(u\) 的 \(max(u) = |Pre|\)，从 \(u\) 跳
\(par\) 的话可以遍历 \(Pre\) 的所有后缀。

\href{https://codeforces.com/contest/235/problem/C}{CF200C}

\hypertarget{ux6a21ux677f-8}{%
\subsubsection{模板}\label{ux6a21ux677f-8}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ SAM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt,last;}
    \DataTypeTok{int}\NormalTok{ nx[N][}\DecValTok{26}\NormalTok{],par[N],len[N],sum[N];}
    \DataTypeTok{int}\NormalTok{ buc[N],seq[N];}
    \DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{    \{}
\NormalTok{        cnt++;}
\NormalTok{        mst(nx[cnt],}\DecValTok{0}\NormalTok{);}
\NormalTok{        par[cnt]=len[cnt]=sum[cnt]=}\DecValTok{0}\NormalTok{;        }
        \ControlFlowTok{return}\NormalTok{ cnt;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,last=root=newnode();\}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ c)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ np=newnode(),p=last;}
\NormalTok{        len[np]=len[last]+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(p\&\&!nx[p][c])nx[p][c]=np,p=par[p];}
        \ControlFlowTok{if}\NormalTok{(p)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ q=nx[p][c];}
            \ControlFlowTok{if}\NormalTok{(len[q]==len[p]+}\DecValTok{1}\NormalTok{)par[np]=q;}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ nq=newnode();}
\NormalTok{                len[nq]=len[p]+}\DecValTok{1}\NormalTok{;}
\NormalTok{                par[nq]=par[q];}
\NormalTok{                memcpy(nx[nq],nx[q],}\KeywordTok{sizeof}\NormalTok{(nx[q]));}
                \ControlFlowTok{while}\NormalTok{(p\&\&nx[p][c]==q)nx[p][c]=nq,p=par[p];}
\NormalTok{                par[q]=par[np]=nq;}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ par[np]=root;}
\NormalTok{        last=np;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ sort() }\CommentTok{//seq 倒序为 叶子 {-}\textgreater{} 根}
\NormalTok{    \{}
\NormalTok{        mst(buc,}\DecValTok{0}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt)buc[len[i]]++;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,N{-}}\DecValTok{1}\NormalTok{)buc[i]+=buc[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt)seq[buc[len[i]]{-}{-}]=i;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)insert(s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{);}
        \DataTypeTok{int}\NormalTok{ cur=root;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur=nx[cur][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{],sum[cur]++;}
\NormalTok{        sort();}
\NormalTok{        fd(i,cnt,}\DecValTok{1}\NormalTok{)cur=seq[i],sum[par[cur]]+=sum[cur];}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6280ux5de7-ux5e94ux7528}{%
\subsubsection{技巧 \& 应用}\label{ux6280ux5de7-ux5e94ux7528}}

\hypertarget{ux6c42-endpos-ux96c6ux5408ux7684ux5927ux5c0fux6700ux5927ux503cux6700ux5c0fux503c}{%
\paragraph{\texorpdfstring{1.求 \(endpos\)
集合的大小/最大值/最小值}{1.求 endpos 集合的大小/最大值/最小值}}\label{ux6c42-endpos-ux96c6ux5408ux7684ux5927ux5c0fux6700ux5927ux503cux6700ux5c0fux503c}}

考虑 \(par\) 树的所有节点，\(endpos\) 中 含有 \(i\)
的深度最大的节点一定是表示前缀 \(Pre_{i}\) 的状态，标记这个节点后用
dfs/拓扑/基排 逆推即可。

如果要求每个点 \(endpos\) 的具体值可能需要 线段树合并/平衡树启发式合并。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ seq[MAXN*}\DecValTok{2}\NormalTok{],buc[N];}
\DataTypeTok{void}\NormalTok{ sort\_by\_len()}
\NormalTok{\{}
\NormalTok{    mst(buc,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt) buc[len[i]]++;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,N{-}}\DecValTok{1}\NormalTok{) buc[i]+=buc[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt) seq[buc[len[i]]{-}{-}]=i;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    fd(i,cnt,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur=seq[i];}
\NormalTok{        f[par[cur]]+=f[cur];}
        \CommentTok{//f[par[cur]]=min(f[par[cur]],f[cur]);}
        \CommentTok{//f[par[cur]]=max(f[par[cur]],f[cur]);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{logn-ux67e5ux627eux67d0ux4e2aux5b50ux4e32ux5728-sam-ux4e0aux5bf9ux5e94ux7684ux72b6ux6001}{%
\paragraph{\texorpdfstring{2. \(logn\) 查找某个子串在 \(SAM\)
上对应的状态}{2. logn 查找某个子串在 SAM 上对应的状态}}\label{logn-ux67e5ux627eux67d0ux4e2aux5b50ux4e32ux5728-sam-ux4e0aux5bf9ux5e94ux7684ux72b6ux6001}}

考虑倍增，预处理出每个节点在 \(par\) 树上的\(2^j\) 祖先，从表示
\(S[1...r]\) 的节点往上跳找到深度最小且满足 \(max(u)>=(r-l+1)\)的 \(u\)
即可。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=cnt;i++) nx[i][}\DecValTok{0}\NormalTok{]=par[i];}
\NormalTok{    fp(k,}\DecValTok{1}\NormalTok{,}\DecValTok{20}\NormalTok{)fp(i,}\DecValTok{1}\NormalTok{,cnt)nx[i][k]=nx[nx[i][k{-}}\DecValTok{1}\NormalTok{]][k{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{\}}
\NormalTok{LL count(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ cur=suf[r];}
\NormalTok{    fd(k,}\DecValTok{20}\NormalTok{,}\DecValTok{0}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{(nx[cur][k]\&\&len[nx[cur][k]]\textgreater{}=r{-}l+}\DecValTok{1}\NormalTok{)}
\NormalTok{            cur=nx[cur][k];}
    \ControlFlowTok{return}\NormalTok{ sum[cur];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e24ux4e2aux4e32ux7684lcs}{%
\paragraph{3. 两个串的LCS}\label{ux4e24ux4e2aux4e32ux7684lcs}}

对 \(S\) 串建立 \(SAM\)，拿 \(T\) 串到 \(SAM\) 上``运行''

具体来讲就是考虑 \(T\) 的每个前缀 \(pre_{i}\) 有多长的后缀是 \(S\)
的一个子串，从 \(pre_{i}\) 转移到 \(pre_{i+1}\) 时看下当前状态是否存在到
\(T[i+1]\) 的转移边，若不存在就不断跳 \(par\) (删掉前面的一部分)
直到找到存在转移边的状态，同时维护在每个状态下的匹配长度，最后取个
\(max\) 就是答案。

匹配过程十分类似于 \(kmp\) 和 \(AC\)自动机 啊，，，

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ L=}\DecValTok{0}\NormalTok{,ans=}\DecValTok{0}\NormalTok{,cur=root,n=strlen(s+}\DecValTok{1}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ c=s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(cur!=root\&\&!nx[cur][c])}
\NormalTok{            cur=par[cur],L=len[cur];}
        \ControlFlowTok{if}\NormalTok{(nx[cur][c]) cur=nx[cur][c],L++;}
\NormalTok{        ans=max(ans,L);}
\NormalTok{    \}}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux672cux8d28ux4e0dux540cux7684ux5b50ux4e32ux4e2aux6570}{%
\paragraph{4.本质不同的子串个数}\label{ux672cux8d28ux4e0dux540cux7684ux5b50ux4e32ux4e2aux6570}}

相同的子串一定被同一个状态所表示，所以对后缀自动机上每个状态所表示的子串长度求和即是答案。

\[ans = \sum_{i=1}^{cnt}len[i]-len[par[i]]\]

\hypertarget{ux6700ux5c0fux8868ux793aux6cd5}{%
\paragraph{5.最小表示法}\label{ux6700ux5c0fux8868ux793aux6cd5}}

先将字符串 \(S\) 复制一倍后得到 \(T\)，可以发现 \(T\) 的长度为 \(n\)
的子串中涵盖了 \(S\) 循环移位所能得到的所有可能，所以问题转化为求 \(T\)
的长度为 \(n\) 的子串中字典序最小的一个。

对 \(T\) 建立 \(SAM\) 后从 \(root\)
开始贪心走转移边中字符最小的那条即可。

\hypertarget{ux5b57ux5178ux5e8fkux5927ux5b50ux4e32}{%
\paragraph{6.字典序k大子串}\label{ux5b57ux5178ux5e8fkux5927ux5b50ux4e32}}

统计出在每个状态通过转移边能到达的状态的数量 \(f[u]\)
，从根节点开始从小到大枚举转移边 \(v\) 若 \(f[v]>=k\) 则从 \(u\) 转移到
\(v\)，否则将 \(k\) 减去 \(f[v]\) 后继续尝试字符更大的转移边。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ print(}\DataTypeTok{int}\NormalTok{ cur,}\DataTypeTok{int}\NormalTok{ k,}\DataTypeTok{int}\NormalTok{ t,LL f[])}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!k) }\ControlFlowTok{return}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ trans:nx[cur])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(f[trans.se]\textgreater{}=k)}
\NormalTok{        \{}
\NormalTok{            putchar(trans.fi),print(trans.se,k{-}(t?sum[trans.se]:}\DecValTok{1}\NormalTok{),t,f);}
            \ControlFlowTok{break}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ k{-}=f[trans.se];}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ k,}\DataTypeTok{int}\NormalTok{ t)}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt) buc[len[i]]++;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,N{-}}\DecValTok{1}\NormalTok{) buc[i]+=buc[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt) seq[buc[len[i]]{-}{-}]=i;}
\NormalTok{    fd(i,cnt,}\DecValTok{1}\NormalTok{) sum[par[seq[i]]]+=sum[seq[i]];}

\NormalTok{    fd(i,cnt,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur=seq[i];}
\NormalTok{        f[}\DecValTok{0}\NormalTok{][cur]=}\DecValTok{1}\NormalTok{,f[}\DecValTok{1}\NormalTok{][cur]=sum[cur];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ trans:nx[cur])}
\NormalTok{        \{}
\NormalTok{            f[}\DecValTok{0}\NormalTok{][cur]+=f[}\DecValTok{0}\NormalTok{][trans.se];}
\NormalTok{            f[}\DecValTok{1}\NormalTok{][cur]+=f[}\DecValTok{1}\NormalTok{][trans.se];}
\NormalTok{        \}}
\NormalTok{    \}}

    \ControlFlowTok{if}\NormalTok{(f[t][root]{-}(t==}\DecValTok{1}\NormalTok{?sum[root]:}\DecValTok{1}\NormalTok{)\textless{}k) printf(}\StringTok{"{-}1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{else}\NormalTok{ print(root,k,t,f[t]),putchar(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux591aux4e2aux4e32ux7684lcs}{%
\paragraph{7.多个串的LCS}\label{ux591aux4e2aux4e32ux7684lcs}}

对其中一个串建立 \(SAM\) 把剩下所有串放到 \(SAM\)
上运行，类似于求两个串的 \(LCS\)
的过程，运行每一个串的时候记录它在当前状态上的最大匹配长度，注意不同串在同一个状态上的匹配长度要取
\(min\),最后统计答案即可。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ run(string \&s,}\DataTypeTok{int}\NormalTok{ id)}
\NormalTok{\{}
\NormalTok{    mst(f,}\DecValTok{0}\NormalTok{);}
    \DataTypeTok{int}\NormalTok{ cur=root,L=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,s.size(){-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ c=s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(cur!=root\&\&!nx[cur][c])}
\NormalTok{            cur=par[cur],L=len[cur];}
        \ControlFlowTok{if}\NormalTok{(nx[cur][c]) cur=nx[cur][c],L++;}
\NormalTok{        f[cur]=max(f[cur],L);}
\NormalTok{    \}}
\NormalTok{    fd(i,cnt,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur=seq[i];}
        \ControlFlowTok{if}\NormalTok{(f[cur]) f[par[cur]]=len[par[cur]];}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(id==}\DecValTok{2}\NormalTok{) fp(i,}\DecValTok{1}\NormalTok{,cnt) ans[i]=f[i];}
    \ControlFlowTok{else}\NormalTok{ fp(i,}\DecValTok{1}\NormalTok{,cnt) ans[i]=min(ans[i],f[i]);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ L=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt) L=max(ans[i],L);}
\NormalTok{    cout \textless{}\textless{} L \textless{}\textless{} endl;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux8be2ux95eeux67d0ux4e00ux5b50ux4e32ux7684ux540eux7f00ux81eaux52a8ux673a}{%
\paragraph{8.询问某一子串的后缀自动机}\label{ux8be2ux95eeux67d0ux4e00ux5b50ux4e32ux7684ux540eux7f00ux81eaux52a8ux673a}}

考虑用线段树合并维护 \(right\) 集合，询问一个节点是否在子串 \([L,R]\)
构成的后缀自动机上可以通过查询节点的 \(right\) 集合是否在区间
\([L+len,R]\) 中有值，其中 \(len\) 为当前匹配长度。

\href{https://www.luogu.com.cn/problem/P4770}{{[}NOI2018{]}你的名字}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ seg}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ cnt,s[N],ls[N],rs[N];}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x||nl\textgreater{}nr||nr\textless{}l||nl\textgreater{}r)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}\ControlFlowTok{return}\NormalTok{ s[x];}
        \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid)}\ControlFlowTok{return}\NormalTok{ query(ls[x],l,mid,nl,nr);}
        \ControlFlowTok{if}\NormalTok{(nl\textgreater{} mid)}\ControlFlowTok{return}\NormalTok{ query(rs[x],mid+}\DecValTok{1}\NormalTok{,r,nl,nr);}
        \ControlFlowTok{return}\NormalTok{ query(ls[x],l,mid,nl,mid)+query(rs[x],mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ pos)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x)x=++cnt; s[x]++; }\ControlFlowTok{if}\NormalTok{(l==r)}\ControlFlowTok{return}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(pos\textless{}=mid)insert(ls[x],l,mid,pos);}
        \ControlFlowTok{else}\NormalTok{ insert(rs[x],mid+}\DecValTok{1}\NormalTok{,r,pos);}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ merge(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!x||!y)}\ControlFlowTok{return}\NormalTok{ x+y; }\DataTypeTok{int}\NormalTok{ cur=++cnt;}
        \ControlFlowTok{if}\NormalTok{(l==r)s[cur]=s[x]+s[y];}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            ls[cur]=merge(ls[x],ls[y],l,mid);}
\NormalTok{            rs[cur]=merge(rs[x],rs[y],mid+}\DecValTok{1}\NormalTok{,r);}
\NormalTok{            s[cur]=s[ls[cur]]+s[rs[cur]];}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ cur;}
\NormalTok{    \}}
\NormalTok{\}}
\KeywordTok{template}\NormalTok{\textless{}}\DataTypeTok{int}\NormalTok{ N\textgreater{}}
\KeywordTok{struct}\NormalTok{ SAM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt,last;}
    \DataTypeTok{int}\NormalTok{ nx[N][}\DecValTok{26}\NormalTok{],par[N],len[N];}
    \DataTypeTok{int}\NormalTok{ rt[N],mx[N],buc[N],seq[N];}
    \DataTypeTok{int}\NormalTok{ newnode()}
\NormalTok{    \{}
\NormalTok{        cnt++;}
\NormalTok{        mst(nx[cnt],}\DecValTok{0}\NormalTok{);}
\NormalTok{        par[cnt]=len[cnt]=rt[cnt]=mx[cnt]=}\DecValTok{0}\NormalTok{;    }
        \ControlFlowTok{return}\NormalTok{ cnt;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,last=root=newnode();\}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ c)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ np=newnode(),p=last;}
\NormalTok{        len[np]=len[last]+}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(p\&\&!nx[p][c])nx[p][c]=np,p=par[p];}
        \ControlFlowTok{if}\NormalTok{(p)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ q=nx[p][c];}
            \ControlFlowTok{if}\NormalTok{(len[q]==len[p]+}\DecValTok{1}\NormalTok{)par[np]=q;}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ nq=newnode();}
\NormalTok{                len[nq]=len[p]+}\DecValTok{1}\NormalTok{;}
\NormalTok{                par[nq]=par[q];}
\NormalTok{                memcpy(nx[nq],nx[q],}\KeywordTok{sizeof}\NormalTok{(nx[q]));}
                \ControlFlowTok{while}\NormalTok{(p\&\&nx[p][c]==q)nx[p][c]=nq,p=par[p];}
\NormalTok{                par[q]=par[np]=nq;}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ par[np]=root;}
\NormalTok{        last=np;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ sort()}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ mx=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt)buc[len[i]]++,mx=max(mx,len[i]);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,mx)buc[i]+=buc[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt)seq[buc[len[i]]{-}{-}]=i;}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,mx)buc[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
\NormalTok{        init();}
        \DataTypeTok{int}\NormalTok{ n=strlen(s+}\DecValTok{1}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)insert(s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build\_mx(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=strlen(s+}\DecValTok{1}\NormalTok{),cur=root;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur=nx[cur][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{],mx[cur]=i;}
\NormalTok{        sort();}
\NormalTok{        fd(i,cnt,}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ x=seq[i];}
            \ControlFlowTok{if}\NormalTok{(par[x])mx[par[x]]=max(mx[par[x]],mx[x]);}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build\_right(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=strlen(s+}\DecValTok{1}\NormalTok{),cur=root;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur=nx[cur][s[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{],seg::insert(rt[cur],}\DecValTok{1}\NormalTok{,n,i);}
\NormalTok{        sort();}
\NormalTok{        fd(i,cnt,}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ x=seq[i];}
            \ControlFlowTok{if}\NormalTok{(par[x])rt[par[x]]=seg::merge(rt[par[x]],rt[x],}\DecValTok{1}\NormalTok{,n);}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ move(}\DataTypeTok{int}\NormalTok{ \&l,}\DataTypeTok{int}\NormalTok{ \&cur,}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ L,}\DataTypeTok{int}\NormalTok{ R,}\DataTypeTok{int}\NormalTok{ c)}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(nx[cur][c]\&\&seg::query(rt[nx[cur][c]],}\DecValTok{1}\NormalTok{,n,L+l,R)\textgreater{}}\DecValTok{0}\NormalTok{)}
\NormalTok{                \{cur=nx[cur][c],l++;}\ControlFlowTok{return}\NormalTok{;\}}
            \ControlFlowTok{if}\NormalTok{(!l)}\ControlFlowTok{return}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{({-}{-}l==len[par[cur]])cur=par[cur];}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    LL calc(}\DataTypeTok{int}\NormalTok{ p[],LL ans=}\DecValTok{0}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{2}\NormalTok{,cnt)}
\NormalTok{            ans+=max(}\DecValTok{0}\NormalTok{,len[i]{-}max(len[par[i]],p[mx[i]]));}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ n,m,L,R;}
\DataTypeTok{char}\NormalTok{ s[MAXN],t[MAXN];}
\DataTypeTok{int}\NormalTok{  p[MAXN];}
\NormalTok{SAM\textless{}}\DecValTok{1000005}\NormalTok{\textgreater{} S;}
\NormalTok{SAM\textless{}}\DecValTok{2000005}\NormalTok{\textgreater{} T;}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,s+}\DecValTok{1}\NormalTok{),n=strlen(s+}\DecValTok{1}\NormalTok{),S.build(s),S.build\_right(s);}
\NormalTok{    MC}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,t+}\DecValTok{1}\NormalTok{,\&L,\&R),m=strlen(t+}\DecValTok{1}\NormalTok{),T.build(t),T.build\_mx(t);}
        \DataTypeTok{int}\NormalTok{ cur=S.root,l=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)S.move(l,cur,n,L,R,t[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{),p[i]=l;}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{, T.calc(p));}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5e7fux4e49sam}{%
\subsection{广义SAM}\label{ux5e7fux4e49sam}}

将 \(SAM\) 推广到字典树上的产物，目前不太理解，，，

定义 \(Trie\) 树的一个子串为节点 \(u\) 到它子树中的节点 \(v\)
的路径所形成的字符串，那么广义 \(SAM\) 接受的状态为 \(Tire\)
树上的所有子串。

把 \(endpos\) 视为 \(Trie\) 树上的节点，\(par\) 的定义不变。

\hypertarget{ux6a21ux677f-9}{%
\subsubsection{模板}\label{ux6a21ux677f-9}}

离线构造，需要预先知道 \(Tire\) 树的形态，从根节点开始
\(bfs\)，建立新节点时拿他父亲的状态作为 \(last\) 执行普通 \(SAM\) 的
\(extend\) 即可。

\href{https://www.luogu.org/problem/P3346}{{[}ZJOI2015{]}诸神眷顾的幻想乡}
求多个串本质不同的子串个数

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ K = }\DecValTok{10}\NormalTok{;}

\KeywordTok{namespace}\NormalTok{ SAM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt;}
    \DataTypeTok{int}\NormalTok{ len[MAXN*}\DecValTok{2}\NormalTok{],par[MAXN*}\DecValTok{2}\NormalTok{];}
    \DataTypeTok{int}\NormalTok{ nx[MAXN*}\DecValTok{2}\NormalTok{][K+}\DecValTok{1}\NormalTok{];}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)\{x=++cnt;\}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,newnode(root);\}}
    \DataTypeTok{int}\NormalTok{ extend(}\DataTypeTok{int}\NormalTok{ c,}\DataTypeTok{int}\NormalTok{ last)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur;}
\NormalTok{        newnode(cur);}
\NormalTok{        len[cur]=len[last]+}\DecValTok{1}\NormalTok{;}
        \DataTypeTok{int}\NormalTok{ p=last;}
        \ControlFlowTok{while}\NormalTok{(p\&\&!nx[p][c])}
\NormalTok{            nx[p][c]=cur,p=par[p];}
        \ControlFlowTok{if}\NormalTok{(!p) par[cur]=root;}
        \ControlFlowTok{else}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ q=nx[p][c];}
            \ControlFlowTok{if}\NormalTok{(len[q]==len[p]+}\DecValTok{1}\NormalTok{) par[cur]=q;}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ n;}
\NormalTok{                newnode(n);}
\NormalTok{                len[n]=len[p]+}\DecValTok{1}\NormalTok{;}
\NormalTok{                par[n]=par[q];}
\NormalTok{                memcpy(nx[n],nx[q],}\KeywordTok{sizeof}\NormalTok{(nx[q]));}
                \ControlFlowTok{while}\NormalTok{(p\&\&nx[p][c]==q)}
\NormalTok{                    nx[p][c]=n,p=par[p];}
\NormalTok{                par[q]=par[cur]=n;}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ cur;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt) ans+=len[i]{-}len[par[i]];}
\NormalTok{        io.write(ans);}
\NormalTok{        io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}

\KeywordTok{namespace}\NormalTok{ Trie}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cur,cnt;}
    \DataTypeTok{int}\NormalTok{ nx[MAXN][K+}\DecValTok{1}\NormalTok{],fa[MAXN],last[MAXN];}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)\{x=++cnt;\}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,newnode(root),cur=root;\}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ c)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!nx[cur][c])}
\NormalTok{            newnode(nx[cur][c]),fa[nx[cur][c]]=cur;}
\NormalTok{        cur=nx[cur][c];}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ back()\{cur=fa[cur];\}}
    \DataTypeTok{void}\NormalTok{ build\_sam()}
\NormalTok{    \{}
\NormalTok{        SAM::init();}
\NormalTok{        queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{        q.push(root);}
\NormalTok{        last[root]=SAM::root;}
        \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ cur=q.front(); q.pop();}
\NormalTok{            fp(i,}\DecValTok{0}\NormalTok{,K)}\ControlFlowTok{if}\NormalTok{(nx[cur][i])}
\NormalTok{                last[nx[cur][i]]=SAM::extend(i,last[cur]),}
\NormalTok{                    q.push(nx[cur][i]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e;}
\DataTypeTok{int}\NormalTok{ n,c;}
\DataTypeTok{int}\NormalTok{ pre[MAXN],col[MAXN],in[MAXN];}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{e.pb(\{u,v,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    Trie::insert(col[u]);}
\NormalTok{    go(u) }\ControlFlowTok{if}\NormalTok{(v!=fa) dfs(v,u);}
\NormalTok{    Trie::back();}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(c),e.pb(edge());}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) io.read(col[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{        io.read(u),io.read(v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{        in[u]++,in[v]++;}
\NormalTok{    \}}
\NormalTok{    Trie::init();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) }\ControlFlowTok{if}\NormalTok{(in[i]==}\DecValTok{1}\NormalTok{) dfs(i,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    Trie::build\_sam();}
\NormalTok{    SAM::solve();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ef4ux62a4ux5b57ux7b26ux4e32ux5728ux5206ux7ec4ux4e2dux7684ux51faux73b0ux60c5ux51b5}{%
\subsubsection{维护字符串在分组中的出现情况}\label{ux7ef4ux62a4ux5b57ux7b26ux4e32ux5728ux5206ux7ec4ux4e2dux7684ux51faux73b0ux60c5ux51b5}}

set + 启发式合并 o(nlognlogn)

可以用线段树合并去1log

\href{https://www.luogu.com.cn/problem/SP10570}{多个串的LCS}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ K = }\DecValTok{26}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ n,ans;}
\DataTypeTok{char}\NormalTok{ s[MAXN];}

\KeywordTok{namespace}\NormalTok{ SAM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt;}
    \DataTypeTok{int}\NormalTok{ len[MAXN*}\DecValTok{2}\NormalTok{],par[MAXN*}\DecValTok{2}\NormalTok{],nx[MAXN*}\DecValTok{2}\NormalTok{][K+}\DecValTok{1}\NormalTok{];}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN*}\DecValTok{2}\NormalTok{];}
\NormalTok{    set\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s[MAXN*}\DecValTok{2}\NormalTok{];}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)}
\NormalTok{    \{}
\NormalTok{        x=++cnt;}
\NormalTok{        G[x].clear();}
\NormalTok{        s[x].clear();}
\NormalTok{        len[x]=par[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        mst(nx[x],}\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,newnode(root);\}}
    \DataTypeTok{int}\NormalTok{ extend(}\DataTypeTok{int}\NormalTok{ c,}\DataTypeTok{int}\NormalTok{ last)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur;}
\NormalTok{        newnode(cur);}
\NormalTok{        len[cur]=len[last]+}\DecValTok{1}\NormalTok{;}
        \DataTypeTok{int}\NormalTok{ p=last;}
        \ControlFlowTok{while}\NormalTok{(p\&\&!nx[p][c])}
\NormalTok{            nx[p][c]=cur,p=par[p];}
        \ControlFlowTok{if}\NormalTok{(!p) par[cur]=root;}
        \ControlFlowTok{else}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ q=nx[p][c];}
            \ControlFlowTok{if}\NormalTok{(len[q]==len[p]+}\DecValTok{1}\NormalTok{) par[cur]=q;}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ n;}
\NormalTok{                newnode(n);}
\NormalTok{                len[n]=len[p]+}\DecValTok{1}\NormalTok{;}
\NormalTok{                par[n]=par[q];}
\NormalTok{                memcpy(nx[n],nx[q],}\KeywordTok{sizeof}\NormalTok{(nx[q]));}
                \ControlFlowTok{while}\NormalTok{(p\&\&nx[p][c]==q)}
\NormalTok{                    nx[p][c]=n,p=par[p];}
\NormalTok{                par[q]=par[cur]=n;}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{return}\NormalTok{ cur;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ son=u;}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
\NormalTok{        \{}
\NormalTok{            dfs(v);}
            \ControlFlowTok{if}\NormalTok{(s[v].size()\textgreater{}s[son].size())}
\NormalTok{                son=v;}
\NormalTok{        \}}
\NormalTok{        s[u].swap(s[son]);}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
            \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ id:s[v])}
\NormalTok{                s[u].insert(id);}
        \ControlFlowTok{if}\NormalTok{(s[u].size()==n)}
\NormalTok{            ans=max(ans,len[u]);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt)}
\NormalTok{            G[par[i]].pb(i);}
\NormalTok{        dfs(root);}
\NormalTok{    \}}
\NormalTok{\}}

\KeywordTok{namespace}\NormalTok{ Trie}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ root,cnt;}
    \DataTypeTok{int}\NormalTok{ nx[MAXN][K+}\DecValTok{1}\NormalTok{],fa[MAXN],last[MAXN];}
\NormalTok{    set\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s[MAXN];}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)}
\NormalTok{    \{}
\NormalTok{        x=++cnt;}
\NormalTok{        s[x].clear();}
\NormalTok{        fa[x]=last[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        mst(nx[x],}\DecValTok{0}\NormalTok{);    }
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()\{cnt=}\DecValTok{0}\NormalTok{,newnode(root);\}}
    \DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ id,}\DataTypeTok{char}\NormalTok{ str[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur=root,n=strlen(str+}\DecValTok{1}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{        \{   }
            \DataTypeTok{int}\NormalTok{ c=str[i]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(!nx[cur][c])newnode(nx[cur][c]);}
\NormalTok{            cur=nx[cur][c],s[cur].insert(id);}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ cur)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ id:s[u])}
\NormalTok{            SAM::s[cur].insert(id);}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,K)}\ControlFlowTok{if}\NormalTok{(nx[u][i])}
\NormalTok{            dfs(nx[u][i],SAM::nx[cur][i]);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        SAM::init();}
\NormalTok{        queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{        q.push(root);}
\NormalTok{        last[root]=SAM::root;}
        \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ cur=q.front(); q.pop();}
\NormalTok{            fp(i,}\DecValTok{0}\NormalTok{,K)}\ControlFlowTok{if}\NormalTok{(nx[cur][i])}
\NormalTok{                last[nx[cur][i]]=SAM::extend(i,last[cur]),}
\NormalTok{                    q.push(nx[cur][i]);}
\NormalTok{        \}}
\NormalTok{        dfs(root,SAM::root);}
\NormalTok{        SAM::solve();}
\NormalTok{    \}}
\NormalTok{\};}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    MC}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n),ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        Trie::init();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,s+}\DecValTok{1}\NormalTok{),Trie::insert(i,s);}
\NormalTok{        Trie::solve();}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux56deux6587ux81eaux52a8ux673aux56deux6587ux6811}{%
\subsection{回文自动机(回文树)}\label{ux56deux6587ux81eaux52a8ux673aux56deux6587ux6811}}

\(root1\) 奇根 \(root2\) 偶根

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ K = }\DecValTok{26}\NormalTok{;}

\KeywordTok{namespace}\NormalTok{ PAM}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ cnt,root1,root2,last=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ nx[MAXN*}\DecValTok{2}\NormalTok{][K],len[MAXN*}\DecValTok{2}\NormalTok{],fail[MAXN*}\DecValTok{2}\NormalTok{],sum[MAXN*}\DecValTok{2}\NormalTok{];}
\NormalTok{    string str;}
    \DataTypeTok{void}\NormalTok{ newnode(}\DataTypeTok{int}\NormalTok{ \&x)}
\NormalTok{    \{}
\NormalTok{        x=++cnt;}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{) nx[x][i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        len[x]=fail[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init()}
\NormalTok{    \{}
\NormalTok{        cnt=}\DecValTok{0}\NormalTok{,str.clear(),str.pb(}\CharTok{\textquotesingle{}$\textquotesingle{}}\NormalTok{);}
\NormalTok{        newnode(root1),len[root1]={-}}\DecValTok{1}\NormalTok{;}
\NormalTok{        newnode(root2),len[root2]= }\DecValTok{0}\NormalTok{;}
\NormalTok{        fail[root2]=root1,last=root1;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ extend(}\DataTypeTok{int}\NormalTok{ pos)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ c=str[pos]{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{,p=last,np;}
        \ControlFlowTok{while}\NormalTok{(str[pos{-}len[p]{-}}\DecValTok{1}\NormalTok{]!=str[pos]) p=fail[p];}
        \ControlFlowTok{if}\NormalTok{(nx[p][c]) np=nx[p][c];}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            newnode(np);}
\NormalTok{            nx[p][c]=np;}
\NormalTok{            len[np]=len[p]+}\DecValTok{2}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(p==root1) fail[np]=root2;}
            \ControlFlowTok{else}
\NormalTok{            \{}
\NormalTok{                p=fail[p];}
                \ControlFlowTok{while}\NormalTok{(str[pos{-}len[p]{-}}\DecValTok{1}\NormalTok{]!=str[pos]) p=fail[p];}
\NormalTok{                fail[np]=nx[p][c];}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{        last=np,sum[last]++;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ build(}\DataTypeTok{char}\NormalTok{ s[])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ n=strlen(s+}\DecValTok{1}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) str.pb(s[i]),extend(i);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{    \{}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fd(i,cnt,}\DecValTok{1}\NormalTok{) sum[fail[i]]+=sum[i];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,cnt) ans=max(ans,(LL)len[i]*sum[i]);}
\NormalTok{        io.write(ans),io.push(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ debug()}
\NormalTok{    \{}
\NormalTok{        fp(x,}\DecValTok{1}\NormalTok{,cnt)}
\NormalTok{        \{}
\NormalTok{            cout \textless{}\textless{} dbgs3(x,len[x],fail[x]) \textless{}\textless{} endl;}
\NormalTok{            fp(i,}\DecValTok{0}\NormalTok{,K{-}}\DecValTok{1}\NormalTok{) }\ControlFlowTok{if}\NormalTok{(nx[x][i]) cout \textless{}\textless{} dbgs2(}\DataTypeTok{char}\NormalTok{(i+}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{),nx[x][i]) \textless{}\textless{} endl;}
\NormalTok{        \}}
\NormalTok{        cout \textless{}\textless{} endl;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{shift-and}{%
\subsection{Shift-And}\label{shift-and}}

可以处理一些带限制的子串匹配问题，\(O(n*m/64)\)

\href{http://acm.hdu.edu.cn/showproblem.php?pid=5716}{hdu5716}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,len;}
\DataTypeTok{char}\NormalTok{ s[MAXN],t[}\DecValTok{65}\NormalTok{];}
\NormalTok{bitset\textless{}N\textgreater{} f,b[}\DecValTok{65}\NormalTok{];}
\KeywordTok{inline} \DataTypeTok{int}\NormalTok{ H(}\DataTypeTok{char}\NormalTok{ c)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(c\textgreater{}=}\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{\&\&c\textless{}=}\CharTok{\textquotesingle{}9\textquotesingle{}}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ c{-}}\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{+}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(c\textgreater{}=}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{\&\&c\textless{}=}\CharTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ c{-}}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{+}\DecValTok{11}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(c\textgreater{}=}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{\&\&c\textless{}=}\CharTok{\textquotesingle{}Z\textquotesingle{}}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ c{-}}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{+}\DecValTok{37}\NormalTok{;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(gets(s+}\DecValTok{1}\NormalTok{))}
\NormalTok{    \{}
\NormalTok{        m=strlen(s+}\DecValTok{1}\NormalTok{),scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n),mst(b,}\DecValTok{0}\NormalTok{);}
        \CommentTok{//fp(i,1,62)b[i].reset();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{        \{}
\NormalTok{            scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,\&len,t+}\DecValTok{1}\NormalTok{);}
\NormalTok{            fp(j,}\DecValTok{1}\NormalTok{,len)b[H(t[j])][i]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{        f.reset(); }\DataTypeTok{bool}\NormalTok{ flag=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ k=H(s[i]);}
            \ControlFlowTok{if}\NormalTok{(k)}
\NormalTok{            \{}
\NormalTok{                f[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
\NormalTok{                f\textless{}\textless{}=}\DecValTok{1}\NormalTok{;}
\NormalTok{                f\&=b[k];}
                \ControlFlowTok{if}\NormalTok{(f[n])printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,i{-}n+}\DecValTok{1}\NormalTok{),flag=}\DecValTok{0}\NormalTok{;}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ f.reset();}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(flag)puts(}\StringTok{"NULL"}\NormalTok{); getchar();}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6570ux5b66-ux6570ux8bba}{%
\section{数学 \& 数论}\label{ux6570ux5b66-ux6570ux8bba}}

\hypertarget{ux4e8cux6b21ux5269ux4f59}{%
\subsection{二次剩余}\label{ux4e8cux6b21ux5269ux4f59}}

模意义下开根号

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL n,p,w;}
\KeywordTok{struct}\NormalTok{ num \{LL x, y;\};}
\NormalTok{num mul(num a, num b, LL p)}
\NormalTok{\{}
\NormalTok{    num ans = \{}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{\};}
\NormalTok{    ans.x = ((a.x * b.x \% p + a.y * b.y \% p * w \% p) \% p + p) \% p;}
\NormalTok{    ans.y = ((a.x * b.y \% p + a.y * b.x \% p) \% p + p) \% p;}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\NormalTok{LL binpow\_real(LL a, LL b, LL p)}
\NormalTok{\{ }
\NormalTok{    LL ans = }\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{ (b)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{ (b \& }\DecValTok{1}\NormalTok{) ans = ans * a \% p;}
\NormalTok{        a = a * a \% p;}
\NormalTok{        b \textgreater{}\textgreater{}= }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans \% p;}
\NormalTok{\}}
\NormalTok{LL binpow\_imag(num a, LL b, LL p)}
\NormalTok{\{  }
\NormalTok{    num ans = \{}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{\};}
    \ControlFlowTok{while}\NormalTok{ (b)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{ (b \& }\DecValTok{1}\NormalTok{) ans = mul(ans, a, p);}
\NormalTok{        a = mul(a, a, p);}
\NormalTok{        b \textgreater{}\textgreater{}= }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans.x \% p;}
\NormalTok{\}}
\NormalTok{LL cipolla(LL n, LL p)}
\NormalTok{\{}
\NormalTok{    n \%= p;}
    \ControlFlowTok{if}\NormalTok{ (p == }\DecValTok{2}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ n;}
    \ControlFlowTok{if}\NormalTok{ (binpow\_real(n, (p {-} }\DecValTok{1}\NormalTok{) / }\DecValTok{2}\NormalTok{, p) == p {-} }\DecValTok{1}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    LL a;}
    \ControlFlowTok{while}\NormalTok{ (}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{ }
\NormalTok{        a = rand() \% p;}
\NormalTok{        w = ((a * a \% p {-} n) \% p + p) \% p;}
        \ControlFlowTok{if}\NormalTok{ (binpow\_real(w, (p {-} }\DecValTok{1}\NormalTok{) / }\DecValTok{2}\NormalTok{, p) == p {-} }\DecValTok{1}\NormalTok{) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    num x = \{a, }\DecValTok{1}\NormalTok{\};}
    \ControlFlowTok{return}\NormalTok{ binpow\_imag(x, (p + }\DecValTok{1}\NormalTok{) / }\DecValTok{2}\NormalTok{, p);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    srand(time(}\DecValTok{0}\NormalTok{));}
\NormalTok{    MC}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%lld\%lld}\StringTok{"}\NormalTok{,\&n,\&p);}
        \ControlFlowTok{if}\NormalTok{(!n) printf(}\StringTok{"0}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            LL ans1=cipolla(n,p),ans2=p{-}ans1;}
            \ControlFlowTok{if}\NormalTok{(ans1=={-}}\DecValTok{1}\NormalTok{)printf(}\StringTok{"Hola!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(ans1==ans2)printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans1);}
                \ControlFlowTok{else}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{ }\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,min(ans1,ans2),max(ans1,ans2));}
\NormalTok{            \}}

\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6590ux6ce2ux90a3ux5951ux901aux9879ux516cux5f0f}{%
\subsection{斐波那契通项公式}\label{ux6590ux6ce2ux90a3ux5951ux901aux9879ux516cux5f0f}}

\[
a_n=\frac{1}{\sqrt{5}}[(\frac{\sqrt{5}+1}{2})^n-(\frac{\sqrt{5}-1}{2})^n]
\]

在模 \(1e9+9\) 意义下有：

\[\frac{1}{\sqrt{5}} = 383008016\]

\[\frac{\sqrt{5}+1}{2} = 691504013\]

\[\frac{\sqrt{5}-1}{2} = 308495997\]

可以用来快速求 fib \(k\) 次方之和

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ LL a = }\DecValTok{691504013}\NormalTok{, b = }\DecValTok{308495997}\NormalTok{, t = }\DecValTok{383008016}\NormalTok{, MOD = }\FloatTok{1e9}\NormalTok{+}\DecValTok{9}\NormalTok{;}

\NormalTok{LL n; }\DataTypeTok{int}\NormalTok{ k;}
\NormalTok{LL f[MAXN],fi[MAXN],inv[MAXN];}
\NormalTok{LL pa[MAXN],pb[MAXN];}
\NormalTok{LL fpow(LL x,LL k)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{1}\NormalTok{; x\%=MOD;}
    \ControlFlowTok{while}\NormalTok{(k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\&}\DecValTok{1}\NormalTok{)ans=ans*x\%MOD;}
\NormalTok{        x=x*x\%MOD,k=k\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\NormalTok{LL get\_inv(LL x)\{}\ControlFlowTok{return}\NormalTok{ fpow(x,MOD{-}}\DecValTok{2}\NormalTok{);\}}
\NormalTok{LL C(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m)\{}\ControlFlowTok{return}\NormalTok{ f[n]*fi[n{-}m]\%MOD*fi[m]\%MOD;\}}
\NormalTok{LL A(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m)\{}\ControlFlowTok{return}\NormalTok{ f[n]*fi[n{-}m]\%MOD;\}}
\DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{\{}
\NormalTok{    f[}\DecValTok{0}\NormalTok{]=fi[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,n)f[i]=f[i{-}}\DecValTok{1}\NormalTok{]*i\%MOD;}
\NormalTok{    fi[n]=get\_inv(f[n]);}
\NormalTok{    fd(i,n{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)fi[i]=fi[i+}\DecValTok{1}\NormalTok{]*(i+}\DecValTok{1}\NormalTok{)\%MOD;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)inv[i]=fi[i]*f[i{-}}\DecValTok{1}\NormalTok{]\%MOD;}
\NormalTok{\}}
\NormalTok{LL sum(LL a1, LL q, LL n)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(q==}\DecValTok{1}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ n*a1\%MOD;}
    \ControlFlowTok{return}\NormalTok{ a1*(}\DecValTok{1}\NormalTok{{-}fpow(q,n))\%MOD*get\_inv(}\DecValTok{1}\NormalTok{{-}q)\%MOD;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    init(}\FloatTok{1e5}\NormalTok{);}
\NormalTok{    pa[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,}\FloatTok{1e5}\NormalTok{)pa[i]=pa[i{-}}\DecValTok{1}\NormalTok{]*a\%MOD;}
\NormalTok{    pb[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,}\FloatTok{1e5}\NormalTok{)pb[i]=pb[i{-}}\DecValTok{1}\NormalTok{]*b\%MOD;}
\NormalTok{    MC}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%lld\%d}\StringTok{"}\NormalTok{,\&n,\&k);}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(j,}\DecValTok{0}\NormalTok{,k)}
\NormalTok{            ans+=C(k,j)*sum(pa[k{-}j]*pb[j]\%MOD,pa[k{-}j]*pb[j]\%MOD,n)\%MOD*((j\&}\DecValTok{1}\NormalTok{)?{-}}\DecValTok{1}\NormalTok{:}\DecValTok{1}\NormalTok{),ans\%=MOD;}
\NormalTok{        ans*=fpow(get\_inv(t),k),ans\%=MOD,ans+=MOD,ans\%=MOD;}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7b49ux6bd4ux6c42ux548c}{%
\subsection{等比求和}\label{ux7b49ux6bd4ux6c42ux548c}}

\[
    q = 1, S_{n} = n*a_{1} 
\]

\[
    q \neq 1, S_{n} = \frac{a_1(1-q^n)}{1-q}=\frac{a_1-a_{n}q}{1-q}
\]

\hypertarget{ux7b49ux5deeux6c42ux548c}{%
\subsection{等差求和}\label{ux7b49ux5deeux6c42ux548c}}

\[
    S_{n} = na_{1} + \frac{n(n-1)}{2}d = \frac{n(a_{1} + a_{n})}{2}
\]

\hypertarget{gcd-exgcd}{%
\subsection{GCD \& EXGCD}\label{gcd-exgcd}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ gcd(}\DataTypeTok{int}\NormalTok{ a,}\DataTypeTok{int}\NormalTok{ b)\{}\ControlFlowTok{return}\NormalTok{ b==}\DecValTok{0}\NormalTok{?a:gcd(b,a\%b);\}}
\DataTypeTok{void}\NormalTok{ exgcd(}\DataTypeTok{int}\NormalTok{ a,}\DataTypeTok{int}\NormalTok{ b,}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ \&y,}\DataTypeTok{int}\NormalTok{ \&d)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!b)\{d = a;x = }\DecValTok{1}\NormalTok{;y=}\DecValTok{0}\NormalTok{;}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{else}\NormalTok{\{exgcd(b,a\%b,y,x,d);y{-}=x*(a/b);\}}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ a,}\DataTypeTok{int}\NormalTok{ b,}\DataTypeTok{int}\NormalTok{ c,}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ \&y)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ d=gcd(a,b);}
    \ControlFlowTok{if}\NormalTok{(c\%d) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}\CommentTok{//无解}
\NormalTok{    a/=d,b/=d,c/=d;}
\NormalTok{    exgcd(a,b,x,y,d);}
\NormalTok{    x*=c,y*=c;}
    \CommentTok{//x+=b y{-}=a}
    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux89e3ux65b9ux7a0b-axbyc}{%
\subsubsection{\texorpdfstring{1.解方程
\(ax+by=c\)}{1.解方程 ax+by=c}}\label{ux89e3ux65b9ux7a0b-axbyc}}

设 \(g=gcd(a, b)\)，首先方程有解的前提是 \({c}\) \% \({g} = 0\)

令 \(a'=a/g\)，\(b'=b/g\)，\(c'=c/g\)，则方程 \(ax+by=c\) 的解与方程
\(a'x+b'y=c'\) 的解一一对应，同时满足 \(gcd(a', b')=1\)（即 \(a'\),
\(b'\) 互质）

利用 \(exgcd\) 我们可以求得方程\(a'x+b'y=gcd(a',b')=1\) 的一组特解
\(x_{0},y_{0}\)，那么\textbf{原方程的通解}可以表示为：

\(c'*x_{0}+k*b',c'*y_{0}-k*a',k\in{Z}\)

\hypertarget{ux5febux901fux5e42}{%
\subsection{快速幂}\label{ux5febux901fux5e42}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL fpow(LL x,LL k)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\&}\DecValTok{1}\NormalTok{) ans=ans*x\%MOD;}
\NormalTok{        x=x*x\%MOD,k=k\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux56e0ux5b50ux6c42ux548c}{%
\subsection{因子求和}\label{ux56e0ux5b50ux6c42ux548c}}

若X分解质因数的结果是 \[p_1^{c_1}p_2^{c_2}...p_n^{c_n}\]
那么X所有因子的和就是
\[(1+p_1^1+...+p_1^{c_1})(1+p_2^1+...+p_2^{c_2})...(1+p_n^1+p_n^2+...+p_n^{c_n})\]
等比数列求和即可，注意下 \(1-p\) 和模数互质的情况，这时
\[(1+p^1+p^2+...+p^n) \equiv  (n+1) \]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//求a\^{}b的所有因子之和}
\NormalTok{LL inv(LL x)\{}\ControlFlowTok{return}\NormalTok{ fpow(x,MOD{-}}\DecValTok{2}\NormalTok{);\}}
\NormalTok{LL a,b;}
\NormalTok{vector\textless{}lpr\textgreater{} p;}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    a=read(),b=read();}
    \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{1}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"0}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{if}\NormalTok{(b==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{;(LL)i\textless{}=a;i++)}
\NormalTok{    \{}
\NormalTok{        LL cnt=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{(a\%i==}\DecValTok{0}\NormalTok{) a/=i,cnt++;}
        \ControlFlowTok{if}\NormalTok{(cnt) p.pb(\{i,cnt*b\});}
        \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{1}\NormalTok{) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    LL ans=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:p)}
\NormalTok{    \{}
\NormalTok{        LL t=x.fi,cnt=x.se;}
        \ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{{-}t)\%MOD==}\DecValTok{0}\NormalTok{) ans=ans*(cnt+}\DecValTok{1}\NormalTok{)\%MOD;}
        \ControlFlowTok{else}\NormalTok{ ans=(ans*(}\DecValTok{1}\NormalTok{{-}fpow(t,cnt+}\DecValTok{1}\NormalTok{))\%MOD*inv(}\DecValTok{1}\NormalTok{{-}t)\%MOD+MOD)\%MOD;}
\NormalTok{    \}}
\NormalTok{    write(ans),putchar(}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6027ux7b5bux7d20ux6570}{%
\subsection{线性筛素数}\label{ux7ebfux6027ux7b5bux7d20ux6570}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} prime;}
\DataTypeTok{bool}\NormalTok{ flag[N];}
\DataTypeTok{void}\NormalTok{ init\_prime(}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{\{}
\NormalTok{    flag[}\DecValTok{1}\NormalTok{]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!flag[i]) prime.pb(i);}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ p:prime)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{((LL)p*i\textgreater{}n) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{            flag[p*i]=}\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(i\%p==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865ux9636ux4e58ux5206ux89e3ux8d28ux56e0ux6570}{%
\subsection{(待补)阶乘分解质因数}\label{ux5f85ux8865ux9636ux4e58ux5206ux89e3ux8d28ux56e0ux6570}}

\(O(n\log{n})\)

\hypertarget{ux7ec4ux5408ux6570ux9012ux63a8}{%
\subsection{组合数递推}\label{ux7ec4ux5408ux6570ux9012ux63a8}}

\(C(n,m)=C(n-1,m-1)+C(n-1,m)\)

\hypertarget{ux7ec4ux5408ux6570ux9884ux5904ux7406}{%
\subsection{组合数预处理}\label{ux7ec4ux5408ux6570ux9884ux5904ux7406}}

O(n+nlogn)

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ LL MOD = }\DecValTok{998244353}\NormalTok{;}
\NormalTok{LL f[MAXN],ff[MAXN];}
\NormalTok{LL fpow(LL x,LL k)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{1}\NormalTok{; x\%=MOD;}
    \ControlFlowTok{while}\NormalTok{(k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\&}\DecValTok{1}\NormalTok{)ans=ans*x\%MOD;}
\NormalTok{        x=x*x\%MOD,k=k\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\KeywordTok{inline}\NormalTok{ LL inv(LL x)\{}\ControlFlowTok{return}\NormalTok{ fpow(x,MOD{-}}\DecValTok{2}\NormalTok{);\}}
\KeywordTok{inline}\NormalTok{ LL A(LL n,LL m)\{}\ControlFlowTok{return}\NormalTok{ f[n]*ff[n{-}m]\%MOD;\}}
\KeywordTok{inline}\NormalTok{ LL C(LL n,LL m)\{}\ControlFlowTok{return}\NormalTok{ A(n,m)*ff[m]\%MOD;\}}
\KeywordTok{inline} \DataTypeTok{void}\NormalTok{ init()\{f[}\DecValTok{0}\NormalTok{]=ff[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,MAXN{-}}\DecValTok{1}\NormalTok{)f[i]=f[i{-}}\DecValTok{1}\NormalTok{]*i\%MOD,ff[i]=ff[i{-}}\DecValTok{1}\NormalTok{]*inv(i)\%MOD;\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{fft}{%
\subsection{FFT}\label{fft}}

当所求的值可以写作 \[h(j)=\sum_{i=0}^{j}f(i)*g(j-i)\] 或
\[h(j)=\sum_{i=j+1}^{n}f(i)*g(i-j)\] 的卷积形式时，可以考虑使用 \(FFT\)
，第二种类型的多项式需要翻转并扩展上下界来变成第一类的形式。

\hypertarget{ux8d44ux6599-6}{%
\subsubsection{资料}\label{ux8d44ux6599-6}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{https://www.cnblogs.com/zwfymqz/p/8244902.html?tdsourcetag=s_pctim_aiomsg}{快速傅里叶变换(FFT)详解}
\item
  \href{https://oi.men.ci/fft-notes/}{FFT 学习笔记}
\item
  \href{https://blog.csdn.net/qq_38891827/article/details/80281151}{FFT模板以及简单的FFT入门题总结}
\end{enumerate}

\hypertarget{ux6a21ux677f-10}{%
\subsubsection{模板}\label{ux6a21ux677f-10}}

\hypertarget{ux5e38ux89c4}{%
\paragraph{常规}\label{ux5e38ux89c4}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef}\NormalTok{ cp complex\textless{}}\DataTypeTok{double}\NormalTok{\textgreater{};}
\KeywordTok{namespace}\NormalTok{ fft}
\NormalTok{\{}
\NormalTok{    cp o[}\DecValTok{4}\NormalTok{*MAXN],oi[}\DecValTok{4}\NormalTok{*MAXN];}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
\NormalTok{            o[i] =cp(cos(}\DecValTok{2}\NormalTok{*PI/n*i),sin(}\DecValTok{2}\NormalTok{*PI/n*i));}
\NormalTok{            oi[i]=conj(o[i]);}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ transform(cp a[],}\AttributeTok{const} \DataTypeTok{int}\NormalTok{ n,cp o[])}
\NormalTok{    \{}
        \CommentTok{//二进制翻转}
        \DataTypeTok{int}\NormalTok{ k=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}k)\textless{}n)k++;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ t=}\DecValTok{0}\NormalTok{;}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{0}\NormalTok{;j\textless{}k;j++)}
                \ControlFlowTok{if}\NormalTok{(i\&(}\DecValTok{1}\NormalTok{\textless{}\textless{}j))}
\NormalTok{                    t|=(}\DecValTok{1}\NormalTok{\textless{}\textless{}(k{-}j{-}}\DecValTok{1}\NormalTok{));}
            \ControlFlowTok{if}\NormalTok{(i\textless{}t) swap(a[i],a[t]);}
\NormalTok{        \}}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{2}\NormalTok{;l\textless{}=n;l*=}\DecValTok{2}\NormalTok{)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ m=l/}\DecValTok{2}\NormalTok{;}
            \CommentTok{//将两个长度为 m 的序列的答案合并为长度为 l 的序列的答案}
            \ControlFlowTok{for}\NormalTok{(cp *p=a;p!=a+n;p+=l)}
\NormalTok{            \{}
                \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}m;i++)}
\NormalTok{                \{}
\NormalTok{                    cp t=o[n/l*i]*p[m+i];}
\NormalTok{                    p[m+i]=p[i]{-}t,p[i]+=t;}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ dft (cp a[],}\DataTypeTok{int}\NormalTok{ n)\{transform(a,n,o);\}}
    \DataTypeTok{void}\NormalTok{ idft(cp a[],}\DataTypeTok{int}\NormalTok{ n)\{transform(a,n,oi);}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++) a[i]/=n;\}}
\NormalTok{\};}

\CommentTok{//n1 n2为多项式a1 a2系数的个数 不是最高次数(注意+1)}

\DataTypeTok{void}\NormalTok{ mul(}\DataTypeTok{int}\NormalTok{ a1[],}\DataTypeTok{int}\NormalTok{ n1,}\DataTypeTok{int}\NormalTok{ a2[],}\DataTypeTok{int}\NormalTok{ n2,}\DataTypeTok{int}\NormalTok{ res[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(n\textless{}n1+n2) n=n\textless{}\textless{}}\DecValTok{1}\NormalTok{;}
    \AttributeTok{static}\NormalTok{ cp c1[}\DecValTok{4}\NormalTok{*MAXN],c2[}\DecValTok{4}\NormalTok{*MAXN];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{} n;i++) c1[i]=c2[i]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1;i++) c1[i].real(a1[i]);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n2;i++) c2[i].real(a2[i]);}
\NormalTok{    fft::init(n);}
\NormalTok{    fft::dft(c1,n),fft::dft(c2,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++) c1[i]*=c2[i];}
\NormalTok{    fft::idft(c1,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1+n2{-}}\DecValTok{1}\NormalTok{;i++)}
\NormalTok{        res[i]=}\DataTypeTok{int}\NormalTok{(floor(c1[i].real()+}\FloatTok{0.5}\NormalTok{));}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mul(}\DataTypeTok{double}\NormalTok{ a1[],}\DataTypeTok{int}\NormalTok{ n1,}\DataTypeTok{double}\NormalTok{ a2[],}\DataTypeTok{int}\NormalTok{ n2,}\DataTypeTok{double}\NormalTok{ res[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(n\textless{}n1+n2) n=n\textless{}\textless{}}\DecValTok{1}\NormalTok{;}
    \AttributeTok{static}\NormalTok{ cp c1[}\DecValTok{4}\NormalTok{*MAXN],c2[}\DecValTok{4}\NormalTok{*MAXN];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{} n;i++) c1[i]=c2[i]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1;i++) c1[i].real(a1[i]);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n2;i++) c2[i].real(a2[i]);}
\NormalTok{    fft::init(n);}
\NormalTok{    fft::dft(c1,n),fft::dft(c2,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++) c1[i]*=c2[i];}
\NormalTok{    fft::idft(c1,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1+n2{-}}\DecValTok{1}\NormalTok{;i++)}
\NormalTok{        res[i]=c1[i].real();}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5361ux5e38}{%
\paragraph{卡常}\label{ux5361ux5e38}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ cp}
\NormalTok{\{}
    \DataTypeTok{double}\NormalTok{ r,i;}
\NormalTok{    cp(}\DataTypeTok{double}\NormalTok{ \_r = }\DecValTok{0}\NormalTok{,}\DataTypeTok{double}\NormalTok{ \_i = }\DecValTok{0}\NormalTok{)\{r = \_r; i = \_i;\}}
\NormalTok{    cp }\KeywordTok{operator}\NormalTok{ +(}\AttributeTok{const}\NormalTok{ cp  \&b)\{}\ControlFlowTok{return}\NormalTok{ cp(r+b.r,i+b.i);\}}
\NormalTok{    cp }\KeywordTok{operator}\NormalTok{ {-}(}\AttributeTok{const}\NormalTok{ cp  \&b)\{}\ControlFlowTok{return}\NormalTok{ cp(r{-}b.r,i{-}b.i);\}}
\NormalTok{    cp }\KeywordTok{operator}\NormalTok{ *(}\AttributeTok{const}\NormalTok{ cp  \&b)\{}\ControlFlowTok{return}\NormalTok{ cp(r*b.r{-}i*b.i,r*b.i+i*b.r);\}}
\NormalTok{    cp }\KeywordTok{operator}\NormalTok{ /(}\AttributeTok{const} \DataTypeTok{int}\NormalTok{ \&n)\{}\ControlFlowTok{return}\NormalTok{ cp(r/n,i/n);\}}
\NormalTok{\};}

\KeywordTok{namespace}\NormalTok{ fft}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ R[MAXN*}\DecValTok{4}\NormalTok{];}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ L=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{while}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}L)\textless{}n) L++;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
\NormalTok{            R[i]=(R[i\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{]\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{)|((i\&}\DecValTok{1}\NormalTok{)\textless{}\textless{}(L{-}}\DecValTok{1}\NormalTok{));}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ transform(cp a[],}\AttributeTok{const} \DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ f)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++)}
            \ControlFlowTok{if}\NormalTok{(i\textless{}R[i])}
\NormalTok{                swap(a[i],a[R[i]]);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{2}\NormalTok{;l\textless{}=n;l=l\textless{}\textless{}}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ m=l/}\DecValTok{2}\NormalTok{;}
\NormalTok{            cp wn=cp(cos(}\DecValTok{2}\NormalTok{*PI/l),f*sin(}\DecValTok{2}\NormalTok{*PI/l));}
            \ControlFlowTok{for}\NormalTok{(cp *p=a;p!=a+n;p+=l)}
\NormalTok{            \{}
\NormalTok{                cp w=cp(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}
                \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}m;i++,w=w*wn)}
\NormalTok{                \{}
\NormalTok{                    cp t=w*p[m+i];}
\NormalTok{                    p[m+i]=p[i]{-}t,p[i]=p[i]+t;}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ dft (cp a[],}\DataTypeTok{int}\NormalTok{ n)\{transform(a,n, }\DecValTok{1}\NormalTok{);\}}
    \DataTypeTok{void}\NormalTok{ idft(cp a[],}\DataTypeTok{int}\NormalTok{ n)\{transform(a,n,{-}}\DecValTok{1}\NormalTok{);}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++) a[i]=a[i]/n;\}}
\NormalTok{\};}

\NormalTok{cp c1[MAXN*}\DecValTok{4}\NormalTok{],c2[MAXN*}\DecValTok{4}\NormalTok{];}
\DataTypeTok{void}\NormalTok{ mul(LL a1[],}\DataTypeTok{int}\NormalTok{ n1,LL a2[],}\DataTypeTok{int}\NormalTok{ n2,LL res[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(n\textless{}n1+n2) n=n\textless{}\textless{}}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}=n;i++) c1[i]=c2[i]=cp(}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1;i++) c1[i]=cp(a1[i],}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n2;i++) c2[i]=cp(a2[i],}\DecValTok{0}\NormalTok{);}
\NormalTok{    fft::init(n);}
\NormalTok{    fft::dft(c1,n),fft::dft(c2,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n;i++) c1[i]=c1[i]*c2[i];}
\NormalTok{    fft::idft(c1,n);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}n1+n2{-}}\DecValTok{1}\NormalTok{;i++)}
\NormalTok{        res[i]=LL(floor(c1[i].r+}\FloatTok{0.5}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux9ad8ux65afux6d88ux5143}{%
\subsection{高斯消元}\label{ux9ad8ux65afux6d88ux5143}}

\hypertarget{ux666eux901a-1}{%
\subsubsection{普通}\label{ux666eux901a-1}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ guass(}\DataTypeTok{int}\NormalTok{ **a,}\DataTypeTok{int}\NormalTok{ n)}\CommentTok{//高斯消元}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{,to;}\DataTypeTok{double}\NormalTok{ t;}\CommentTok{//now为当前处理的行数}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) }\CommentTok{//消去并回代Xi}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(to=i;to\textless{}=n;to++)}
            \ControlFlowTok{if}\NormalTok{(fabs(a[to][i])\textgreater{}eps) }\ControlFlowTok{break}\NormalTok{;}\CommentTok{//找到Xi系数非0的一行}
        \ControlFlowTok{if}\NormalTok{(to\textgreater{}n) }\ControlFlowTok{continue}\NormalTok{;}\CommentTok{//Xi系数全为0}
        \ControlFlowTok{if}\NormalTok{(to!=i)}\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=n+}\DecValTok{1}\NormalTok{;j++)}
\NormalTok{            swap(a[to][j],a[i][j]);}\CommentTok{//交换}
\NormalTok{        t=a[i][i];}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=n+}\DecValTok{1}\NormalTok{;j++) a[i][j]/=t;}\CommentTok{//将Xi行所有的系数变为1}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ j=}\DecValTok{1}\NormalTok{;j\textless{}=n;j++)}\CommentTok{//j为1到n 回代与消去同时进行}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(j==i) }\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{            t=a[j][i];}\CommentTok{//倍数}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=}\DecValTok{1}\NormalTok{;k\textless{}=n+}\DecValTok{1}\NormalTok{;k++)}
\NormalTok{                a[j][k]{-}=t*a[i][k];}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
        \ControlFlowTok{if}\NormalTok{(fabs(a[i][n+}\DecValTok{1}\NormalTok{])\textgreater{}eps) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}\CommentTok{//出现 0=常数 的情况无解}
    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}\CommentTok{//有解}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6a21ux610fux4e49}{%
\subsubsection{模意义}\label{ux6a21ux610fux4e49}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ guass(LL a[][sz], }\DataTypeTok{int}\NormalTok{ n, }\DataTypeTok{int}\NormalTok{ MOD) }\CommentTok{//模意义下的高斯消元}
\NormalTok{\{}
\NormalTok{    LL t;}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{, to;}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{;i \textless{}= n;i++)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{ (to = i;to \textless{}= n;to++)}
            \ControlFlowTok{if}\NormalTok{ (a[to][i]) }\ControlFlowTok{break}\NormalTok{;}

        \ControlFlowTok{if}\NormalTok{ (to \textgreater{} n) }\ControlFlowTok{continue}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{ (to != i)}
            \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{1}\NormalTok{;j \textless{}= n + }\DecValTok{1}\NormalTok{;j++)}
\NormalTok{                swap(a[to][j], a[i][j]);}
        
\NormalTok{        t = get\_inv(a[i][i], MOD);}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{1}\NormalTok{;j \textless{}= n + }\DecValTok{1}\NormalTok{;j++)}
\NormalTok{            a[i][j] *= t, a[i][j] \%= MOD;}

        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = }\DecValTok{1}\NormalTok{;j \textless{}= n;j++)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{ (j == i) }\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{            t = a[j][i];}
            \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ k = }\DecValTok{1}\NormalTok{;k \textless{}= n + }\DecValTok{1}\NormalTok{;k++)}
\NormalTok{                a[j][k] = ((a[j][k] {-} t * a[i][k] \% MOD) }
\NormalTok{                    \% MOD + MOD) \% MOD;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{lucas}{%
\subsection{Lucas}\label{lucas}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ C(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m,}\DataTypeTok{int}\NormalTok{ p)}\CommentTok{//C(n,m) mod p p为素数}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(n\textless{}m) }\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}\CommentTok{//注意当n\textless{}m时 C(a, b) = 0}
    \ControlFlowTok{if}\NormalTok{(m\textgreater{}n{-}m) m=n{-}m;}
    \DataTypeTok{int}\NormalTok{ s1=}\DecValTok{1}\NormalTok{,s2=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=m;i++) s1=s1*(n{-}i+}\DecValTok{1}\NormalTok{)\%p;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=m;i++) s2=s2*i\%p;}
    \ControlFlowTok{return}\NormalTok{ s1*qpow(s2,p{-}}\DecValTok{2}\NormalTok{,p)\%p;}\CommentTok{//逆元}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ lucas(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m,}\DataTypeTok{int}\NormalTok{ p)}\CommentTok{//lucas定理　}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!n||!m) }\ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ lucas(n/p,m/p,p)*C(n\%p,m\%p,p)\%p;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6b27ux62c9ux964dux5e42}{%
\subsection{欧拉降幂}\label{ux6b27ux62c9ux964dux5e42}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL euler(LL a, string b, LL m) }\CommentTok{// 扩展欧拉定理 a\^{}b \% m = a\^{}(b\%phi(m)+phi(m)) \% m b为高精度}
\NormalTok{\{}
    \DataTypeTok{bool}\NormalTok{ flag = }\DecValTok{0}\NormalTok{;}
\NormalTok{    LL t = }\DecValTok{0}\NormalTok{, phi\_m = get\_phi(m);}
    \ControlFlowTok{for}\NormalTok{ (string::iterator p = b.begin();p != b.end();p++)}
\NormalTok{    \{}
\NormalTok{        t = t * }\DecValTok{10}\NormalTok{ + (*p) {-} }\CharTok{\textquotesingle{}0\textquotesingle{}}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{ (t \textgreater{}= phi\_m) }\CommentTok{// 当b\textless{}phi(m)时直接用快速幂}
\NormalTok{            t \%= phi\_m, flag = }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ flag ? fast\_pow(a, t \% phi\_m + phi\_m, m) : fast\_pow(a, t, m);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865ux4e2dux56fdux5269ux4f59ux5b9aux7406}{%
\subsection{(待补)中国剩余定理}\label{ux5f85ux8865ux4e2dux56fdux5269ux4f59ux5b9aux7406}}

\hypertarget{ux7ebfux6027ux6c42ux9006ux5143}{%
\subsection{线性求逆元}\label{ux7ebfux6027ux6c42ux9006ux5143}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n;}
\NormalTok{LL MOD,f[MAXN],fi[MAXN],inv[MAXN];}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    f[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,n)f[i]=f[i{-}}\DecValTok{1}\NormalTok{]*i\%MOD;}
\NormalTok{    fi[n]=fpow(f[n],MOD{-}}\DecValTok{2}\NormalTok{);}
\NormalTok{    fd(i,n{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)fi[i]=fi[i+}\DecValTok{1}\NormalTok{]*(i+}\DecValTok{1}\NormalTok{)\%MOD;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)inv[i]=fi[i]*f[i{-}}\DecValTok{1}\NormalTok{]\%MOD;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6570ux8bbaux5206ux5757ux6574ux9664ux5206ux5757}{%
\subsection{数论分块(整除分块)}\label{ux6570ux8bbaux5206ux5757ux6574ux9664ux5206ux5757}}

\(\lfloor \frac{n}{i} \rfloor\) 的取值最多 \(sqrt(n)\) 种

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,r=}\DecValTok{1}\NormalTok{;l\textless{}=n;l=r+}\DecValTok{1}\NormalTok{,r=min(n,n/(n/l)))}
\NormalTok{\{}
\NormalTok{    ...}
    \ControlFlowTok{if}\NormalTok{(r==n)}\ControlFlowTok{break}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{o1ux7ec4ux5408ux6570ux5957ux88c5}{%
\subsection{O(1)组合数套装}\label{o1ux7ec4ux5408ux6570ux5957ux88c5}}

预处理 \(O(n)\)

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#undef fi}
\DataTypeTok{int}\NormalTok{ n,m;}
\AttributeTok{const}\NormalTok{ LL MOD = }\DecValTok{998244353}\NormalTok{;}
\NormalTok{LL f[MAXN],fi[MAXN],inv[MAXN];}
\NormalTok{LL fpow(LL x,LL k)}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{1}\NormalTok{; x\%=MOD;}
    \ControlFlowTok{while}\NormalTok{(k)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(k\&}\DecValTok{1}\NormalTok{)ans=ans*x\%MOD;}
\NormalTok{        x=x*x\%MOD,k=k\textgreater{}\textgreater{}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\NormalTok{LL get\_inv(LL x)\{}\ControlFlowTok{return}\NormalTok{ fpow(x,MOD{-}}\DecValTok{2}\NormalTok{);\}}
\NormalTok{LL C(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m)\{}\ControlFlowTok{return}\NormalTok{ f[n]*fi[n{-}m]\%MOD*fi[m]\%MOD;\}}
\NormalTok{LL A(}\DataTypeTok{int}\NormalTok{ n,}\DataTypeTok{int}\NormalTok{ m)\{}\ControlFlowTok{return}\NormalTok{ f[n]*fi[n{-}m]\%MOD;\}}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    f[}\DecValTok{0}\NormalTok{]=fi[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,n)f[i]=f[i{-}}\DecValTok{1}\NormalTok{]*i\%MOD;}
\NormalTok{    fi[n]=get\_inv(f[n]);}
\NormalTok{    fd(i,n{-}}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)fi[i]=fi[i+}\DecValTok{1}\NormalTok{]*(i+}\DecValTok{1}\NormalTok{)\%MOD;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)inv[i]=fi[i]*f[i{-}}\DecValTok{1}\NormalTok{]\%MOD;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux7ebfux6027ux57fa}{%
\subsection{线性基}\label{ux7ebfux6027ux57fa}}

\hypertarget{ux8d44ux6599-7}{%
\subsubsection{资料}\label{ux8d44ux6599-7}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \href{https://oi.men.ci/linear-basis-notes/}{线性基学习笔记 Menci}
\item
  \href{https://ouuan.github.io/\%E7\%BA\%BF\%E6\%80\%A7\%E5\%9F\%BA\%E5\%AD\%A6\%E4\%B9\%A0\%E7\%AC\%94\%E8\%AE\%B0/}{线性基学习笔记
  ouuan}
\end{enumerate}

\hypertarget{ux6027ux8d28-1}{%
\subsubsection{性质}\label{ux6027ux8d28-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  线性基内的元素线性无关
\item
  原集合的任意一个元素都可唯一的表示为线性基中若干个元素异或起来的结果
\item
  线性基合并只需要将一个线性基中的所有元素插入到另一个线性基中即可。
\end{enumerate}

\hypertarget{ux6a21ux677f-11}{%
\subsubsection{模板}\label{ux6a21ux677f-11}}

\hypertarget{ux7ebfux6027ux57faux6c42ux6700ux5927ux5f02ux6216ux548c}{%
\paragraph{1.线性基求最大异或和}\label{ux7ebfux6027ux57faux6c42ux6700ux5927ux5f02ux6216ux548c}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ LinearBasis}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{int}\NormalTok{ mn = }\DecValTok{60}\NormalTok{;}
\NormalTok{    LL a[MAXN];}
\NormalTok{    LL maxXor()}\CommentTok{//最大异或和}
\NormalTok{    \{}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=mn;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
            \ControlFlowTok{if}\NormalTok{((ans\^{}a[i])\textgreater{}ans)}
\NormalTok{                ans\^{}=a[i];}
        \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ insert(LL x)}\CommentTok{//插入一个数}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=mn;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\BuiltInTok{LL}\NormalTok{\textless{}\textless{}i)\&x)}
\NormalTok{            \{}
                \ControlFlowTok{if}\NormalTok{(a[i]) x\^{}=a[i];}
                \ControlFlowTok{else}\NormalTok{\{a[i]=x;}\ControlFlowTok{break}\NormalTok{;\}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \DataTypeTok{bool}\NormalTok{ check(LL x)}\CommentTok{//判断x是否可由线性基构造出来}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=mn;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
            \ControlFlowTok{if}\NormalTok{(((}\DecValTok{1}\BuiltInTok{LL}\NormalTok{\textless{}\textless{}i)\&x) \&\& a[i])}
\NormalTok{                x\^{}=a[i];}
        \ControlFlowTok{return}\NormalTok{ x==}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux524dux7f00ux7ebfux6027ux57fa}{%
\paragraph{2.前缀线性基}\label{ux524dux7f00ux7ebfux6027ux57fa}}

前缀线性基可以解决用给定区间内的元素所能异或出的最大和问题，本质上是贪心的选择��置更靠右的元素作为基底。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ a[MAXN][}\DecValTok{31}\NormalTok{];}\CommentTok{//线性基}
\DataTypeTok{int}\NormalTok{ pos[MAXN][}\DecValTok{31}\NormalTok{];}\CommentTok{//线性基中的元素在原序列中的位置}
\DataTypeTok{void}\NormalTok{ insert(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ index)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}=mx;i++)}
\NormalTok{    \{}
\NormalTok{        a[index][i]  =a[index{-}}\DecValTok{1}\NormalTok{][i];}
\NormalTok{        pos[index][i]=pos[index{-}}\DecValTok{1}\NormalTok{][i];}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ curp=index;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=mx;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}i)\&x)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!a[index][i])}\CommentTok{//该位上没有元素 直接插入}
\NormalTok{            \{}
\NormalTok{                a[index][i]=x;}
\NormalTok{                pos[index][i]=curp;}
                \ControlFlowTok{break}\NormalTok{;}
\NormalTok{            \}}
            \ControlFlowTok{if}\NormalTok{(curp\textgreater{}pos[index][i])}\CommentTok{//当前元素作为基时位置更靠右}
\NormalTok{            \{}
\NormalTok{                swap(x,a[index][i]);}
\NormalTok{                swap(curp,pos[index][i]);}
\NormalTok{            \}}
\NormalTok{            x\^{}=a[index][i];}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=mx;i\textgreater{}=}\DecValTok{0}\NormalTok{;i{-}{-})}
        \ControlFlowTok{if}\NormalTok{(a[r][i]\&\&pos[r][i]\textgreater{}=l)}
            \ControlFlowTok{if}\NormalTok{((ans\^{}a[r][i])\textgreater{}ans)}
\NormalTok{                ans\^{}=a[r][i];}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{dp}{%
\section{dp}\label{dp}}

\hypertarget{ux6811ux4e0aux80ccux5305ux4e0aux4e0bux754cux4f18ux5316-onm}{%
\subsection{树上背包上下界优化
O(nm)}\label{ux6811ux4e0aux80ccux5305ux4e0aux4e0bux754cux4f18ux5316-onm}}

\hypertarget{ux53c2ux8003}{%
\subsubsection{参考}\label{ux53c2ux8003}}

\href{https://www.cnblogs.com/ouuan/p/BackpackOnTree.html}{树上背包的上下界优化
ouuan}

\hypertarget{ux6a21ux677f-12}{%
\subsubsection{模板}\label{ux6a21ux677f-12}}

\href{https://ac.nowcoder.com/acm/contest/6895/A}{Nowcoder 蓝魔法师}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ LL MOD = }\DecValTok{998244353}\NormalTok{;}
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,k;}
\NormalTok{LL  f[MAXN][MAXN],s[MAXN],g[MAXN];}
\DataTypeTok{int}\NormalTok{ sz[MAXN];}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa) }
\NormalTok{\{   }
\NormalTok{    f[u][}\DecValTok{1}\NormalTok{]=sz[u]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
\NormalTok{        dfs(v,u),mst(g,}\DecValTok{0}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,min(k,sz[u]))}
\NormalTok{        \{}
\NormalTok{            fp(j,}\DecValTok{1}\NormalTok{,min(k{-}i,sz[v]))}
\NormalTok{                g[i+j]+=f[u][i]*f[v][j]\%MOD,g[i+j]\%=MOD;}
\NormalTok{            g[i]+=f[u][i]*s[v]\%MOD,g[i]\%=MOD;}
\NormalTok{        \}}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,k)f[u][i]=g[i];}
\NormalTok{        sz[u]+=sz[v];}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,k)s[u]+=f[u][i],s[u]\%=MOD;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&k);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,k)ans+=f[}\DecValTok{1}\NormalTok{][i],ans\%=MOD;}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{nlognux6c42lis}{%
\subsection{NlogN求LIS}\label{nlognux6c42lis}}

\hypertarget{ux6a21ux677f-13}{%
\subsubsection{模板}\label{ux6a21ux677f-13}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,ans1,ans2;}
\DataTypeTok{int}\NormalTok{ f1[MAXN],f2[MAXN];}
\DataTypeTok{int}\NormalTok{ s2[MAXN],s1[MAXN];}
\DataTypeTok{int}\NormalTok{ a[MAXN];}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[++n])!=EOF);n{-}{-};}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++) s1[i]=s2[i]=inf;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{    \{}
        \CommentTok{//s[i]代表长度为i的子序列最后一个元素的最小值}
        \DataTypeTok{int}\NormalTok{ j =lower\_bound(s1+}\DecValTok{1}\NormalTok{,s1+}\DecValTok{1}\NormalTok{+n,a[i]){-}s1;}
\NormalTok{        f1[i]=j,s1[j]=a[i];}
\NormalTok{        ans1=max(ans1,f1[i]);}
\NormalTok{    \}}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=n;i;i{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ j =upper\_bound(s2+}\DecValTok{1}\NormalTok{,s2+}\DecValTok{1}\NormalTok{+n,a[i]){-}s2;}
\NormalTok{        f2[i]=j,s2[j]=a[i];}
\NormalTok{        ans2=max(ans2,f2[i]);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans2,ans1);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6570ux4f4ddp-ux8bb0ux5fc6ux5316ux641cux7d22}{%
\subsection{数位DP
记忆化搜索}\label{ux6570ux4f4ddp-ux8bb0ux5fc6ux5316ux641cux7d22}}

\hypertarget{ux6a21ux677f-14}{%
\subsubsection{模板}\label{ux6a21ux677f-14}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL cnt,d[}\DecValTok{20}\NormalTok{],f[}\DecValTok{20}\NormalTok{][...];}

\CommentTok{//limit 是否有最高位限制}
\CommentTok{//lead  是否有前导零}
\CommentTok{//state 状态}
\CommentTok{//状态只与len之前的位有关 因此len之前的状态相同时可用记忆化来计算}
\CommentTok{//** 请用{-}1作为没算过的标记 **}
\NormalTok{LL dfs(}\DataTypeTok{int}\NormalTok{ len,}\DataTypeTok{bool}\NormalTok{ limit,}\DataTypeTok{bool}\NormalTok{ lead,}\DataTypeTok{int}\NormalTok{ state1 ...)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(len==}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return}\NormalTok{ ...; }\CommentTok{//边界值}
    \ControlFlowTok{if}\NormalTok{(!lead \&\& !limit  \&\& f[len][state1][...] != {-}}\DecValTok{1}\NormalTok{)  }\ControlFlowTok{return}\NormalTok{ f[len][state1][...];}
    \DataTypeTok{int}\NormalTok{ maxn=limit?d[len]:}\DecValTok{9}\NormalTok{;}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}=maxn;i++)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(lead\&\&i==}\DecValTok{0}\NormalTok{)}
\NormalTok{            ans+=dfs(len{-}}\DecValTok{1}\NormalTok{,limit\&\&i==maxn,}\DecValTok{1}\NormalTok{,...);}
        \ControlFlowTok{else}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(....)}
\NormalTok{                ans+=dfs(len{-}}\DecValTok{1}\NormalTok{,limit\&\&i==maxn,}\DecValTok{0}\NormalTok{,...);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(!lead \&\& !limit) f[len][state1][...]=ans;}
    \CommentTok{//cout \textless{}\textless{} dbgs(len) \textless{}\textless{} dbgs4(limit,lead,num,s) \textless{}\textless{} endl;}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}

\NormalTok{LL solve(LL x) }\CommentTok{//计算[0,x]内符合条件的数}
\NormalTok{\{}
\NormalTok{    cnt=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(x) d[++cnt]=x\%}\DecValTok{10}\NormalTok{,x=x/}\DecValTok{10}\NormalTok{;}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(...) ans+=dfs(cnt,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,...);}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
\NormalTok{    mst(f,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5b50ux96c6ux679aux4e3esos-dp}{%
\subsection{子集枚举(SOS-DP)}\label{ux5b50ux96c6ux679aux4e3esos-dp}}

\hypertarget{o3n}{%
\subsubsection{O(3\^{}n)}\label{o3n}}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;s\textless{}(}\DecValTok{1}\NormalTok{\textless{}\textless{}n);s++)}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=s;;i=(i{-}}\DecValTok{1}\NormalTok{)\&s)}
\NormalTok{    \{}
        \CommentTok{//code here...}
        \ControlFlowTok{if}\NormalTok{(!i) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{on2n}{%
\subsubsection{O(n*2\^{}n)}\label{on2n}}

类似于：

\[S_i = \sum_{j\subset i}A_j\]

\[F_i = \min_{}\{A_j\},  j\subset i\]

\[F_i = \max_{}\{A_j\},  j\subset i\]

的式子都可以用高维前缀和优化

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;s\textless{}(}\DecValTok{1}\NormalTok{\textless{}\textless{}n);s++)}
        \ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}(i{-}}\DecValTok{1}\NormalTok{))\&s)}
\NormalTok{            f[s]+=f[s\^{}(}\DecValTok{1}\NormalTok{\textless{}\textless{}(i{-}}\DecValTok{1}\NormalTok{))];}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux51b3ux7b56ux5355ux8c03ux6027}{%
\subsection{决策单调性}\label{ux51b3ux7b56ux5355ux8c03ux6027}}

\hypertarget{ux53efux79bbux7ebf}{%
\subsubsection{可离线}\label{ux53efux79bbux7ebf}}

分治

例：\href{https://www.luogu.com.cn/problem/CF321E}{CF321E}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ s,}\DataTypeTok{int}\NormalTok{ l=}\DecValTok{1}\NormalTok{,}\DataTypeTok{int}\NormalTok{ r=n,}\DataTypeTok{int}\NormalTok{ nl=}\DecValTok{0}\NormalTok{,}\DataTypeTok{int}\NormalTok{ nr=n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l\textgreater{}r) }\ControlFlowTok{return}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ m = mid,from; f[s][m]=inf; }
\NormalTok{    fp(i,nl,min(nr,m{-}}\DecValTok{1}\NormalTok{))}
        \ControlFlowTok{if}\NormalTok{(f[s{-}}\DecValTok{1}\NormalTok{][i]+cost(i+}\DecValTok{1}\NormalTok{,m)\textless{}f[s][m])}
\NormalTok{            f[s][m]=f[s{-}}\DecValTok{1}\NormalTok{][i]+cost(i+}\DecValTok{1}\NormalTok{,m),from=i;}
\NormalTok{    solve(s,l,m{-}}\DecValTok{1}\NormalTok{,nl,from),solve(s,m+}\DecValTok{1}\NormalTok{,r,from,nr);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e0dux53efux79bbux7ebf}{%
\subsubsection{不可离线}\label{ux4e0dux53efux79bbux7ebf}}

写法参考自：\href{https://max.book118.com/html/2017/0827/130420281.shtm}{浅析1D1D动态规划的优化}

确定 \(f[3]\) 之前所有状态的最优决策表：

1111111111111222222222222

加入 \(f[3]\) 后决策表只能有三种类型

1111111111111222222222222 不变

1111111111111222223333333 占据 \(2\) 的一部分

1111113333333333333333333 完全覆盖 \(2\)

考虑使用栈来维护每个 \(i\) 作为决策点的起始位置

设老决策的起点为 \(j\)，从栈顶向下依次考虑：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  若新决策在 \(j\) 优于老决策，则退栈并抛弃老决策
\item
  否则，转折点一定在当前这个老决策的区间中，二分这个位置
\item
  新决策入栈
\end{enumerate}

例： \href{https://www.luogu.com.cn/problem/P1912}{{[}NOI2009{]}诗人小G}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pr s[MAXN]; }\DataTypeTok{int}\NormalTok{ h=}\DecValTok{0}\NormalTok{;}
\NormalTok{LL calc(}\DataTypeTok{int}\NormalTok{ i,}\DataTypeTok{int}\NormalTok{ j)\{}\ControlFlowTok{return}\NormalTok{ f[j]+cost(i,j);\}}
\NormalTok{fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{\{}
\NormalTok{    pr t=*(ub(s+}\DecValTok{1}\NormalTok{,s+h+}\DecValTok{1}\NormalTok{,mp(i,inf)){-}}\DecValTok{1}\NormalTok{);}

\NormalTok{    f[i]=calc(i,t.se),from[i]=t.se;}
    
    \ControlFlowTok{if}\NormalTok{(i==n||calc(n,s[h].se)\textless{}calc(n,i))}\ControlFlowTok{continue}\NormalTok{;}

    \ControlFlowTok{while}\NormalTok{(h\&\&s[h].fi\textgreater{}i\&\&calc(s[h].fi,s[h].se)\textgreater{}calc(s[h].fi,i))h{-}{-};}
    \DataTypeTok{int}\NormalTok{ l=max(i+}\DecValTok{1}\NormalTok{,s[h].fi),r=n,ans=n;}
    \ControlFlowTok{while}\NormalTok{(l\textless{}=r)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(calc(mid,s[h].se)\textgreater{}calc(mid,i))ans=mid,r=mid{-}}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ l=mid+}\DecValTok{1}\NormalTok{; }
\NormalTok{    \}}
\NormalTok{    s[++h]=\{ans,i\};}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux659cux7387ux4f18ux5316}{%
\subsection{斜率优化}\label{ux659cux7387ux4f18ux5316}}

\[ f[i] = x(j) + k(i)*y(j) + b(i) \]

\(x\) , \(y\) 与 \(j\) 相关，\(k\) 与 \(i\) 相关，\(b\) 为常数/与 \(i\)
相关

\(x\) 单调 \(k\) 单调 -\textgreater{} 单调队列/单调栈 (看 \(k\) 递减/增)

\(x\) 单调 \(k\) 不单调 -\textgreater{} 单调队列上二分

\(x\) 不单调 -\textgreater{} 平衡树(请)

\hypertarget{ux56feux8bba}{%
\section{图论}\label{ux56feux8bba}}

\hypertarget{ux6811-hash}{%
\subsection{树 hash}\label{ux6811-hash}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ULL seed = }\DecValTok{13331}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ n;}
\DataTypeTok{int}\NormalTok{ sz[MAXN];}
\NormalTok{ULL f[MAXN],p[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} ve; sz[u]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}\ControlFlowTok{if}\NormalTok{(v!=fa)dfs(v,u),sz[u]+=sz[v],ve.pb(v);}
\NormalTok{    sort(all(ve),[](}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{}\ControlFlowTok{return}\NormalTok{ f[u]\textless{}f[v];\});}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}ve.size();i++)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=ve[i];}
\NormalTok{        f[u]+=f[v]*p[i];}
\NormalTok{    \}}
\NormalTok{    f[u]*=sz[u];}
    \ControlFlowTok{if}\NormalTok{(sz[u]==}\DecValTok{1}\NormalTok{)f[u]=}\DecValTok{1}\NormalTok{; }\CommentTok{// 叶子}
    \CommentTok{// cout \textless{}\textless{} dbgs2(u,f[u]) \textless{}\textless{} endl;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ init()\{p[}\DecValTok{0}\NormalTok{]=}\DecValTok{1}\NormalTok{;fp(i,}\DecValTok{1}\NormalTok{,MAXN{-}}\DecValTok{1}\NormalTok{)p[i]=p[i{-}}\DecValTok{1}\NormalTok{]*seed;\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{sat}{%
\subsection{2-sat}\label{sat}}

\(n\) 个变量 \(x[1]\) \textasciitilde{} \(x[n]\)，取值为 \(0\) 或
\(1\)，满足若干二元限制关系，判断并求出可行解。

\(x[i]\) \& \(x[j]\) = 0/1

\(x[i]\) \textbar{} \(x[j]\) = 0/1

\(x[i]\) \^{} \(x[j]\) = 0/1

\(x[i]\) = 1

\(x[i]\) = 0

建图，每个变量 \(x[i]\) 拆成两个点 \(i\) 和 \(i+n\)，代表 \(x[i]=0\) 和
\(x[i]=1\)

有向边 \(u -> v\) 表示当 \(u\) 成立时，\(v\)
一定成立，那么一条二元限制一定可以分解成若干有向边

之后缩点，判断是否存在 \(i\) 和 \(i+n\) 属于同一联通份量，若存在则无解

否则有解，\(x[i] = (bel[i]>bel[i+n])\)，\(bel\) 为缩点后的编号

\href{https://www.luogu.com.cn/problem/P4782}{luogu P4782}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{int}\NormalTok{ tim=}\DecValTok{0}\NormalTok{,num=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ low[MAXN],dfn[MAXN],bel[MAXN],siz[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN]; }\CommentTok{//in stack}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s;}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    dfn[u]=low[u]=++tim,vis[u]=}\DecValTok{1}\NormalTok{,s.pb(u);    }
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(vis[v]) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(low[u]==dfn[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur; num++;}
        \ControlFlowTok{do}\NormalTok{\{}
\NormalTok{            cur=s.back(),s.ppb();}
\NormalTok{            vis[cur]=}\DecValTok{0}\NormalTok{,bel[cur]=num,siz[num]++;}
\NormalTok{        \}}\ControlFlowTok{while}\NormalTok{(cur!=u);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{G[u].pb(v);\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x,y,a,b;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d\%d}\StringTok{"}\NormalTok{,\&x,\&a,\&y,\&b);}
        \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{0}\NormalTok{\&\&b==}\DecValTok{0}\NormalTok{)      addedge(x+n,y),addedge(y+n,x);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{0}\NormalTok{\&\&b==}\DecValTok{1}\NormalTok{) addedge(x+n,y+n),addedge(y,x);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{1}\NormalTok{\&\&b==}\DecValTok{0}\NormalTok{) addedge(x,y),addedge(y+n,x+n);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(a==}\DecValTok{1}\NormalTok{\&\&b==}\DecValTok{1}\NormalTok{) addedge(x,y+n),addedge(y,x+n);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{*n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(bel[i]==bel[i+n])}\ControlFlowTok{return}\NormalTok{ puts(}\StringTok{"IMPOSSIBLE"}\NormalTok{);}
\NormalTok{    puts(}\StringTok{"POSSIBLE"}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,bel[i]\textgreater{}bel[i+n]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\href{https://vjudge.net/problem/POJ-3678}{POJ3678}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{int}\NormalTok{ tim=}\DecValTok{0}\NormalTok{,num=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ low[MAXN],dfn[MAXN],bel[MAXN],siz[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN]; }\CommentTok{//in stack}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s;}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    dfn[u]=low[u]=++tim,vis[u]=}\DecValTok{1}\NormalTok{,s.pb(u);    }
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,G[u].size(){-}}\DecValTok{1}\NormalTok{)}
    \CommentTok{// for(auto v:G[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=G[u][i];}
        \ControlFlowTok{if}\NormalTok{(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(vis[v]) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(low[u]==dfn[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur; num++;}
        \ControlFlowTok{do}\NormalTok{\{}
\NormalTok{            cur=s.back(),s.ppb();}
\NormalTok{            vis[cur]=}\DecValTok{0}\NormalTok{,bel[cur]=num,siz[num]++;}
\NormalTok{        \}}\ControlFlowTok{while}\NormalTok{(cur!=u);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{G[u].pb(v);\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ a,b,c; }\DataTypeTok{char}\NormalTok{ op[}\DecValTok{5}\NormalTok{];}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%s}\StringTok{"}\NormalTok{,\&a,\&b,\&c,op+}\DecValTok{1}\NormalTok{),a++,b++;}
        \ControlFlowTok{if}\NormalTok{(op[}\DecValTok{1}\NormalTok{]==}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{) }\CommentTok{//and}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(c) addedge(a,a+n),addedge(b,b+n);}
            \ControlFlowTok{else}\NormalTok{  addedge(a+n,b),addedge(b+n,a);}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(op[}\DecValTok{1}\NormalTok{]==}\CharTok{\textquotesingle{}O\textquotesingle{}}\NormalTok{) }\CommentTok{//or}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(c) addedge(a,b+n),addedge(b,a+n);}
            \ControlFlowTok{else}\NormalTok{  addedge(a+n,a),addedge(b+n,b);}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{(op[}\DecValTok{1}\NormalTok{]==}\CharTok{\textquotesingle{}X\textquotesingle{}}\NormalTok{) }\CommentTok{//xor}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(c)}
\NormalTok{            \{}
\NormalTok{                addedge(a,b+n),addedge(a+n,b);}
\NormalTok{                addedge(b,a+n),addedge(b+n,a);}
\NormalTok{            \}}
            \ControlFlowTok{else}
\NormalTok{            \{}
\NormalTok{                addedge(a,b),addedge(a+n,b+n);}
\NormalTok{                addedge(b,a),addedge(b+n,a+n);}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{*n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
    \DataTypeTok{bool}\NormalTok{ flag=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)flag\&=(bel[i]!=bel[i+n]);}
\NormalTok{    puts(flag?}\StringTok{"YES"}\NormalTok{:}\StringTok{"NO"}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux652fux914dux6811}{%
\subsection{支配树}\label{ux652fux914dux6811}}

支配：以某个点为起点，当删除 u 时 v 变的不可达，则称点 u 支配了点 v

支配关系构成一种有根树，起点为根，树上每个点支配他子树的所有节点

\(idom[u]\) 最近支配点，即每个点在支配树上的父亲

\(sdom[u]\) 半支配点，即从 v 点为起点在 dfs 树上不走树边可以到达 u 的 v
中 dfn 最小的点

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,root,tim;}
\DataTypeTok{int}\NormalTok{ dfn[MAXN],sdom[MAXN],idom[MAXN],fa[MAXN],p[MAXN];}
\CommentTok{//数组下标为原图编号}
\CommentTok{//idom sdom 记录点的dfn序 其他记录原图编号}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN],V[MAXN],c[MAXN],d[MAXN];}
\CommentTok{//G正向边 V反向边 c=\{x|sdom[x]==x\} d支配树}

\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{G[u].pb(v),V[v].pb(u);\}}
\KeywordTok{namespace}\NormalTok{ dsu}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ f[MAXN],home[MAXN];}
    \CommentTok{// home[x] 记录x到根上最小的sdom所在的点}
    \DataTypeTok{int}\NormalTok{ find(}\DataTypeTok{int}\NormalTok{ x)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(x==f[x])}\ControlFlowTok{return}\NormalTok{ x;}
        \DataTypeTok{int}\NormalTok{ t=f[x];}
\NormalTok{        f[x]=find(f[x]);}
        \ControlFlowTok{if}\NormalTok{(sdom[home[t]]\textless{}sdom[home[x]])}
\NormalTok{            home[x]=home[t];}
        \ControlFlowTok{return}\NormalTok{ f[x];        }
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ get(}\DataTypeTok{int}\NormalTok{ x)\{find(x);}\ControlFlowTok{return}\NormalTok{ home[x];\}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{\{}
\NormalTok{    dfn[u]=++tim,p[tim]=u,fa[u]=par;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
        \ControlFlowTok{if}\NormalTok{(v!=par\&\&!dfn[v])}
\NormalTok{            dfs(v,u);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ ans[MAXN];}
\DataTypeTok{void}\NormalTok{ get\_ans(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{\{}
\NormalTok{    ans[u]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:d[u])}\ControlFlowTok{if}\NormalTok{(v!=par)}
\NormalTok{        get\_ans(v,u),ans[u]+=ans[v];}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        add(u,v);}
\NormalTok{    \}}
\NormalTok{    dfs(root=}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fd(i,tim,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x=p[i];}
\NormalTok{        dsu::f[x]=dsu::home[x]=x;}
\NormalTok{        sdom[x]=i;}
\NormalTok{        idom[x]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    fd(i,tim,}\DecValTok{2}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=p[i];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:V[u])}\ControlFlowTok{if}\NormalTok{(dfn[v])}
\NormalTok{            sdom[u]=min(sdom[u],sdom[dsu::get(v)]);}
\NormalTok{        c[p[sdom[u]]].pb(u);}
\NormalTok{        dsu::f[u]=fa[u];}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:c[fa[u]])}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ x=dsu::get(v);}
            \ControlFlowTok{if}\NormalTok{(sdom[x]==dfn[fa[u]])idom[v]=dfn[fa[u]];}
            \ControlFlowTok{else}\NormalTok{ idom[v]=dfn[x];}
\NormalTok{        \}}
\NormalTok{        c[fa[u]].clear();}
\NormalTok{    \}   }
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,tim)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ x=p[i];}
        \ControlFlowTok{if}\NormalTok{(sdom[x]==idom[x])idom[x]=p[idom[x]];}
        \ControlFlowTok{else}\NormalTok{ idom[x]=idom[p[idom[x]]];}
\NormalTok{        d[idom[x]].pb(x);}
        \CommentTok{// cout \textless{}\textless{} dbgs2(idom[x],x) \textless{}\textless{} endl;}
\NormalTok{    \}}
\NormalTok{    get\_ans(root,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,ans[i]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux865aux6811}{%
\subsection{虚树}\label{ux865aux6811}}

模板

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ virtual\_tree }\CommentTok{//虚树}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ *inner\_dfn;}

    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u, }\DataTypeTok{int}\NormalTok{ fa, graph \&G)}
\NormalTok{    \{}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = G.pre[u]; i; i = G.e[i].next)}
            \ControlFlowTok{if}\NormalTok{ (G.e[i].to != fa)}
\NormalTok{                dfs(G.e[i].to, u, G);}
\NormalTok{        G.pre[u] = }\DecValTok{0}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ clear\_edge(}\DataTypeTok{int}\NormalTok{ root, graph \&G) \{ G.ecnt = }\DecValTok{0}\NormalTok{, dfs(root, {-}}\DecValTok{1}\NormalTok{, G); \}}
    \CommentTok{//别用memset 手动清边表保证复杂度}

    \KeywordTok{typedef} \DataTypeTok{int}\NormalTok{ func(}\DataTypeTok{int}\NormalTok{ u, }\DataTypeTok{int}\NormalTok{ v);}
    \DataTypeTok{bool}\NormalTok{ cmp(}\DataTypeTok{int}\NormalTok{ u, }\DataTypeTok{int}\NormalTok{ v) \{ }\ControlFlowTok{return}\NormalTok{ inner\_dfn[u] \textless{} inner\_dfn[v]; \}}

    \CommentTok{//建立虚树 返回dfn最小的节点 需预处理出dfs序(dfn[])与get\_lca函数}
    \DataTypeTok{int}\NormalTok{ build\_virtual\_tree(vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} \&p, }\DataTypeTok{int}\NormalTok{ dfn[], graph \&G, func get\_lca, }\DataTypeTok{int}\NormalTok{ s[])}
\NormalTok{    \{}
\NormalTok{        inner\_dfn = dfn;}
\NormalTok{        p.push\_back(}\DecValTok{1}\NormalTok{); }\CommentTok{//默认加入1作为根节点}
\NormalTok{        sort(p.begin(), p.end());}
\NormalTok{        p.erase(unique(p.begin(), p.end()), p.end());}
\NormalTok{        sort(p.begin(), p.end(), cmp);}

        \CommentTok{//使用 栈s 保存树链}
        \DataTypeTok{int}\NormalTok{ top = }\DecValTok{0}\NormalTok{;}
\NormalTok{        s[++top] = p.front();}

        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i \textless{} p.size(); i++)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ \&cur = p[i], lca = get\_lca(cur, s[top]);}
            \ControlFlowTok{if}\NormalTok{ (lca == s[top]) s[++top] = cur; }\CommentTok{//当前节点可以加入到链的尾部}
            \ControlFlowTok{else} \CommentTok{//栈中所表示的树链已经有一部分处理完了 退栈并连边}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ t = top;}
                \ControlFlowTok{while}\NormalTok{ (dfn[s[t]] \textgreater{} dfn[lca]) t{-}{-};}
                \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ j = t + }\DecValTok{1}\NormalTok{; j \textless{} top; j++)}
\NormalTok{                    G.add\_edge(s[j], s[j + }\DecValTok{1}\NormalTok{], }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{);}
\NormalTok{                top = t, G.add\_edge(lca, s[top + }\DecValTok{1}\NormalTok{], }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{);}
                \ControlFlowTok{if}\NormalTok{ (s[top] != lca) s[++top] = lca;}
\NormalTok{                s[++top] = cur;}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i \textless{} top; i++)}
\NormalTok{            G.add\_edge(s[i], s[i + }\DecValTok{1}\NormalTok{], }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{return}\NormalTok{ s[}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{kruskalux91cdux6784ux6811}{%
\subsection{Kruskal重构树}\label{kruskalux91cdux6784ux6811}}

\hypertarget{ux8d44ux6599-8}{%
\subsubsection{资料}\label{ux8d44ux6599-8}}

\href{https://www.cnblogs.com/zwfymqz/p/9683523.html}{Kruskal重构树入门
自为风月马前卒}

\hypertarget{ux6a21ux677f-15}{%
\subsubsection{模板}\label{ux6a21ux677f-15}}

构建方法：初始时有 \(n\) 个叶子节点，运行 \(kruskal\)
最小生成树算法，对于用边权为 \(w\) 连接两个节点 \((u,v)\),
新建一个权值为 \(w\) 的节点 \(x\)，并连边 \((x,root(u))\) 和
\((x,root(v))\), 并将 \(x\) 置为这颗树的根节点。

这样建出来的其实是一个大根堆，可以用来求从点 \(x\) 出发只走边权 \(<=w\)
的边能到达的点的极大集合

做法就是从 \(x\) 倍增往上面跳直到点权 \(>w\)，设跳到的点为 \(u\)，那么
\(u\) 的所有叶子就是所求的极大集合

还有一个性质是：任意两个点路径上边权的最大值为它们的LCA的点权

\hypertarget{ux4f8bux9898-1}{%
\subsubsection{例题}\label{ux4f8bux9898-1}}

\href{http://www.lydsy.com/JudgeOnline/problem.php?id=3551}{Peaks加强版}

\begin{quote}
在Bytemountains有N座山峰，每座山峰有他的高度hi。

有些山峰之间有双向道路相连，共M条路径，每条路径有一个困难值，这个值越大表示越难走.

现在有Q组询问，每组询问询问从点v开始只经过困难值小于等于x的路径所能到达的山峰中第k高的山峰，如果无解输出−1
\end{quote}

kruskal重构树 + 主席树

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} X;}
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,m,q,cnt,last={-}}\DecValTok{1}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ h[MAXN],a[MAXN],b[MAXN],fa[MAXN],st[MAXN],ed[MAXN],f[MAXN][}\DecValTok{21}\NormalTok{];}
\KeywordTok{struct}\NormalTok{ temp\{}\DataTypeTok{int}\NormalTok{ u,v,w;\}edg[N];}
\DataTypeTok{int}\NormalTok{ find(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ fa[x]==x?x:fa[x]=find(fa[x]);\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    st[u]=++cnt,b[cnt]=h[u],f[u][}\DecValTok{0}\NormalTok{]=fa;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)dfs(v,u);}
\NormalTok{    ed[u]=cnt;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ root[MAXN],s[MAXN*}\DecValTok{10}\NormalTok{],ls[MAXN*}\DecValTok{10}\NormalTok{],rs[MAXN*}\DecValTok{10}\NormalTok{],}\VariableTok{cnt\_}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ \&rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ pos)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!rt)rt=++}\VariableTok{cnt\_}\NormalTok{; s[rt]=s[pre]+}\DecValTok{1}\NormalTok{; }\ControlFlowTok{if}\NormalTok{(l==r)}\ControlFlowTok{return}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(pos\textless{}=mid)update(ls[pre],ls[rt],l,mid,pos),rs[rt]=rs[pre];}
    \ControlFlowTok{else}\NormalTok{ update(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,pos),ls[rt]=ls[pre];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ pre,}\DataTypeTok{int}\NormalTok{ rt,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(l==r)\{printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,X[l{-}}\DecValTok{1}\NormalTok{]),last=X[l{-}}\DecValTok{1}\NormalTok{];}\ControlFlowTok{return}\NormalTok{;\}}
    \DataTypeTok{int}\NormalTok{ sum=s[rs[rt]]{-}s[rs[pre]];}
    \ControlFlowTok{if}\NormalTok{(sum\textgreater{}=k)query(rs[pre],rs[rt],mid+}\DecValTok{1}\NormalTok{,r,k);}
    \ControlFlowTok{else}\NormalTok{ query(ls[pre],ls[rt],l,mid,k{-}sum);}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ cmp(}\AttributeTok{const}\NormalTok{ temp \&a,}\AttributeTok{const}\NormalTok{ temp \&b)\{}\ControlFlowTok{return}\NormalTok{ a.w\textless{}b.w;\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m,\&q);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&h[i]),X.pb(h[i]); sort(all(X)),unq(X);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)h[i]=lb(all(X),h[i]){-}X.begin()+}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{*n)fa[i]=i;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&edg[i].u,\&edg[i].v,\&edg[i].w);}
\NormalTok{    sort(edg+}\DecValTok{1}\NormalTok{,edg+}\DecValTok{1}\NormalTok{+m,cmp);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}\ControlFlowTok{if}\NormalTok{(find(edg[i].u)!=find(edg[i].v))}
\NormalTok{    \{}
\NormalTok{        a[++n]=edg[i].w; }\DataTypeTok{int}\NormalTok{ fu=find(edg[i].u),fv=find(edg[i].v);}
\NormalTok{        addedge(n,fu),addedge(n,fv),fa[fu]=fa[fv]=n;}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!st[i])dfs(find(i),}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(j,}\DecValTok{1}\NormalTok{,}\DecValTok{20}\NormalTok{)fp(i,}\DecValTok{1}\NormalTok{,n)f[i][j]=f[f[i][j{-}}\DecValTok{1}\NormalTok{]][j{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
        \ControlFlowTok{if}\NormalTok{(b[i])update(root[i{-}}\DecValTok{1}\NormalTok{],root[i],}\DecValTok{1}\NormalTok{,X.size(),b[i]);}
        \ControlFlowTok{else}\NormalTok{ root[i]=root[i{-}}\DecValTok{1}\NormalTok{];}
    \ControlFlowTok{while}\NormalTok{(q{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,x,k;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&u,\&x,\&k);}
        \ControlFlowTok{if}\NormalTok{(last!={-}}\DecValTok{1}\NormalTok{)u\^{}=last,x\^{}=last,k\^{}=last;}
\NormalTok{        fd(i,}\DecValTok{20}\NormalTok{,}\DecValTok{0}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(f[u][i]\&\&a[f[u][i]]\textless{}=x)u=f[u][i];}
        \DataTypeTok{int}\NormalTok{ l=st[u],r=ed[u];}
        \ControlFlowTok{if}\NormalTok{(s[root[r]]{-}s[root[l{-}}\DecValTok{1}\NormalTok{]]\textless{}k)printf(}\StringTok{"{-}1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{),last={-}}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ query(root[l{-}}\DecValTok{1}\NormalTok{],root[r],}\DecValTok{1}\NormalTok{,X.size(),k);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4f20ux9012ux95edux5305}{%
\subsection{传递闭包}\label{ux4f20ux9012ux95edux5305}}

若有关系 a-\textgreater b 和 b-\textgreater c，则有关系 a-\textgreater c

初始给定相邻的关系，求最终的关系矩阵

bitset 优化 floyd，\(O(n^3/64)\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fp(k,}\DecValTok{1}\NormalTok{,n)fp(i,}\DecValTok{1}\NormalTok{,n)}
    \ControlFlowTok{if}\NormalTok{(f[i][k])f[i]|=f[k];}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6700ux5c0fux73af}{%
\subsection{最小环}\label{ux6700ux5c0fux73af}}

\hypertarget{ux65e0ux8fb9ux6743}{%
\subsubsection{无边权}\label{ux65e0ux8fb9ux6743}}

bfs O(n\^{}2+nm)

考虑枚举每个点为起点做一遍
bfs，当搜索树上出现平行边或前向边的时候更新答案

需特判自环

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ bfs(}\DataTypeTok{int}\NormalTok{ S)}
\NormalTok{\{}
\NormalTok{    queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q; mst(dis,}\DecValTok{0}\NormalTok{),dis[S]=inq[S]=}\DecValTok{1}\NormalTok{,q.push(S);}
    \DataTypeTok{int}\NormalTok{ aa=}\DecValTok{0}\NormalTok{,bb=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q.front(); q.pop(); inq[u]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        go(u)}
            \ControlFlowTok{if}\NormalTok{(!dis[v])dis[v]=dis[u]+}\DecValTok{1}\NormalTok{,q.push(v),inq[v]=}\DecValTok{1}\NormalTok{;}
            \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(inq[v])ans=min(ans,dis[u]+dis[v]{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)bfs(i);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6709ux8fb9ux6743}{%
\subsubsection{有边权}\label{ux6709ux8fb9ux6743}}

floyd n\^{}3

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,ans=inf;}
\DataTypeTok{int}\NormalTok{ d[MAXN][MAXN],w[MAXN][MAXN];}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)fp(j,}\DecValTok{1}\NormalTok{,n)w[i][j]=inf;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)w[i][i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v,x;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v,\&x);}
\NormalTok{        w[u][v]=min(w[u][v],x);}
\NormalTok{        w[v][u]=min(w[v][u],x);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)fp(j,}\DecValTok{1}\NormalTok{,n)d[i][j]=w[i][j];}
\NormalTok{    fp(k,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,k{-}}\DecValTok{1}\NormalTok{)fp(j,}\DecValTok{1}\NormalTok{,k{-}}\DecValTok{1}\NormalTok{)}\ControlFlowTok{if}\NormalTok{(i!=j)ans=min(ans,d[i][j]+w[i][k]+w[j][k]);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)fp(j,}\DecValTok{1}\NormalTok{,n)d[i][j]=min(d[i][j],d[i][k]+d[k][j]);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(ans==inf)puts(}\StringTok{"No solution."}\NormalTok{);}
    \ControlFlowTok{else}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{km}{%
\subsection{KM}\label{km}}

O(n\^{}3)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{LL w[MAXN][MAXN],lx[MAXN],ly[MAXN],slack[MAXN];}
\DataTypeTok{int}\NormalTok{ lk[MAXN],pre[MAXN];}
\DataTypeTok{bool}\NormalTok{ visy[MAXN];}
\DataTypeTok{void}\NormalTok{ bfs(}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x=}\DecValTok{0}\NormalTok{,y=}\DecValTok{0}\NormalTok{,yy=}\DecValTok{0}\NormalTok{; LL delta;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)slack[i]=linf;}
\NormalTok{    mst(pre,}\DecValTok{0}\NormalTok{),lk[y]=k;}
    \ControlFlowTok{while}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        x=lk[y],delta=linf,visy[y]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!visy[i])}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(slack[i]\textgreater{}lx[x]+ly[i]{-}w[x][i])}
\NormalTok{                slack[i]=lx[x]+ly[i]{-}w[x][i],pre[i]=y; }
            \ControlFlowTok{if}\NormalTok{(slack[i]\textless{}delta) delta=slack[i],yy=i;}
\NormalTok{        \}}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,n)}
            \ControlFlowTok{if}\NormalTok{(visy[i]) lx[lk[i]]{-}=delta,ly[i]+=delta;}
            \ControlFlowTok{else}\NormalTok{ slack[i]{-}=delta;}
\NormalTok{        y=yy;}
        \ControlFlowTok{if}\NormalTok{(lk[y]=={-}}\DecValTok{1}\NormalTok{) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{while}\NormalTok{(y) lk[y]=lk[pre[y]],y=pre[y];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    mst(lx,}\DecValTok{0}\NormalTok{),mst(ly,}\DecValTok{0}\NormalTok{),mst(lk,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) mst(visy,}\DecValTok{0}\NormalTok{),bfs(i);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n)!=EOF)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)fp(j,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{"}\NormalTok{,\&w[i][j]);}
\NormalTok{        solve();}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)ans+=lx[i]+ly[i];}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ Case = }\DecValTok{0}\NormalTok{;}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{tarjan}{%
\subsection{tarjan}\label{tarjan}}

\hypertarget{ux65e0ux5411ux56fe-ux5272ux70b9}{%
\subsubsection{1.无向图 割点}\label{ux65e0ux5411ux56fe-ux5272ux70b9}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} ans;}

\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ fa[MAXN],dfn[MAXN],low[MAXN],tim;}
\DataTypeTok{int}\NormalTok{ pre[MAXN];}

\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{e.pb(\{u,v,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}

\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ child=}\DecValTok{0}\NormalTok{;}
    \DataTypeTok{bool}\NormalTok{ flag=}\DecValTok{0}\NormalTok{;}
\NormalTok{    dfn[u]=low[u]=++tim;}
\NormalTok{    go(u)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{        \{}
\NormalTok{            fa[v]=u,tarjan(v);}
\NormalTok{            low[u]=min(low[u],low[v]);}
\NormalTok{            child++;}
            \ControlFlowTok{if}\NormalTok{(fa[u]) flag|=(low[v]\textgreater{}=dfn[u]);}
            \ControlFlowTok{else}\NormalTok{ flag|=(child\textgreater{}=}\DecValTok{2}\NormalTok{);}
\NormalTok{        \}}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(fa[u]!=v) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(flag) ans.pb(u);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    ans.clear();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
\NormalTok{    sort(all(ans));}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans.size());}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ u:ans) printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,u);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    io.read(n),io.read(m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{        io.read(u),io.read(v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    solve();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux65e0ux5411ux56fe-ux5272ux8fb9}{%
\subsubsection{2.无向图 割边}\label{ux65e0ux5411ux56fe-ux5272ux8fb9}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ edge}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ u,v;}
    \DataTypeTok{bool}\NormalTok{ flag;}
\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ fa[MAXN],dfn[MAXN],low[MAXN],tim;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{}  G[MAXN],ans;}
\NormalTok{vector\textless{}edge\textgreater{} e;}
\NormalTok{map\textless{}pr,}\DataTypeTok{int}\NormalTok{\textgreater{} h; }\CommentTok{//判重边}

\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    dfn[u]=low[u]=++tim;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ i:G[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=(e[i].u==u)?e[i].v:e[i].u;}
        \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{        \{}
\NormalTok{            fa[v]=u;}
\NormalTok{            tarjan(v);}
\NormalTok{            low[u]=min(low[u],low[v]);}
            \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}dfn[u]\&\&!e[i].flag)}
\NormalTok{                ans.pb(i+}\DecValTok{1}\NormalTok{);}
\NormalTok{        \}}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(fa[u]!=v) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    e.clear(),h.clear(),tim=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) G[i].clear();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) dfn[i]=low[i]=fa[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    ans.clear();}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&t:e)}\ControlFlowTok{if}\NormalTok{(h[\{t.u,t.v\}]\textgreater{}}\DecValTok{1}\NormalTok{)t.flag=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
\NormalTok{    sort(all(ans));}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans.size());}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{0}\NormalTok{;i\textless{}ans.size();i++)}
\NormalTok{    \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,ans[i]);}
\NormalTok{        putchar(i==ans.size(){-}}\DecValTok{1}\NormalTok{?}\CharTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n}\CharTok{\textquotesingle{}}\NormalTok{:}\CharTok{\textquotesingle{} \textquotesingle{}}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ T;}
\NormalTok{    io.read(T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
\NormalTok{        io.read(n),io.read(m),init();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{            io.read(u),io.read(v);}
            \ControlFlowTok{if}\NormalTok{(u\textgreater{}v) swap(u,v);}
\NormalTok{            e.pb(\{u,v,}\DecValTok{0}\NormalTok{\});}
\NormalTok{            G[u].pb(e.size(){-}}\DecValTok{1}\NormalTok{);}
\NormalTok{            G[v].pb(e.size(){-}}\DecValTok{1}\NormalTok{);}
\NormalTok{            h[\{u,v\}]++;}
\NormalTok{        \}}
\NormalTok{        solve();}
        \ControlFlowTok{if}\NormalTok{(T) printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux65e0ux5411ux56fe-ux70b9ux53ccux7f29ux70b9}{%
\subsubsection{3.无向图
点双缩点}\label{ux65e0ux5411ux56fe-ux70b9ux53ccux7f29ux70b9}}

\hypertarget{ux65e0ux5411ux56fe-ux8fb9ux53ccux7f29ux70b9}{%
\subsubsection{4.无向图
边双缩点}\label{ux65e0ux5411ux56fe-ux8fb9ux53ccux7f29ux70b9}}

例题：\href{https://www.acwing.com/problem/content/399/}{逃不掉的路}

边双连通分量： 不包含桥 或 任意两点都存在至少两条独立路可以相互到达 的图

求法：去掉所有桥后能互达的点构成一个边双分量

缩点之后不存在环，是一棵树

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ edge}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ u,v;}
    \DataTypeTok{bool}\NormalTok{ flag;}
    \DataTypeTok{bool}\NormalTok{ isBridge;}
\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ n,m,q;}
\DataTypeTok{int}\NormalTok{ fa[MAXN],dfn[MAXN],low[MAXN],tim;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{}  G[MAXN],M[XN];}
\NormalTok{vector\textless{}edge\textgreater{} e;}
\NormalTok{map\textless{}pr,}\DataTypeTok{int}\NormalTok{\textgreater{} h; }\CommentTok{//判重边}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    dfn[u]=low[u]=++tim;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ i:G[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=(e[i].u==u)?e[i].v:e[i].u;}
        \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{        \{}
\NormalTok{            fa[v]=u;}
\NormalTok{            tarjan(v);}
\NormalTok{            low[u]=min(low[u],low[v]);}
            \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}dfn[u]\&\&!e[i].flag)}
\NormalTok{                e[i].isBridge=}\DecValTok{1}\NormalTok{;}
\NormalTok{        \}}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(fa[u]!=v) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ cnt,bel[MAXN];}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!bel[u]) bel[u]=cnt;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ i:G[u])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(e[i].isBridge) }\ControlFlowTok{continue}\NormalTok{;}
        \DataTypeTok{int}\NormalTok{ v=(e[i].u==u)?e[i].v:e[i].u;}
        \ControlFlowTok{if}\NormalTok{(!bel[v]) dfs(v);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ \&t:e)}\ControlFlowTok{if}\NormalTok{(h[\{t.u,t.v\}]\textgreater{}}\DecValTok{1}\NormalTok{)t.flag=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!bel[i])cnt++,dfs(i);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ t:e) }\CommentTok{//建图}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ \&u=bel[t.u],\&v=bel[t.v];}
        \ControlFlowTok{if}\NormalTok{(v!=u) M[u].pb(v),M[v].pb(u);}
\NormalTok{    \}}
    \CommentTok{//lca::init();}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
        \ControlFlowTok{if}\NormalTok{(u\textgreater{}v) swap(u,v);}
\NormalTok{        e.pb(\{u,v,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\});}
\NormalTok{        G[u].pb(e.size(){-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        G[v].pb(e.size(){-}}\DecValTok{1}\NormalTok{);}
\NormalTok{        h[\{u,v\}]++;}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6709ux5411ux56feux5f3aux8fdeux901aux5206ux91cfux7f29ux70b9}{%
\subsubsection{5.有向图强连通分量缩点}\label{ux6709ux5411ux56feux5f3aux8fdeux901aux5206ux91cfux7f29ux70b9}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{int}\NormalTok{ tim=}\DecValTok{0}\NormalTok{,num=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ low[MAXN],dfn[MAXN],bel[MAXN],siz[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN]; }\CommentTok{//in stack}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s;}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    s.clear();}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)low[i]=dfn[i]=bel[i]=siz[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)G[i].clear(); q}
\NormalTok{    tim=num=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    dfn[u]=low[u]=++tim,vis[u]=}\DecValTok{1}\NormalTok{,s.pb(u);    }
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!dfn[v]) tarjan(v),low[u]=min(low[u],low[v]);}
        \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{(vis[v]) low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(low[u]==dfn[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ cur; num++;}
        \ControlFlowTok{do}\NormalTok{\{}
\NormalTok{            cur=s.back(),s.ppb();}
\NormalTok{            vis[cur]=}\DecValTok{0}\NormalTok{,bel[cur]=num,siz[num]++;}
\NormalTok{        \}}\ControlFlowTok{while}\NormalTok{(cur!=u);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ d[MAXN];}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!dfn[i])tarjan(i);}
\NormalTok{    fp(u,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])}
        \ControlFlowTok{if}\NormalTok{(bel[u]!=bel[v])}
\NormalTok{            d[bel[u]]++;}
    \DataTypeTok{int}\NormalTok{ ans;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,num)}\ControlFlowTok{if}\NormalTok{(!d[i])ans=i;}
    \ControlFlowTok{if}\NormalTok{(siz[ans]==n) puts(}\StringTok{"No"}\NormalTok{);}
    \ControlFlowTok{else}
\NormalTok{    \{}
\NormalTok{        puts(}\StringTok{"Yes"}\NormalTok{);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ }\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,siz[ans],n{-}siz[ans]);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(bel[i]==ans)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,i);printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(bel[i]!=ans)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,i);printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5904ux7406ux4ed9ux4ebaux638c}{%
\subsection{处理仙人掌}\label{ux5904ux7406ux4ed9ux4ebaux638c}}

仙人掌找环：

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ build()}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(a.size()==}\DecValTok{2}\NormalTok{) }\CommentTok{//树边}
\NormalTok{    \{}
\NormalTok{        ...}
\NormalTok{    \}}
    \ControlFlowTok{else} \CommentTok{//环}
\NormalTok{    \{}
\NormalTok{        ...}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    low[u]=dfn[u]=++tim,s.pb(u);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ e:G1[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e.fi;}
        \ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{            \{}
\NormalTok{                tarjan(v,u),low[u]=min(low[u],low[v]);}
                \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}=dfn[u])}
\NormalTok{                \{}
\NormalTok{                    a.clear(); }\ControlFlowTok{while}\NormalTok{(!s.empty()\&\&s.back()!=v)a.pb(s.back()),s.ppb();}
\NormalTok{                    a.pb(s.back()),s.ppb(),a.pb(u),reverse(all(a)),build();}
\NormalTok{                \}}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ low[u]=min(low[u],dfn[v]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6c42ux73afux5916ux5206ux652fux5927ux5c0f}{%
\subsubsection{求环外分支大小}\label{ux6c42ux73afux5916ux5206ux652fux5927ux5c0f}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,tim;}
\DataTypeTok{int}\NormalTok{ dfn[MAXN],low[MAXN],sz[MAXN];}
\NormalTok{LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s,a;}
\DataTypeTok{void}\NormalTok{ solve(vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} \&a)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(a.size()==}\DecValTok{2}\NormalTok{)}\ControlFlowTok{return} \DataTypeTok{void}\NormalTok{(ans=(ans+}\DecValTok{1}\BuiltInTok{LL}\NormalTok{*a[}\DecValTok{0}\NormalTok{]*a[}\DecValTok{1}\NormalTok{]\%MOD)\%MOD); }\CommentTok{// 树边}
    \CommentTok{// 环边    }
    \DataTypeTok{int}\NormalTok{ len=a.size(); LL s=}\DecValTok{0}\NormalTok{,sj=}\DecValTok{0}\NormalTok{,sjj=}\DecValTok{0}\NormalTok{,ans=}\DecValTok{0}\NormalTok{; }
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,a.size(){-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        LL si=a[i];}

\NormalTok{        ans+=si*i\%MOD*len\%MOD*s\%MOD,ans\%=MOD;}
\NormalTok{        ans{-}=si*i\%MOD*i\%MOD*s\%MOD,ans\%=MOD;}
\NormalTok{        ans+=si*i\%MOD*sj\%MOD,ans\%=MOD;}
\NormalTok{        ans{-}=si*len\%MOD*sj\%MOD,ans\%=MOD;}
\NormalTok{        ans+=si*i\%MOD*sj\%MOD,ans\%=MOD;}
\NormalTok{        ans{-}=si*sjj\%MOD,ans\%=MOD;}
        
\NormalTok{        s+=si,sj+=si*i\%MOD,sjj+=si*i\%MOD*i\%MOD,s\%=MOD,sj\%=MOD,sjj\%=MOD;}
\NormalTok{    \}}
\NormalTok{    ans*=inv(len),ans\%=MOD,::ans+=ans,::ans\%=MOD; }\ControlFlowTok{return}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    low[u]=dfn[u]=++tim,sz[u]=}\DecValTok{1}\NormalTok{,s.pb(u);}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{        \{}
\NormalTok{            dfs(v,u),low[u]=min(low[u],low[v]);}
            \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}=dfn[u])}
\NormalTok{            \{}
\NormalTok{                a.clear(); }\DataTypeTok{int}\NormalTok{ left=n;}
                \ControlFlowTok{while}\NormalTok{(!s.empty()\&\&s.back()!=v)}
\NormalTok{                    sz[u]+=sz[s.back()],}
\NormalTok{                    a.pb(sz[s.back()]), }\CommentTok{// a.pb(s.back()),}
\NormalTok{                    left{-}=sz[s.back()],}
\NormalTok{                    s.ppb();}
                
\NormalTok{                sz[u]+=sz[s.back()],}
\NormalTok{                a.pb(sz[s.back()]), }\CommentTok{// a.pb(s.back()),}
\NormalTok{                left{-}=sz[s.back()],}
\NormalTok{                s.ppb();}

\NormalTok{                a.pb(left), }\CommentTok{// a.pb(u),}
\NormalTok{                solve(a);}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    MC}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{        edge\_cnt=tim=ans=}\DecValTok{0}\NormalTok{,mst(pre,}\DecValTok{0}\NormalTok{),mst(dfn,}\DecValTok{0}\NormalTok{),mst(low,}\DecValTok{0}\NormalTok{),s.clear();}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{            addedge(u,v),addedge(v,u);}
\NormalTok{        \}}
\NormalTok{        dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{),printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,(ans\%MOD+MOD)\%MOD);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4ed9ux4ebaux638cux6700ux77edux8def}{%
\subsubsection{仙人掌最短路}\label{ux4ed9ux4ebaux638cux6700ux77edux8def}}

考虑将仙人掌缩成(有根)园方树，原点到原点的边权不变，原点到方点的距离为0，方点
\(u\) 到原点 \(v\) 的距离为环上 \(v\) 到 \(fa[u]\) 的最短路。

求两点最短路首先求lca，若lca是原点则直接输出距离，若是方点则输出
dis(tu,u)+dis(tv,v)+(u,v)两点在环上的最短路距离。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,q,tim,sz;}
\NormalTok{vector\textless{}pr\textgreater{} G1[MAXN],G2[MAXN];}
\NormalTok{map\textless{}pr,}\DataTypeTok{int}\NormalTok{\textgreater{} weight;}
\NormalTok{unordered\_map\textless{}}\DataTypeTok{int}\NormalTok{,}\DataTypeTok{int}\NormalTok{\textgreater{} pos[MAXN];}
\DataTypeTok{int}\NormalTok{ f[MAXN][}\DecValTok{25}\NormalTok{],low[MAXN],dfn[MAXN],sum[MAXN],d[MAXN],h[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} s,a,pre[MAXN];}
\DataTypeTok{int}\NormalTok{ dis(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)\{}\ControlFlowTok{return}\NormalTok{ weight[\{min(u,v),max(u,v)\}];\}}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ w,vector\textless{}pr\textgreater{} G[MAXN])\{G[u].pb(\{v,w\}),G[v].pb(\{u,w\});\}}
\DataTypeTok{void}\NormalTok{ build()}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(a.size()==}\DecValTok{2}\NormalTok{)}\ControlFlowTok{return}\NormalTok{ addedge(a[}\DecValTok{0}\NormalTok{],a[}\DecValTok{1}\NormalTok{],dis(a[}\DecValTok{0}\NormalTok{],a[}\DecValTok{1}\NormalTok{]),G2);}
\NormalTok{    ++n,pre[n].resize(a.size());}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,pre[n].size(){-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ d=dis(a[i],a[i{-}}\DecValTok{1}\NormalTok{]);}
\NormalTok{        pre[n][i]=pre[n][i{-}}\DecValTok{1}\NormalTok{]+d;}
\NormalTok{        sum[n]+=d;}
\NormalTok{    \}}
\NormalTok{    sum[n]+=dis(a[}\DecValTok{0}\NormalTok{],a.back());}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,a.size(){-}}\DecValTok{1}\NormalTok{)}
\NormalTok{        addedge(n,a[i],min(pre[n][i],sum[n]{-}pre[n][i]),G2);    }
\NormalTok{    addedge(a[}\DecValTok{0}\NormalTok{],n,}\DecValTok{0}\NormalTok{,G2);}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,a.size(){-}}\DecValTok{1}\NormalTok{)pos[n][a[i]]=pre[n][i];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ tarjan(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    low[u]=dfn[u]=++tim,s.pb(u);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ e:G1[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e.fi;}
        \ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{            \{}
\NormalTok{                tarjan(v,u),low[u]=min(low[u],low[v]);}
                \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}=dfn[u])}
\NormalTok{                \{}
\NormalTok{                    a.clear(); }\ControlFlowTok{while}\NormalTok{(!s.empty()\&\&s.back()!=v)a.pb(s.back()),s.ppb();}
\NormalTok{                    a.pb(s.back()),s.ppb(),a.pb(u),reverse(all(a)),build();}
\NormalTok{                \}}
\NormalTok{            \}}
            \ControlFlowTok{else}\NormalTok{ low[u]=min(low[u],dfn[v]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ par)}
\NormalTok{\{}
\NormalTok{    f[u][}\DecValTok{0}\NormalTok{]=par,h[u]=h[par]+}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ e:G2[u])}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e.fi,w=e.se;}
        \ControlFlowTok{if}\NormalTok{(v!=par)}
\NormalTok{        \{}
\NormalTok{            d[v]=d[u]+w,dfs(v,u);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ dis(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ sq)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ d=abs(pos[sq][u]{-}pos[sq][v]);}
    \ControlFlowTok{return}\NormalTok{ min(d,sum[sq]{-}d);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ tu=u,tv=v; }\ControlFlowTok{if}\NormalTok{(h[u]\textless{}h[v]) swap(u,v),swap(tu,tv);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=log2(h[u])+}\DecValTok{1}\NormalTok{;k\textgreater{}=}\DecValTok{0}\NormalTok{;k{-}{-})}
        \ControlFlowTok{if}\NormalTok{(h[f[u][k]]\textgreater{}=h[v])}
\NormalTok{            u=f[u][k];}
    \ControlFlowTok{if}\NormalTok{(u==v) }\ControlFlowTok{return}\NormalTok{ d[tu]{-}d[tv];}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=log2(h[u])+}\DecValTok{1}\NormalTok{;k\textgreater{}=}\DecValTok{0}\NormalTok{;k{-}{-})}
        \ControlFlowTok{if}\NormalTok{(f[u][k]!=f[v][k])}
\NormalTok{            u=f[u][k],v=f[v][k];}
    \DataTypeTok{int}\NormalTok{ l=f[u][}\DecValTok{0}\NormalTok{];}
    \ControlFlowTok{if}\NormalTok{(l\textless{}=sz)}\ControlFlowTok{return}\NormalTok{ d[tu]+d[tv]{-}}\DecValTok{2}\NormalTok{*d[l];}
    \ControlFlowTok{return}\NormalTok{ d[tu]{-}d[u]+d[tv]{-}d[v]+dis(u,v,f[u][}\DecValTok{0}\NormalTok{]);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m,\&q),sz=n;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v,w;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v,\&w);}
        \ControlFlowTok{if}\NormalTok{(u\textgreater{}v)swap(u,v);addedge(u,v,w,G1),weight[\{u,v\}]=w;}
\NormalTok{    \}}
\NormalTok{    tarjan(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{),dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=}\DecValTok{1}\NormalTok{;k\textless{}=}\DecValTok{20}\NormalTok{;k++)}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{            f[i][k]=f[f[i][k{-}}\DecValTok{1}\NormalTok{]][k{-}}\DecValTok{1}\NormalTok{];}
    \ControlFlowTok{while}\NormalTok{(q{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,query(u,v));}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4ed9ux4ebaux638cux76f4ux5f84}{%
\subsubsection{仙人掌直径}\label{ux4ed9ux4ebaux638cux76f4ux5f84}}

定义仙人掌上两点距离为他们之间的最短路，求仙人掌的直径

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,N*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,m,tim,ans=}\DecValTok{0}\NormalTok{;}
\DataTypeTok{int}\NormalTok{ low[MAXN],dfn[MAXN],f[MAXN],t[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} a,s;}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(a.size()==}\DecValTok{2}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        ans=max(ans,f[a[}\DecValTok{0}\NormalTok{]]+f[a[}\DecValTok{1}\NormalTok{]]+}\DecValTok{1}\NormalTok{);}
\NormalTok{        f[a[}\DecValTok{0}\NormalTok{]]=max(f[a[}\DecValTok{0}\NormalTok{]],f[a[}\DecValTok{1}\NormalTok{]]+}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{return}\NormalTok{;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ len=a.size();}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,len{-}}\DecValTok{1}\NormalTok{)a.pb(a[i]);}
\NormalTok{    deque\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,a.size(){-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(!q.empty()\&\&i{-}q.front()\textgreater{}len/}\DecValTok{2}\NormalTok{)q.ppf();}
        \ControlFlowTok{if}\NormalTok{(!q.empty())\{}\DataTypeTok{int}\NormalTok{ j=q.front();ans=max(ans,f[a[i]]+i{-}j+f[a[j]]);\}}
        \ControlFlowTok{while}\NormalTok{(!q.empty()\&\&f[a[i]]{-}i\textgreater{}=f[a[q.back()]]{-}q.back())q.ppb();q.pb(i);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,len{-}}\DecValTok{1}\NormalTok{)f[a[}\DecValTok{0}\NormalTok{]]=max(f[a[}\DecValTok{0}\NormalTok{]],f[a[i]]+min(i,len{-}i));}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    low[u]=dfn[u]=++tim,s.pb(u);}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!dfn[v])}
\NormalTok{        \{}
\NormalTok{            dfs(v,u),low[u]=min(low[u],low[v]);}
            \ControlFlowTok{if}\NormalTok{(low[v]\textgreater{}=dfn[u])}
\NormalTok{            \{}
\NormalTok{                a.clear();}\ControlFlowTok{while}\NormalTok{(!s.empty()\&\&s.back()!=v)a.pb(s.back()),s.ppb();}
\NormalTok{                a.pb(s.back()),s.ppb(),a.pb(u),reverse(all(a)),solve();}
\NormalTok{            \}}
\NormalTok{        \}}
        \ControlFlowTok{else}\NormalTok{ low[u]=min(low[u],dfn[v]);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ k;scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&k);}
\NormalTok{        fp(j,}\DecValTok{1}\NormalTok{,k)}
\NormalTok{        \{}
\NormalTok{            scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&t[j]);}
            \ControlFlowTok{if}\NormalTok{(j!=}\DecValTok{1}\NormalTok{)addedge(t[j],t[j{-}}\DecValTok{1}\NormalTok{]),addedge(t[j{-}}\DecValTok{1}\NormalTok{],t[j]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    dfs(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{),printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6811ux4e0a-k-ux7ea7ux7956ux5148}{%
\subsection{树上 k 级祖先}\label{ux6811ux4e0a-k-ux7ea7ux7956ux5148}}

\hypertarget{onlognqlogn-ux5728ux7ebf}{%
\subsubsection{O(nlogn+qlogn) 在线}\label{onlognqlogn-ux5728ux7ebf}}

倍增

\hypertarget{onq-ux79bbux7ebf}{%
\subsubsection{O(n+q) 离线}\label{onq-ux79bbux7ebf}}

dfs过程中维护个栈

\hypertarget{onlognq-ux5728ux7ebf}{%
\subsubsection{O(nlogn+q) 在线}\label{onlognq-ux5728ux7ebf}}

\href{https://zhuanlan.zhihu.com/p/25984772}{长链剖分}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,q;}
\DataTypeTok{int}\NormalTok{ h[MAXN],son[MAXN],f[MAXN][}\DecValTok{21}\NormalTok{],bel[MAXN],mx[MAXN];}
\DataTypeTok{int}\NormalTok{ cnt,top[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} up[MAXN],down[MAXN];}
\DataTypeTok{int}\NormalTok{ highbit[MAXN];}
\DataTypeTok{void}\NormalTok{ dfs1(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa=}\DecValTok{0}\NormalTok{)}
\NormalTok{\{}
\NormalTok{    f[u][}\DecValTok{0}\NormalTok{]=fa,h[u]=h[fa]+}\DecValTok{1}\NormalTok{,son[u]=}\DecValTok{0}\NormalTok{,mx[u]=h[u];}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{    \{}
\NormalTok{        dfs1(v,u),mx[u]=max(mx[u],mx[v]);}
        \ControlFlowTok{if}\NormalTok{(mx[v]\textgreater{}mx[son[u]])son[u]=v;}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs2(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ tp)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!bel[tp])++cnt,bel[tp]=cnt,top[cnt]=tp;}
\NormalTok{    bel[u]=bel[tp];}
    \ControlFlowTok{if}\NormalTok{(son[u])dfs2(son[u],tp);}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=f[u][}\DecValTok{0}\NormalTok{]\&\&v!=son[u])dfs2(v,v);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ init()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)fd(j,}\DecValTok{20}\NormalTok{,}\DecValTok{0}\NormalTok{)}\ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}j)\&i)\{highbit[i]=j;}\ControlFlowTok{break}\NormalTok{;\}}
\NormalTok{    fp(j,}\DecValTok{1}\NormalTok{,}\DecValTok{20}\NormalTok{)fp(i,}\DecValTok{1}\NormalTok{,n)f[i][j]=f[f[i][j{-}}\DecValTok{1}\NormalTok{]][j{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,cnt)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=top[i],len=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x=u;x;x=son[x]) down[i].pb(x),len++;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x=u;x\&\&h[u]{-}h[x]\textless{}=len;x=f[x][}\DecValTok{0}\NormalTok{])up[i].pb(x);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!k)}\ControlFlowTok{return}\NormalTok{ u;}
    \DataTypeTok{int}\NormalTok{ j=highbit[k];}
\NormalTok{    u=f[u][j],k{-}=(}\DecValTok{1}\NormalTok{\textless{}\textless{}j);}
    \DataTypeTok{int}\NormalTok{ tp=top[bel[u]];}
    \ControlFlowTok{if}\NormalTok{(h[u]{-}h[tp]\textgreater{}=k) }\ControlFlowTok{return}\NormalTok{ down[bel[u]][h[u]{-}h[tp]{-}k];}
    \ControlFlowTok{else} \ControlFlowTok{return}\NormalTok{ up[bel[u]][k{-}(h[u]{-}h[tp])];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{lca}{%
\subsection{lca}\label{lca}}

\hypertarget{ux500dux589e}{%
\subsubsection{1.倍增}\label{ux500dux589e}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ lca }\CommentTok{//记得初始化 lca::n}
\NormalTok{\{}
    \CommentTok{//判断点x在u到v的路径上 {-}\textgreater{} dis(u,x)+dis(x,v)==dis(u,v)}
    \DataTypeTok{int}\NormalTok{ n,f[MAXN][}\DecValTok{25}\NormalTok{],d[MAXN];}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{    \{}
\NormalTok{        go(u)}\ControlFlowTok{if}\NormalTok{(v!=f[u][}\DecValTok{0}\NormalTok{])}
\NormalTok{            f[v][}\DecValTok{0}\NormalTok{]=u,d[v]=d[u]+}\DecValTok{1}\NormalTok{,dfs(v);}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ sz)}
\NormalTok{    \{}
\NormalTok{        n=sz,d[}\DecValTok{1}\NormalTok{]=}\DecValTok{1}\NormalTok{,dfs(}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=}\DecValTok{1}\NormalTok{;k\textless{}=}\DecValTok{20}\NormalTok{;k++)}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i\textless{}=n;i++)}
\NormalTok{                f[i][k]=f[f[i][k{-}}\DecValTok{1}\NormalTok{]][k{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{    pr query(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v) }\CommentTok{//返回\{lca(u,v),dis(u,v)\}}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ tu=u,tv=v;}
        \ControlFlowTok{if}\NormalTok{(d[u]\textless{}d[v]) swap(u,v),swap(tu,tv);}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=log2(d[u])+}\DecValTok{1}\NormalTok{;k\textgreater{}=}\DecValTok{0}\NormalTok{;k{-}{-})}
            \ControlFlowTok{if}\NormalTok{(d[f[u][k]]\textgreater{}=d[v])}
\NormalTok{                u=f[u][k];}
        \ControlFlowTok{if}\NormalTok{(u==v) }\ControlFlowTok{return}\NormalTok{ \{tv,d[tu]{-}d[tv]\};}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=log2(d[u])+}\DecValTok{1}\NormalTok{;k\textgreater{}=}\DecValTok{0}\NormalTok{;k{-}{-})}
            \ControlFlowTok{if}\NormalTok{(f[u][k]!=f[v][k])}
\NormalTok{                u=f[u][k],v=f[v][k];}
        \DataTypeTok{int}\NormalTok{ l=f[u][}\DecValTok{0}\NormalTok{];}
        \ControlFlowTok{return}\NormalTok{ \{l,d[tu]+d[tv]{-}}\DecValTok{2}\NormalTok{*d[l]\};}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ kth\_fa(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ k) }\CommentTok{//k级祖先 需保证存在}
\NormalTok{    \{}
\NormalTok{        fd(i,}\DecValTok{20}\NormalTok{,}\DecValTok{0}\NormalTok{)}\ControlFlowTok{if}\NormalTok{((}\DecValTok{1}\NormalTok{\textless{}\textless{}i)\&k)u=f[u][i];}
        \ControlFlowTok{return}\NormalTok{ u;}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ move(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ k) }\CommentTok{//u向v走k步 需保证dis(u,v)\textgreater{}=k}
\NormalTok{    \{}
\NormalTok{        pr t=query(u,v); }\DataTypeTok{int}\NormalTok{ l=t.fi;}
        \ControlFlowTok{if}\NormalTok{(d[u]{-}d[l]\textgreater{}=k)}\ControlFlowTok{return}\NormalTok{ kth\_fa(u,k);}
        \ControlFlowTok{return}\NormalTok{ kth\_fa(v,t.se{-}k);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6b27ux62c9ux5e8frmq}{%
\subsubsection{2.欧拉序+RMQ}\label{ux6b27ux62c9ux5e8frmq}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ lca }\CommentTok{//不用初始化n 。。。}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ n,seq[MAXN*}\DecValTok{2}\NormalTok{],pos[MAXN],d[MAXN],f[MAXN*}\DecValTok{2}\NormalTok{][}\DecValTok{25}\NormalTok{];}
    \DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{    \{}
\NormalTok{        seq[++n]=u,pos[u]=n;}
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(v!=fa)}
\NormalTok{            d[v]=d[u]+}\DecValTok{1}\NormalTok{,dfs(v,u),seq[++n]=u;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ S)}
\NormalTok{    \{}
\NormalTok{        n=}\DecValTok{0}\NormalTok{,d[S]=}\DecValTok{1}\NormalTok{,dfs(S,}\DecValTok{0}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)f[i][}\DecValTok{0}\NormalTok{]=seq[i];}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ k=}\DecValTok{1}\NormalTok{;(}\DecValTok{1}\NormalTok{\textless{}\textless{}k)\textless{}=n;k++)}
            \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=}\DecValTok{1}\NormalTok{;i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}k){-}}\DecValTok{1}\NormalTok{\textless{}=n;i++)}
                \ControlFlowTok{if}\NormalTok{(d[f[i][k{-}}\DecValTok{1}\NormalTok{]]\textless{}d[f[i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}(k{-}}\DecValTok{1}\NormalTok{))][k{-}}\DecValTok{1}\NormalTok{]])}
\NormalTok{                        f[i][k]=f[i][k{-}}\DecValTok{1}\NormalTok{];}
                    \ControlFlowTok{else}
\NormalTok{                        f[i][k]=f[i+(}\DecValTok{1}\NormalTok{\textless{}\textless{}(k{-}}\DecValTok{1}\NormalTok{))][k{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
    \DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(pos[v]\textless{}pos[u]) swap(u,v);}
        \DataTypeTok{int}\NormalTok{ k=log2(pos[v]{-}pos[u]+}\DecValTok{1}\NormalTok{);}
        \ControlFlowTok{if}\NormalTok{(d[f[pos[u]][k]]\textless{}d[f[pos[v]{-}(}\DecValTok{1}\NormalTok{\textless{}\textless{}k)+}\DecValTok{1}\NormalTok{][k]])}
            \ControlFlowTok{return}\NormalTok{ f[pos[u]][k];}
        \ControlFlowTok{else}
            \ControlFlowTok{return}\NormalTok{ f[pos[v]{-}(}\DecValTok{1}\NormalTok{\textless{}\textless{}k)+}\DecValTok{1}\NormalTok{][k];}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{spfa-ux5224ux8d1fux73af}{%
\subsection{Spfa 判负环}\label{spfa-ux5224ux8d1fux73af}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//找到一个从顶点1能到达的负环}
\CommentTok{//注意图不连通时负环的判断}
\DataTypeTok{int}\NormalTok{ n,m,S;}
\DataTypeTok{int}\NormalTok{ d[MAXN],in[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\DataTypeTok{int}\NormalTok{ pre[MAXN];}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,w,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e=\{edge()\};}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ w)\{e.pb(\{u,v,w,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}
\DataTypeTok{bool}\NormalTok{ spfa()}
\NormalTok{\{}
\NormalTok{    queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)d[i]=inf,vis[i]=}\DecValTok{0}\NormalTok{,in[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    d[S]=}\DecValTok{0}\NormalTok{,in[S]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    q.push(S),vis[S]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{ }
        \DataTypeTok{int}\NormalTok{ u=q.front();}
\NormalTok{        q.pop(),vis[u]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(d[u]+w\textless{}d[v])}
\NormalTok{        \{}
\NormalTok{            d[v]=d[u]+w;}
\NormalTok{            in[v]++; }\ControlFlowTok{if}\NormalTok{(in[v]\textgreater{}=n) }\ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(!vis[v]) q.push(v);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ T;}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&T);}
    \ControlFlowTok{while}\NormalTok{(T{-}{-})}
\NormalTok{    \{}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)pre[i]=}\DecValTok{0}\NormalTok{;}
\NormalTok{        e.clear(),e.pb(edge());}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ u,v,w;}
\NormalTok{            scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v,\&w);}
\NormalTok{            addedge(u,v,w);}
            \ControlFlowTok{if}\NormalTok{(w\textgreater{}=}\DecValTok{0}\NormalTok{) addedge(v,u,w);}
\NormalTok{        \}}
\NormalTok{        S=}\DecValTok{1}\NormalTok{,puts(spfa()?}\StringTok{"YE5"}\NormalTok{:}\StringTok{"N0"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux70b9ux5206ux6cbb}{%
\subsection{点分治}\label{ux70b9ux5206ux6cbb}}

\hypertarget{ux666eux901a-2}{%
\subsubsection{普通}\label{ux666eux901a-2}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,root,sum;}
\DataTypeTok{int}\NormalTok{ siz[MAXN],mx[MAXN],cnt[}\DecValTok{3}\NormalTok{];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\NormalTok{LL ans=}\DecValTok{0}\NormalTok{,d[MAXN];}

\DataTypeTok{int}\NormalTok{ pre[MAXN];}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,w,next;\};}
\NormalTok{vector\textless{}edge\textgreater{} e;}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ w)\{e.pb(\{u,v,w,pre[u]\}),pre[u]=e.size(){-}}\DecValTok{1}\NormalTok{;\}}

\DataTypeTok{void}\NormalTok{ find\_root(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa) }\CommentTok{//找重心}
\NormalTok{\{}
\NormalTok{    siz[u]=}\DecValTok{1}\NormalTok{,mx[u]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    gow(u)}\ControlFlowTok{if}\NormalTok{(v!=fa\&\&!vis[v])}
\NormalTok{    \{}
\NormalTok{        find\_root(v,u);}
\NormalTok{        siz[u]+=siz[v];}
\NormalTok{        mx[u]=max(mx[u],siz[v]);}
\NormalTok{    \}}
\NormalTok{    mx[u]=max(mx[u],sum{-}siz[u]);}
    \ControlFlowTok{if}\NormalTok{(!root||mx[u]\textless{}mx[root]) root=u;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ calc\_deep(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa) }
\NormalTok{\{}
\NormalTok{    cnt[d[u]\%}\DecValTok{3}\NormalTok{]++;}
\NormalTok{    gow(u)}\ControlFlowTok{if}\NormalTok{(v!=fa\&\&!vis[v])}
\NormalTok{        d[v]=d[u]+w,calc\_deep(v,u);}
\NormalTok{\}}
\NormalTok{LL calc(}\DataTypeTok{int}\NormalTok{ u,LL dis)}
\NormalTok{\{}
\NormalTok{    cnt[}\DecValTok{0}\NormalTok{]=cnt[}\DecValTok{1}\NormalTok{]=cnt[}\DecValTok{2}\NormalTok{]=}\DecValTok{0}\NormalTok{,d[u]=dis,calc\_deep(u,}\DecValTok{0}\NormalTok{);}
    \ControlFlowTok{return}\NormalTok{ cnt[}\DecValTok{0}\NormalTok{]*cnt[}\DecValTok{0}\NormalTok{]+}\DecValTok{2}\NormalTok{*cnt[}\DecValTok{1}\NormalTok{]*cnt[}\DecValTok{2}\NormalTok{];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    vis[u]=}\DecValTok{1}\NormalTok{,ans+=calc(u,}\DecValTok{0}\NormalTok{);}
\NormalTok{    gow(u)}\ControlFlowTok{if}\NormalTok{(!vis[v])ans{-}=calc(v,w);}
\NormalTok{    gow(u)}\ControlFlowTok{if}\NormalTok{(!vis[v])root=}\DecValTok{0}\NormalTok{,sum=siz[v],find\_root(v,u),solve(root);}
\NormalTok{\}}
\NormalTok{LL gcd(LL a,LL b)\{}\ControlFlowTok{return}\NormalTok{ b==}\DecValTok{0}\NormalTok{?a:gcd(b,a\%b);\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    e.pb(edge());}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v,w;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v,\&w);}
\NormalTok{        addedge(u,v,w),addedge(v,u,w);}
\NormalTok{    \}}
\NormalTok{    sum=n,root=}\DecValTok{0}\NormalTok{,find\_root(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{),solve(root);}
\NormalTok{    LL a=ans,b=n*n,g=gcd(a,b); a/=g,b/=g;}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{/}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,a,b);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux52a8ux6001ux70b9ux5206ux6811}{%
\subsubsection{动态(点分树)}\label{ux52a8ux6001ux70b9ux5206ux6811}}

通常套路：用数据结构维护点分树中 \(u\) 这颗子树(分治联通快)所有点到
\(u\) 的信息(\(info1\))，和所有点到 \(par[u]\)
的信息(\(info2\))用于去重。

计算答案时跳点分树用 \(info1\) 计算当前联通快内答案，用 \(info2\) 去重。

\href{https://www.luogu.com.cn/record/38642390}{震波}

求距离点 \(u\) 不超过 \(k\) 的点的点权和，单点修改。

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\KeywordTok{namespace}\NormalTok{ lca; }\CommentTok{//欧拉序lca模板}
\DataTypeTok{int}\NormalTok{ cnt,ls[N],rs[N],s[N];}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ \&x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ pos,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x)x=++cnt; }\ControlFlowTok{if}\NormalTok{(l==r)\{s[x]+=val;}\ControlFlowTok{return}\NormalTok{;\}}
    \ControlFlowTok{if}\NormalTok{(pos\textless{}=mid)update(ls[x],l,mid,pos,val);}
    \ControlFlowTok{else}\NormalTok{ update(rs[x],mid+}\DecValTok{1}\NormalTok{,r,pos,val);}
\NormalTok{    s[x]=s[ls[x]]+s[rs[x]];}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ query(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ l,}\DataTypeTok{int}\NormalTok{ r,}\DataTypeTok{int}\NormalTok{ nl,}\DataTypeTok{int}\NormalTok{ nr)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(!x||nl\textgreater{}nr||nl\textgreater{}r||nr\textless{}l)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(l==nl\&\&r==nr)}\ControlFlowTok{return}\NormalTok{ s[x];}
    \ControlFlowTok{if}\NormalTok{(nr\textless{}=mid)}\ControlFlowTok{return}\NormalTok{ query(ls[x],l,mid,nl,nr);}
    \ControlFlowTok{if}\NormalTok{(nl\textgreater{} mid)}\ControlFlowTok{return}\NormalTok{ query(rs[x],mid+}\DecValTok{1}\NormalTok{,r,nl,nr);}
    \ControlFlowTok{return}\NormalTok{ query(ls[x],l,mid,l,mid)+query(rs[x],mid+}\DecValTok{1}\NormalTok{,r,mid+}\DecValTok{1}\NormalTok{,nr);}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ n,m,root,sum;}
\DataTypeTok{int}\NormalTok{ a[MAXN],siz[MAXN],mx[MAXN],sz[MAXN];}
\DataTypeTok{int}\NormalTok{ dis[MAXN],par[MAXN],fa[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN]; vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} G[MAXN];}
\DataTypeTok{void}\NormalTok{ find\_root(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    siz[u]=}\DecValTok{1}\NormalTok{,mx[u]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(v!=fa\&\&!vis[v])find\_root(v,u),siz[u]+=siz[v],mx[u]=max(mx[u],siz[v]);}
\NormalTok{    mx[u]=max(mx[u],sum{-}siz[u]);}
    \ControlFlowTok{if}\NormalTok{(!root||mx[u]\textless{}mx[root])root=u;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ fa)}
\NormalTok{\{}
\NormalTok{    vis[u]=}\DecValTok{1}\NormalTok{; }\ControlFlowTok{if}\NormalTok{(fa)G[fa].pb(u),::fa[u]=fa;}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(!vis[v])root=}\DecValTok{0}\NormalTok{,sum=siz[v],find\_root(v,u),solve(root,u);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ update(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ val)}
\NormalTok{\{}
\NormalTok{    update(dis[u],}\DecValTok{0}\NormalTok{,sz[u],lca::dis(u,x),val);}
    \ControlFlowTok{if}\NormalTok{(fa[u])}
\NormalTok{        update(par[u],}\DecValTok{0}\NormalTok{,sz[u]+}\DecValTok{1}\NormalTok{,lca::dis(fa[u],x),val),}
\NormalTok{        update(x,fa[u],val);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ calc(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,}\DataTypeTok{int}\NormalTok{ k,}\DataTypeTok{int}\NormalTok{ \&ans)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ d=k{-}lca::dis(u,x); }
    \ControlFlowTok{if}\NormalTok{(d\textgreater{}=}\DecValTok{0}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        ans+=query(dis[u],}\DecValTok{0}\NormalTok{,sz[u],}\DecValTok{0}\NormalTok{,d);}
        \ControlFlowTok{if}\NormalTok{(v)ans{-}=query(par[v],}\DecValTok{0}\NormalTok{,sz[v]+}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,d);}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(fa[u])calc(x,fa[u],u,k,ans);}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u)\{sz[u]=}\DecValTok{1}\NormalTok{;}\ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ v:G[u])dfs(v),sz[u]+=sz[v];\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&a[i]);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&u,\&v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    sum=n,find\_root(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{);}\DataTypeTok{int}\NormalTok{ t=root;find\_root(t,}\DecValTok{0}\NormalTok{);solve(t,}\DecValTok{0}\NormalTok{);lca::init(t);dfs(t);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)update(i,i,a[i]);}
    \DataTypeTok{int}\NormalTok{ last=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(m{-}{-})}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ t,x,y;scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d}\StringTok{"}\NormalTok{,\&t,\&x,\&y);}
\NormalTok{        x\^{}=last,y\^{}=last;}
        \ControlFlowTok{if}\NormalTok{(!t) last=}\DecValTok{0}\NormalTok{,calc(x,x,}\DecValTok{0}\NormalTok{,y,last),printf(}\StringTok{"}\SpecialCharTok{\%d\textbackslash{}n}\StringTok{"}\NormalTok{,last);}
        \ControlFlowTok{else}\NormalTok{ update(x,x,{-}a[x]+y),a[x]=y;}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux5206ux56feux5339ux914d}{%
\subsection{二分图匹配}\label{ux4e8cux5206ux56feux5339ux914d}}

\hypertarget{ux6700ux5927ux6d41}{%
\subsubsection{最大流}\label{ux6700ux5927ux6d41}}

转为网络流跑 Dinic，复杂度为 \(O(\sqrt{n}m)\)，\(n=m=1e5\) 时可以考虑

\hypertarget{ux5308ux7259ux5229}{%
\subsubsection{匈牙利}\label{ux5308ux7259ux5229}}

\(O(nm)\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{int}\NormalTok{ lk[MAXN];}
\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\DataTypeTok{bool}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u)}
\NormalTok{\{}
\NormalTok{    go(u)}\ControlFlowTok{if}\NormalTok{(!vis[v])}
\NormalTok{    \{}
\NormalTok{        vis[v]=}\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(!lk[v]||dfs(lk[v]))}
\NormalTok{            \{lk[v]=u;}\ControlFlowTok{return} \DecValTok{1}\NormalTok{;\}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ solve()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)mst(vis,}\DecValTok{0}\NormalTok{),ans+=dfs(i);}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux5206ux56feux6700ux5927ux6743ux5339ux914dkm}{%
\subsection{二分图最大权匹配(KM)}\label{ux4e8cux5206ux56feux6700ux5927ux6743ux5339ux914dkm}}

\(O(N^3)\)

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\NormalTok{LL w[MAXN][MAXN],lx[MAXN],ly[MAXN],slack[MAXN];}
\DataTypeTok{int}\NormalTok{ lk[MAXN],pre[MAXN];}
\DataTypeTok{bool}\NormalTok{ visy[MAXN];}

\DataTypeTok{void}\NormalTok{ bfs(}\DataTypeTok{int}\NormalTok{ k)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ x=}\DecValTok{0}\NormalTok{,y=}\DecValTok{0}\NormalTok{,yy=}\DecValTok{0}\NormalTok{; LL delta;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)slack[i]=linf;}
\NormalTok{    mst(pre,}\DecValTok{0}\NormalTok{),lk[y]=k;}
    \ControlFlowTok{while}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        x=lk[y],delta=linf,visy[y]=}\DecValTok{1}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!visy[i])}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(slack[i]\textgreater{}lx[x]+ly[i]{-}w[x][i])}
\NormalTok{                slack[i]=lx[x]+ly[i]{-}w[x][i],pre[i]=y; }
            \ControlFlowTok{if}\NormalTok{(slack[i]\textless{}delta) delta=slack[i],yy=i;}
\NormalTok{        \}}
\NormalTok{        fp(i,}\DecValTok{0}\NormalTok{,n)}
            \ControlFlowTok{if}\NormalTok{(visy[i]) lx[lk[i]]{-}=delta,ly[i]+=delta;}
            \ControlFlowTok{else}\NormalTok{ slack[i]{-}=delta;}
\NormalTok{        y=yy;}
        \ControlFlowTok{if}\NormalTok{(lk[y]=={-}}\DecValTok{1}\NormalTok{) }\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{while}\NormalTok{(y) lk[y]=lk[pre[y]],y=pre[y];}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    mst(lx,}\DecValTok{0}\NormalTok{),mst(ly,}\DecValTok{0}\NormalTok{),mst(lk,{-}}\DecValTok{1}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n) mst(visy,}\DecValTok{0}\NormalTok{),bfs(i);}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&n)!=EOF)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)fp(j,}\DecValTok{1}\NormalTok{,n)scanf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{"}\NormalTok{,\&w[i][j]);}
\NormalTok{        solve();}
\NormalTok{        LL ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)ans+=lx[i]+ly[i];}
        \AttributeTok{static} \DataTypeTok{int}\NormalTok{ Case = }\DecValTok{0}\NormalTok{;}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e00ux822cux56feux6700ux5927ux5339ux914dux5e26ux82b1ux6811}{%
\subsection{一般图最大匹配(带花树)}\label{ux4e00ux822cux56feux6700ux5927ux5339ux914dux5e26ux82b1ux6811}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{EDGE(MAXN,MAXN*}\DecValTok{2}\NormalTok{);}
\DataTypeTok{int}\NormalTok{ n,m,ans,tim;}
\DataTypeTok{int}\NormalTok{ f[MAXN],nxt[MAXN],match[MAXN],vis[MAXN],dfn[MAXN];}
\NormalTok{queue\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} q;}
\DataTypeTok{int}\NormalTok{ find(}\DataTypeTok{int}\NormalTok{ x)\{}\ControlFlowTok{return}\NormalTok{ f[x]==x?x:f[x]=find(f[x]);\}}
\DataTypeTok{int}\NormalTok{ lca(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v)}
\NormalTok{\{}
\NormalTok{    ++tim,u=find(u),v=find(v);}
    \ControlFlowTok{while}\NormalTok{(dfn[u]!=tim)}
\NormalTok{    \{}
\NormalTok{        dfn[u]=tim;}
\NormalTok{        u=find(nxt[match[u]]);}
        \ControlFlowTok{if}\NormalTok{(v)swap(u,v);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ u;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ blossom(}\DataTypeTok{int}\NormalTok{ x,}\DataTypeTok{int}\NormalTok{ y,}\DataTypeTok{int}\NormalTok{ l)}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(find(x)!=l)}
\NormalTok{    \{}
\NormalTok{        nxt[x]=y,y=match[x];}
        \ControlFlowTok{if}\NormalTok{(vis[y]==}\DecValTok{2}\NormalTok{)vis[y]=}\DecValTok{1}\NormalTok{,q.push(y);}
        \ControlFlowTok{if}\NormalTok{(find(x)==x)f[x]=l;}
        \ControlFlowTok{if}\NormalTok{(find(y)==y)f[y]=l;}
\NormalTok{        x=nxt[y];}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ aug(}\DataTypeTok{int}\NormalTok{ S)}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)f[i]=i,vis[i]=nxt[i]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(!q.empty())q.pop();q.push(S),vis[S]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q.front(); q.pop();}
\NormalTok{        go(u)}
\NormalTok{        \{}
            \ControlFlowTok{if}\NormalTok{(find(u)==find(v)||vis[v]==}\DecValTok{2}\NormalTok{)}\ControlFlowTok{continue}\NormalTok{;}
            \ControlFlowTok{if}\NormalTok{(!vis[v])}
\NormalTok{            \{}
\NormalTok{                vis[v]=}\DecValTok{2}\NormalTok{,nxt[v]=u;}
                \ControlFlowTok{if}\NormalTok{(!match[v])}
\NormalTok{                \{}
                    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ x=v,last;x;x=last)}
\NormalTok{                        last=match[nxt[x]],match[x]=nxt[x],match[nxt[x]]=x;}
                    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{                \}}
\NormalTok{                vis[match[v]]=}\DecValTok{1}\NormalTok{,q.push(match[v]);}
\NormalTok{            \}}
            \ControlFlowTok{else}
\NormalTok{            \{}
                \DataTypeTok{int}\NormalTok{ l=lca(u,v);}
\NormalTok{                blossom(u,v,l);}
\NormalTok{                blossom(v,u,l);}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"\%d\%d"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;scanf(}\StringTok{"\%d\%d"}\NormalTok{,\&u,\&v);}
\NormalTok{        addedge(u,v),addedge(v,u);}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(!match[i])ans+=aug(i);}
\NormalTok{    printf(}\StringTok{"\%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,ans);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)printf(}\StringTok{"\%d "}\NormalTok{,match[i]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e00ux822cux56feux6700ux5927ux6743ux5339ux914d}{%
\subsection{一般图最大权匹配}\label{ux4e00ux822cux56feux6700ux5927ux6743ux5339ux914d}}

\hypertarget{ux6700ux5927ux6d41-1}{%
\subsection{最大流}\label{ux6700ux5927ux6d41-1}}

Dinic 用容量不为 0 的边构建层次图，在层次图上有方向的进行多路增广。

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,S,T;}
\KeywordTok{struct}\NormalTok{ edge}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ u,v,next;}
\NormalTok{    LL flow;}
\NormalTok{\}e[N*}\DecValTok{2}\NormalTok{];}
\DataTypeTok{int}\NormalTok{ pre[MAXN],cur[MAXN],cnt=}\DecValTok{1}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,LL flow)}
\NormalTok{\{}
\NormalTok{    e[++cnt]=\{u,v,pre[u],flow\},pre[u]=cnt;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ dis[MAXN],q[MAXN];}
\DataTypeTok{bool}\NormalTok{ bfs() }\CommentTok{//构建分层图}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ h=}\DecValTok{1}\NormalTok{,t=}\DecValTok{0}\NormalTok{;}
\NormalTok{    mst(dis,}\DecValTok{0}\NormalTok{),q[++t]=S,dis[S]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(h\textless{}=t)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q[h++];}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=pre[u];i;i=e[i].next)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ v=e[i].v;}
            \ControlFlowTok{if}\NormalTok{(!dis[v]\&\&e[i].flow)}
\NormalTok{                dis[v]=dis[u]+}\DecValTok{1}\NormalTok{,q[++t]=v;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ dis[T];}
\NormalTok{\}}
\NormalTok{LL dfs(}\DataTypeTok{int}\NormalTok{ u,LL flow) }\CommentTok{//多路增广}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(u==T||!flow)}\ControlFlowTok{return}\NormalTok{ flow;}
\NormalTok{    LL ret=}\DecValTok{0}\NormalTok{,d=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=cur[u];i;i=e[i].next)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e[i].v; cur[u]=i; }\CommentTok{//当前弧优化}
        \ControlFlowTok{if}\NormalTok{(dis[v]==dis[u]+}\DecValTok{1}\NormalTok{\&\&e[i].flow)}
\NormalTok{        \{}
\NormalTok{            d=dfs(v,min(flow{-}ret,e[i].flow));}
            \ControlFlowTok{if}\NormalTok{(d)ret+=d,e[i].flow{-}=d,e[i\^{}}\DecValTok{1}\NormalTok{].flow+=d;}
            \ControlFlowTok{if}\NormalTok{(ret==flow)}\ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{\}}
\NormalTok{LL dinic()}
\NormalTok{\{}
\NormalTok{    LL ans=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{(bfs())}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur[i]=pre[i];}
\NormalTok{        ans+=dfs(S,linf);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m,\&S,\&T);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v;LL flow;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%lld}\StringTok{"}\NormalTok{,\&u,\&v,\&flow);}
\NormalTok{        add(u,v,flow),add(v,u,}\DecValTok{0}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,dinic());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux8d39ux7528ux6d41}{%
\subsection{费用流}\label{ux8d39ux7528ux6d41}}

\hypertarget{dinic-bfsux6539ux6700ux77edux8defux7b97ux6cd5}{%
\subsubsection{1. Dinic
Bfs改最短路算法}\label{dinic-bfsux6539ux6700ux77edux8defux7b97ux6cd5}}

将 Dinic 中的 bfs
构建层次图改成最短路算法（Spfa或带势函数的Dijkstra），每次沿着最短路图的方向进行增广。

\hypertarget{spfa}{%
\paragraph{Spfa}\label{spfa}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,S,T;}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;LL flow,w;\}e[N];}
\DataTypeTok{int}\NormalTok{ pre[MAXN],cur[MAXN],cnt=}\DecValTok{1}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,LL flow,LL w)\{e[++cnt]=\{u,v,pre[u],flow,w\},pre[u]=cnt;\}}

\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\DataTypeTok{int}\NormalTok{ q[MAXN],h,t; LL dis[MAXN];}
\DataTypeTok{bool}\NormalTok{ spfa()}\CommentTok{//建议用stl queue 手写要换成循环队列防越界}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)dis[i]=linf; mst(vis,}\DecValTok{0}\NormalTok{);}
\NormalTok{    h=}\DecValTok{1}\NormalTok{,t=}\DecValTok{0}\NormalTok{,vis[S]=}\DecValTok{1}\NormalTok{,dis[S]=}\DecValTok{0}\NormalTok{,q[++t]=S;}
    \ControlFlowTok{while}\NormalTok{(h\textless{}=t)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q[(h++)\%MAXN]; vis[u]=}\DecValTok{0}\NormalTok{; }
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(e[i].flow\&\&dis[v]\textgreater{}dis[u]+w)}
\NormalTok{        \{}
\NormalTok{            dis[v]=dis[u]+w;}
            \ControlFlowTok{if}\NormalTok{(!vis[v])vis[v]=}\DecValTok{1}\NormalTok{,q[(++t)\%MAXN]=v;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ dis[T]\textless{}linf;}
\NormalTok{\}}
\NormalTok{lpr ans;}
\NormalTok{LL dfs(}\DataTypeTok{int}\NormalTok{ u,LL flow)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(u==T||!flow) }\ControlFlowTok{return}\NormalTok{ ans.fi+=flow,ans.se+=dis[u]*flow,flow;}
\NormalTok{    LL ret=}\DecValTok{0}\NormalTok{,d; vis[u]=}\DecValTok{1}\NormalTok{; }\CommentTok{//vis标记 防止在费用为 0 的边上反复跳}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=cur[u];i;i=e[i].next)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e[i].v;LL w=e[i].w; cur[u]=i;}
        \ControlFlowTok{if}\NormalTok{(e[i].flow\&\&dis[u]+w==dis[v]\&\&!vis[v])}
\NormalTok{        \{}
\NormalTok{            d=dfs(v,min(e[i].flow,flow{-}ret));}
            \ControlFlowTok{if}\NormalTok{(d) e[i].flow{-}=d,e[i\^{}}\DecValTok{1}\NormalTok{].flow+=d,ret+=d;}
            \ControlFlowTok{if}\NormalTok{(ret==flow)}\ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ mcf()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(spfa())}
\NormalTok{    \{}
\NormalTok{        mst(vis,}\DecValTok{0}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur[i]=pre[i];   }
\NormalTok{        dfs(S,linf);}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m); scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&S,\&T);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v; LL f,w;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%lld\%lld}\StringTok{"}\NormalTok{,\&u,\&v,\&f,\&w);}
\NormalTok{        add(u,v,f,w),add(v,u,}\DecValTok{0}\NormalTok{,{-}w);}
\NormalTok{    \}}
\NormalTok{    mcf();}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{ }\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans.fi,ans.se);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{dijkstra}{%
\paragraph{Dijkstra}\label{dijkstra}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,S,T;}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;LL flow,w;\}e[N];}
\DataTypeTok{int}\NormalTok{ pre[MAXN],cur[MAXN],cnt=}\DecValTok{1}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,LL flow,LL w)}
\NormalTok{\{}
\NormalTok{    e[++cnt]=\{u,v,pre[u],flow,w\},pre[u]=cnt;}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\NormalTok{LL dis[MAXN],h[MAXN];}
\DataTypeTok{bool}\NormalTok{ dij()}
\NormalTok{\{}
\NormalTok{    priority\_queue\textless{}lpr\textgreater{} q;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)dis[i]=linf;}
\NormalTok{    dis[S]=}\DecValTok{0}\NormalTok{,q.push(\{}\DecValTok{0}\NormalTok{,S\});}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q.top().se; LL d={-}q.top().fi; q.pop();}
        \ControlFlowTok{if}\NormalTok{(d!=dis[u])}\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(e[i].flow\&\&dis[u]+w+h[u]{-}h[v]\textless{}dis[v])}
\NormalTok{            dis[v]=dis[u]+w+h[u]{-}h[v],q.push(\{{-}dis[v],v\});}
\NormalTok{    \}}
    \CommentTok{//fp(i,1,n)cout\textless{}\textless{}dbgs2(i,dis[i])\textless{}\textless{}endl;}
    \ControlFlowTok{return}\NormalTok{ dis[T]\textless{}linf;}
\NormalTok{\}}
\NormalTok{lpr ans;}
\NormalTok{LL dfs(}\DataTypeTok{int}\NormalTok{ u,LL flow)}
\NormalTok{\{}
    \CommentTok{//cout \textless{}\textless{} dbgs(u) \textless{}\textless{} endl;}
    \ControlFlowTok{if}\NormalTok{(u==T||!flow) }\ControlFlowTok{return}\NormalTok{ ans.fi+=flow,ans.se+=(dis[u]+h[u])*flow,flow;}
\NormalTok{    LL ret=}\DecValTok{0}\NormalTok{,d; vis[u]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i=cur[u];i;i=e[i].next)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ v=e[i].v;LL w=e[i].w; cur[u]=i;}
        \ControlFlowTok{if}\NormalTok{(e[i].flow\&\&dis[u]+w+h[u]{-}h[v]==dis[v]\&\&!vis[v])}
\NormalTok{        \{}
\NormalTok{            d=dfs(v,min(e[i].flow,flow{-}ret));}
            \ControlFlowTok{if}\NormalTok{(d) e[i].flow{-}=d,e[i\^{}}\DecValTok{1}\NormalTok{].flow+=d,ret+=d;}
            \ControlFlowTok{if}\NormalTok{(ret==flow)}\ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ret;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ mcf()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(dij())}
\NormalTok{    \{}
\NormalTok{        mst(vis,}\DecValTok{0}\NormalTok{);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)cur[i]=pre[i];   }
\NormalTok{        dfs(S,linf);}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(dis[T]\textless{}linf)h[i]+=dis[i]; }\CommentTok{//维护势函数}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m); }
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&S,\&T);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v; LL f,w;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%lld\%lld}\StringTok{"}\NormalTok{,\&u,\&v,\&f,\&w);}
\NormalTok{        add(u,v,f,w),add(v,u,}\DecValTok{0}\NormalTok{,{-}w);}
\NormalTok{    \}}
\NormalTok{    mcf();}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{ }\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans.fi,ans.se);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ek}{%
\subsubsection{2.EK}\label{ek}}

\hypertarget{dijkstra-1}{%
\paragraph{Dijkstra}\label{dijkstra-1}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m,S,T;}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ u,v,next;LL flow,w;\}e[N];}
\DataTypeTok{int}\NormalTok{ pre[MAXN],cur[MAXN],cnt=}\DecValTok{1}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ add(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ v,LL flow,LL w)}
\NormalTok{\{}
\NormalTok{    e[++cnt]=\{u,v,pre[u],flow,w\},pre[u]=cnt;}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ vis[MAXN];}
\NormalTok{LL dis[MAXN],h[MAXN];}
\DataTypeTok{int}\NormalTok{ from[MAXN];}
\DataTypeTok{bool}\NormalTok{ dij()}
\NormalTok{\{}
\NormalTok{    priority\_queue\textless{}lpr\textgreater{} q;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)dis[i]=linf;}
\NormalTok{    dis[S]=}\DecValTok{0}\NormalTok{,q.push(\{}\DecValTok{0}\NormalTok{,S\});}
    \ControlFlowTok{while}\NormalTok{(!q.empty())}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u=q.top().se; LL d={-}q.top().fi; q.pop();}
        \ControlFlowTok{if}\NormalTok{(d!=dis[u])}\ControlFlowTok{continue}\NormalTok{;}
\NormalTok{        gow(u)}\ControlFlowTok{if}\NormalTok{(e[i].flow\&\&dis[u]+w+h[u]{-}h[v]\textless{}dis[v])}
\NormalTok{            dis[v]=dis[u]+w+h[u]{-}h[v],q.push(\{{-}dis[v],v\}),from[v]=i;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ dis[T]\textless{}linf;}
\NormalTok{\}}
\NormalTok{lpr ans;}
\DataTypeTok{void}\NormalTok{ mcf()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(dij())}
\NormalTok{    \{}
\NormalTok{        LL flow=linf;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ u=T;u!=S;u=e[from[u]].u)}
\NormalTok{            flow=min(flow,e[from[u]].flow);}
\NormalTok{        ans.fi+=flow,ans.se+=(dis[T]+h[T])*flow;}
        \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ u=T;u!=S;u=e[from[u]].u)}
\NormalTok{            e[from[u]].flow{-}=flow,}
\NormalTok{            e[from[u]\^{}}\DecValTok{1}\NormalTok{].flow+=flow;}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(dis[i]\textless{}linf)h[i]+=dis[i];}
\NormalTok{    \}}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m); }
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&S,\&T);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ u,v; LL f,w;}
\NormalTok{        scanf(}\StringTok{"}\SpecialCharTok{\%d\%d\%lld\%lld}\StringTok{"}\NormalTok{,\&u,\&v,\&f,\&w);}
\NormalTok{        add(u,v,f,w),add(v,u,}\DecValTok{0}\NormalTok{,{-}w);}
\NormalTok{    \}}
\NormalTok{    mcf();}
    \ControlFlowTok{return}\NormalTok{ printf(}\StringTok{"}\SpecialCharTok{\%lld}\StringTok{ }\SpecialCharTok{\%lld\textbackslash{}n}\StringTok{"}\NormalTok{,ans.fi,ans.se);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6b27ux62c9ux56deux8def}{%
\subsection{欧拉回路}\label{ux6b27ux62c9ux56deux8def}}

欧拉路径：奇度节点只有两个，连边做一边欧拉回路

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\KeywordTok{struct}\NormalTok{ edge\{}\DataTypeTok{int}\NormalTok{ i,next;\}t[N];}
\DataTypeTok{int}\NormalTok{ head[MAXN],cnt;}
\DataTypeTok{bool}\NormalTok{ vis[MAXN],con[MAXN];}
\DataTypeTok{int}\NormalTok{ d[MAXN];}
\NormalTok{pr e[MAXN];}
\NormalTok{vector\textless{}}\DataTypeTok{int}\NormalTok{\textgreater{} ans;}
\DataTypeTok{void}\NormalTok{ addedge(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ i)}
\NormalTok{\{}
\NormalTok{    ++cnt;}
\NormalTok{    t[cnt].i=i;}
\NormalTok{    t[cnt].next=head[u];}
\NormalTok{    head[u]=cnt;}
\NormalTok{\}}
\DataTypeTok{void}\NormalTok{ dfs(}\DataTypeTok{int}\NormalTok{ u,}\DataTypeTok{int}\NormalTok{ from)}
\NormalTok{\{}
\NormalTok{    con[u]=}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(rg }\DataTypeTok{int}\NormalTok{ k=head[u];k;k=t[k].next)}
\NormalTok{    \{}
        \DataTypeTok{int}\NormalTok{ i=t[k].i;}
        \ControlFlowTok{if}\NormalTok{(!vis[i])}
\NormalTok{        \{}
\NormalTok{            vis[i]=}\DecValTok{1}\NormalTok{;}
\NormalTok{            dfs(e[i].fi!=u?e[i].fi:e[i].se,i);}
\NormalTok{        \}}
        \ControlFlowTok{while}\NormalTok{(t[k].next\&\&vis[t[t[k].next].i])}
\NormalTok{            t[k].next=t[t[k].next].next;}
\NormalTok{    \}}
    \ControlFlowTok{if}\NormalTok{(from)ans.pb((e[from].se==u?}\DecValTok{1}\NormalTok{:{-}}\DecValTok{1}\NormalTok{)*from);}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ eula(}\DataTypeTok{int}\NormalTok{ type) }\CommentTok{// 1无向 2有向}
\NormalTok{\{}
\NormalTok{    ans.clear();}
\NormalTok{    mst(con,}\DecValTok{0}\NormalTok{),mst(vis,}\DecValTok{0}\NormalTok{),mst(head,}\DecValTok{0}\NormalTok{),mst(d,}\DecValTok{0}\NormalTok{);}
\NormalTok{    cnt=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(type==}\DecValTok{1}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            d[e[i].fi]++;}
\NormalTok{            d[e[i].se]++;}
\NormalTok{            addedge(e[i].fi,i);}
\NormalTok{            addedge(e[i].se,i);}
\NormalTok{        \}}
        \ControlFlowTok{else}
\NormalTok{        \{}
\NormalTok{            d[e[i].fi]++;}
\NormalTok{            d[e[i].se]{-}{-};}
\NormalTok{            addedge(e[i].fi,i);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(type==}\DecValTok{1}\NormalTok{)\{}\ControlFlowTok{if}\NormalTok{(d[i]\&}\DecValTok{1}\NormalTok{)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;\}}
        \ControlFlowTok{else}\NormalTok{\{}\ControlFlowTok{if}\NormalTok{(d[i]!=}\DecValTok{0}\NormalTok{)}\ControlFlowTok{return} \DecValTok{0}\NormalTok{;\}}
\NormalTok{    \}}
    \DataTypeTok{bool}\NormalTok{ flag=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(head[i]\&\&!con[i])}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(flag)dfs(i,}\DecValTok{0}\NormalTok{),flag=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{else} \ControlFlowTok{return} \DecValTok{0}\NormalTok{; }\CommentTok{//不连通}
\NormalTok{    \}}
\NormalTok{    reverse(all(ans));}
    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ type;}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{"}\NormalTok{,\&type);}
\NormalTok{    scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&n,\&m);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,m)scanf(}\StringTok{"}\SpecialCharTok{\%d\%d}\StringTok{"}\NormalTok{,\&e[i].fi,\&e[i].se);}
    \ControlFlowTok{if}\NormalTok{(!eula(type))puts(}\StringTok{"NO"}\NormalTok{);}
    \ControlFlowTok{else}
\NormalTok{    \{}
\NormalTok{        puts(}\StringTok{"YES"}\NormalTok{);}
        \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:ans)printf(}\StringTok{"}\SpecialCharTok{\%d}\StringTok{ "}\NormalTok{,x);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux8ba1ux7b97ux51e0ux4f55}{%
\section{计算几何}\label{ux8ba1ux7b97ux51e0ux4f55}}

\hypertarget{ux4e8cux7ef4ux8ba1ux7b97ux51e0ux4f55}{%
\subsection{二维计算几何}\label{ux4e8cux7ef4ux8ba1ux7b97ux51e0ux4f55}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ sgn(}\DataTypeTok{double}\NormalTok{ x)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(x\textless{}{-}eps)}\ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{(x\textgreater{} eps)}\ControlFlowTok{return}  \DecValTok{1}\NormalTok{;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\KeywordTok{struct}\NormalTok{ vec}
\NormalTok{\{}
    \DataTypeTok{double}\NormalTok{ x,y;}
\NormalTok{    vec()\{x=y=}\DecValTok{0}\NormalTok{;\}}
\NormalTok{    vec(}\DataTypeTok{double}\NormalTok{ \_x,}\DataTypeTok{double}\NormalTok{ \_y)\{x=\_x,y=\_y;\}}
\NormalTok{    vec }\KeywordTok{operator}\NormalTok{ +(vec v)\{}\ControlFlowTok{return}\NormalTok{ vec(x+v.x,y+v.y);\}}
\NormalTok{    vec }\KeywordTok{operator}\NormalTok{ {-}(vec v)\{}\ControlFlowTok{return}\NormalTok{ vec(x{-}v.x,y{-}v.y);\}}
\NormalTok{    vec }\KeywordTok{operator}\NormalTok{ *(}\DataTypeTok{double}\NormalTok{ k)\{}\ControlFlowTok{return}\NormalTok{ vec(k*x,k*y);\}}
\NormalTok{    vec }\KeywordTok{operator}\NormalTok{ /(}\DataTypeTok{double}\NormalTok{ k)\{}\ControlFlowTok{return}\NormalTok{ vec(x/k,y/k);\}}
    \DataTypeTok{double} \KeywordTok{operator}\NormalTok{ *(vec v)\{}\ControlFlowTok{return}\NormalTok{ x*v.x+y*v.y;\} }\CommentTok{//点积}
    \DataTypeTok{double}\NormalTok{ len()\{}\ControlFlowTok{return}\NormalTok{ hypot(x,y);\}}
\NormalTok{\};}

\DataTypeTok{double}\NormalTok{ cross(vec a,vec b) }\CommentTok{//叉积}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ a.x*b.y{-}a.y*b.x;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ point\_on\_seg(vec p,vec a,vec b) }\CommentTok{//点在线段上}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ sgn((p{-}a).len()+(p{-}b).len(){-}(a{-}b).len())==}\DecValTok{0}\NormalTok{;}
    \CommentTok{//return sgn(cross(b{-}a,p{-}a))==0\&\&sgn((p{-}a)*(p{-}b))\textless{}=0;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ seg\_have\_inter(vec a,vec b,vec p,vec q) }\CommentTok{//线段判交}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ d1=sgn(cross(b{-}a,p{-}a)),d2=sgn(cross(b{-}a,q{-}a));}
    \DataTypeTok{int}\NormalTok{ d3=sgn(cross(q{-}p,a{-}p)),d4=sgn(cross(q{-}p,b{-}p));}
    \ControlFlowTok{if}\NormalTok{(d1*d2\textless{}}\DecValTok{0}\NormalTok{\&\&d3*d4\textless{}}\DecValTok{0}\NormalTok{) }\ControlFlowTok{return} \DecValTok{1}\NormalTok{; }\CommentTok{//有交点且不在端点}
    \ControlFlowTok{if}\NormalTok{(}
\NormalTok{        (d1==}\DecValTok{0}\NormalTok{\&\&point\_on\_seg(p,a,b))||}
\NormalTok{        (d2==}\DecValTok{0}\NormalTok{\&\&point\_on\_seg(q,a,b))||}
\NormalTok{        (d3==}\DecValTok{0}\NormalTok{\&\&point\_on\_seg(a,p,q))||}
\NormalTok{        (d4==}\DecValTok{0}\NormalTok{\&\&point\_on\_seg(b,p,q)) }
\NormalTok{    ) }\ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{; }\CommentTok{//交在线段端点上}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ line\_parallel(vec a,vec b,vec c,vec d) }\CommentTok{//直线平行}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ sgn(cross(b{-}a,d{-}c))==}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\DataTypeTok{bool}\NormalTok{ line\_same(vec a,vec b,vec c,vec d) }\CommentTok{//直线重叠}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ line\_parallel(a,b,c,d)\&\&sgn(cross(a{-}c,a{-}d))==}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\NormalTok{vec line\_inter(vec a,vec b,vec c,vec d) }\CommentTok{//直线求交点}
\NormalTok{\{}
\NormalTok{    vec base=d{-}c;}
    \DataTypeTok{double}\NormalTok{ d1 = cross(base,a{-}c);}
    \DataTypeTok{double}\NormalTok{ d2 = cross(base,b{-}c);}
    \ControlFlowTok{return}\NormalTok{ vec(}
\NormalTok{        (a.x*d2{-}b.x*d1)/(d2{-}d1),}
\NormalTok{        (a.y*d2{-}b.y*d1)/(d2{-}d1)}
\NormalTok{    );}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux7ef4ux51f8ux5305}{%
\subsection{二维凸包}\label{ux4e8cux7ef4ux51f8ux5305}}

多边形判凸：所有点都在凸包上

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ld slope(pt x,pt y)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{(y.fi{-}x.fi==}\DecValTok{0}\NormalTok{)}\ControlFlowTok{return} \FloatTok{1.0}\NormalTok{/}\FloatTok{0.0}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ (y.se{-}x.se)/(y.fi{-}x.fi);}
\NormalTok{\}}
\NormalTok{ld dis(pt x,pt y)\{}\ControlFlowTok{return}\NormalTok{ sqrt(sqr(y.se{-}x.se)+sqr(y.fi{-}x.fi));\}}
\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    sort(all(p)),unq(p);}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:p) }\CommentTok{//求上凸包}
\NormalTok{    \{}
        \ControlFlowTok{while}\NormalTok{(u.size()\textgreater{}=}\DecValTok{2}\NormalTok{\&\&}
\NormalTok{            slope(u[u.size(){-}}\DecValTok{1}\NormalTok{],u[u.size(){-}}\DecValTok{2}\NormalTok{])\textless{}slope(u[u.size(){-}}\DecValTok{2}\NormalTok{],x))}
\NormalTok{                u.ppb();}
\NormalTok{        u.pb(x);}
\NormalTok{    \}}
\NormalTok{    reverse(all(p));}\ControlFlowTok{while}\NormalTok{(p.back()!=u.front())p.ppb();reverse(all(p));}
\NormalTok{    sort(all(p),[](}\AttributeTok{const}\NormalTok{ pt \&a,}\AttributeTok{const}\NormalTok{ pt \&b)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(a.fi!=b.fi)}\ControlFlowTok{return}\NormalTok{ a.fi\textless{}b.fi;}
        \ControlFlowTok{if}\NormalTok{(a.fi==u.front().fi)}\ControlFlowTok{return}\NormalTok{ a.se==u.front().se;}
        \ControlFlowTok{return}\NormalTok{ a.se\textgreater{}b.se;}
\NormalTok{    \});}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ x:p) }\CommentTok{//下凸包}
\NormalTok{    \{}
        \CommentTok{//cout \textless{}\textless{} dbgs2(x.fi,x.se) \textless{}\textless{} endl;}
        \ControlFlowTok{while}\NormalTok{(l.size()\textgreater{}=}\DecValTok{2}\NormalTok{\&\&slope(l[l.size(){-}}\DecValTok{1}\NormalTok{],l[l.size(){-}}\DecValTok{2}\NormalTok{])\textgreater{}}
\NormalTok{            slope(l[l.size(){-}}\DecValTok{2}\NormalTok{],x))l.ppb();}
\NormalTok{        l.pb(x);}
        \ControlFlowTok{if}\NormalTok{(x==u.back())}\ControlFlowTok{break}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux6700ux5c0fux5706ux8986ux76d6}{%
\subsection{最小圆覆盖}\label{ux6700ux5c0fux5706ux8986ux76d6}}

\begin{Shaded}
\begin{Highlighting}[]

\end{Highlighting}
\end{Shaded}

\hypertarget{ux6700ux5c0fux7403ux8986ux76d6}{%
\subsection{最小球覆盖}\label{ux6700ux5c0fux7403ux8986ux76d6}}

模拟退火 n=100

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const} \DataTypeTok{double}\NormalTok{ eps = }\FloatTok{1e{-}6}\NormalTok{;}

\DataTypeTok{int}\NormalTok{ n;}
\KeywordTok{struct}\NormalTok{ point\{}\DataTypeTok{double}\NormalTok{ x,y,z;\}p[MAXN];}

\DataTypeTok{double}\NormalTok{ dis(point a,point b)}
\NormalTok{\{}
    \ControlFlowTok{return}\NormalTok{ sqrt((a.x{-}b.x)*(a.x{-}b.x)+(a.y{-}b.y)*(a.y{-}b.y)+(a.z{-}b.z)*(a.z{-}b.z));}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{double}\NormalTok{ step = }\FloatTok{0.998}\NormalTok{;}
    \DataTypeTok{double}\NormalTok{ ans=}\FloatTok{1e20}\NormalTok{,temp=}\DecValTok{10000}\NormalTok{;}
\NormalTok{    point cur=\{}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{0}\NormalTok{\};}
    \ControlFlowTok{while}\NormalTok{(temp\textgreater{}eps)}
\NormalTok{    \{}
\NormalTok{        point far=p[}\DecValTok{1}\NormalTok{];}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n)}\ControlFlowTok{if}\NormalTok{(dis(p[i],cur)\textgreater{}dis(far,cur))far=p[i];}
        \ControlFlowTok{if}\NormalTok{(dis(far,cur)\textless{}ans)ans=dis(far,cur);}
\NormalTok{        cur.x+=(far.x{-}cur.x)*(temp/}\DecValTok{10000}\NormalTok{);}
\NormalTok{        cur.y+=(far.y{-}cur.y)*(temp/}\DecValTok{10000}\NormalTok{);}
\NormalTok{        cur.z+=(far.z{-}cur.z)*(temp/}\DecValTok{10000}\NormalTok{);}
\NormalTok{        temp*=step;}
\NormalTok{    \}}
\NormalTok{    cout \textless{}\textless{} setprecision(}\DecValTok{10}\NormalTok{) \textless{}\textless{} ans \textless{}\textless{} endl; }\CommentTok{//include\textless{}iomanip\textgreater{}}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \ControlFlowTok{while}\NormalTok{(cin \textgreater{}\textgreater{} n \&\& n)}
\NormalTok{    \{}
\NormalTok{        fp(i,}\DecValTok{1}\NormalTok{,n) cin\textgreater{}\textgreater{}p[i].x\textgreater{}\textgreater{}p[i].y\textgreater{}\textgreater{}p[i].z;}
\NormalTok{        solve();}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5176ux4ed6}{%
\section{其他}\label{ux5176ux4ed6}}

\hypertarget{ux6a21ux62dfux9000ux706b}{%
\subsection{模拟退火}\label{ux6a21ux62dfux9000ux706b}}

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{const}\NormalTok{ db T0    = }\FloatTok{1e7}\NormalTok{;}
\AttributeTok{const}\NormalTok{ db T\_end = }\FloatTok{1e{-}1}\NormalTok{;}
\AttributeTok{const}\NormalTok{ db D     = }\DecValTok{1}\NormalTok{{-}(}\FloatTok{3e{-}3}\NormalTok{);}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ L    = }\DecValTok{100}\NormalTok{;}

\NormalTok{mt19937 rng(chrono::steady\_clock::now().time\_since\_epoch().count());}

\DataTypeTok{int}\NormalTok{ n,r,ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{vector\textless{}pr\textgreater{} v;}
\DataTypeTok{int}\NormalTok{ p[}\DecValTok{10}\NormalTok{],t[}\DecValTok{10}\NormalTok{];}
\NormalTok{map\textless{}}\DataTypeTok{int}\NormalTok{,}\DataTypeTok{int}\NormalTok{\textgreater{} mn,mx;}
\DataTypeTok{int}\NormalTok{ dis(pr x,pr y)\{}\ControlFlowTok{return}\NormalTok{ sqr(x.fi{-}y.fi)+sqr(x.se{-}y.se);\}}
\DataTypeTok{int}\NormalTok{ cost(}\DataTypeTok{int}\NormalTok{ p[])}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ s=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{        fp(j,}\DecValTok{1}\NormalTok{,i{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{            s+=dis(v[p[i]],v[p[j]]);}
    \ControlFlowTok{return}\NormalTok{ s;}
\NormalTok{\}}
\KeywordTok{inline}\NormalTok{ db rand\_f()}
\NormalTok{\{}
    \AttributeTok{const} \DataTypeTok{int}\NormalTok{ MAX = }\DecValTok{1000000000}\NormalTok{;}
    \ControlFlowTok{return}\NormalTok{ db(rng()\%MAX)/db(MAX);}
\NormalTok{\}}
\KeywordTok{inline} \DataTypeTok{bool}\NormalTok{ check(db delta,db T)\{}\ControlFlowTok{return}\NormalTok{ delta\textgreater{}}\DecValTok{0}\NormalTok{||rand\_f()\textless{}exp(delta/T);\} }\CommentTok{//保证 delta\textless{}0}
\DataTypeTok{void}\NormalTok{ SA()}
\NormalTok{\{}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)p[i]=rng()\%v.size();}
    \ControlFlowTok{for}\NormalTok{(db T=T0;T\textgreater{}T\_end;T=T*D)}
\NormalTok{    \{   }
\NormalTok{        fp(tim,}\DecValTok{1}\NormalTok{,L)}
\NormalTok{        \{}
            \CommentTok{// fp(i,1,n)t[i]=(p[i]+rng())\%v.size();}
            
            \CommentTok{//构造新解}
            \DataTypeTok{int}\NormalTok{ pos=rng()\%n+}\DecValTok{1}\NormalTok{; }
\NormalTok{            t[pos]=rng()\%v.size();}

            \ControlFlowTok{if}\NormalTok{(check(cost(t){-}cost(p),T))swap(t,p);}
\NormalTok{            ans=max(\{ans,cost(t),cost(p)\});}
\NormalTok{        \}}
        \CommentTok{// cout \textless{}\textless{} dbgs2(T,cost(p)) \textless{}\textless{} endl;}
\NormalTok{    \}}
    \CommentTok{// cout \textless{}\textless{} dbgs(cost(p)) \textless{}\textless{} endl;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    v.clear(),ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,{-}r,r)mn[i]=inf,mx[i]={-}inf;}
\NormalTok{    fp(x,{-}r,r)fp(y,{-}r,r)}
        \ControlFlowTok{if}\NormalTok{(x*x+y*y\textless{}=r*r)}
\NormalTok{            mx[x]=max(mx[x],y),}
\NormalTok{            mn[x]=min(mn[x],y);}
\NormalTok{    fp(x,{-}r,r)v.pb(\{x,mn[x]\}),v.pb(\{x,mx[x]\});}
    \CommentTok{// int num=min(\{int(v.size()),4*r+10\});}
    \CommentTok{// sort(all(v),[](pr x,pr y)\{return dis(x,\{0,0\})\textgreater{}dis(y,\{0,0\});\});}
    \CommentTok{// while(v.size()\textgreater{}num)v.ppb();}
\NormalTok{    SA();}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
    \CommentTok{// freopen("output.txt", "w", stdout);}
    \CommentTok{// n=7,r=29; }
    \CommentTok{// int tim = 20;}
    \CommentTok{// while(tim{-}{-})}
        \CommentTok{// cout \textless{}\textless{} solve() \textless{}\textless{} endl;}


\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        fp(j,}\DecValTok{1}\NormalTok{,}\DecValTok{30}\NormalTok{)}
\NormalTok{        \{}
\NormalTok{            n=i,r=j;}
            \CommentTok{// cout \textless{}\textless{} dbgs3(n,r,solve()) \textless{}\textless{} endl;}
            \DataTypeTok{int}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{            fp(tim,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{                ans=max(ans,solve());}
\NormalTok{            printf(}\StringTok{"a[}\SpecialCharTok{\%d}\StringTok{][}\SpecialCharTok{\%d}\StringTok{] = }\SpecialCharTok{\%d}\StringTok{;}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{,n,r,ans);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{unordered_map-ux9632ux7206}{%
\subsection{unordered\_map 防爆}\label{unordered_map-ux9632ux7206}}

\href{https://codeforces.com/blog/entry/62393}{Blowing up
unordered\_map, and how to stop getting hacked on it}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ custom\_hash \{}
    \AttributeTok{static} \DataTypeTok{uint64\_t}\NormalTok{ splitmix64(}\DataTypeTok{uint64\_t}\NormalTok{ x) \{}
        \CommentTok{// http://xorshift.di.unimi.it/splitmix64.c}
\NormalTok{        x += }\BaseNTok{0x9e3779b97f4a7c15}\NormalTok{;}
\NormalTok{        x = (x \^{} (x \textgreater{}\textgreater{} }\DecValTok{30}\NormalTok{)) * }\BaseNTok{0xbf58476d1ce4e5b9}\NormalTok{;}
\NormalTok{        x = (x \^{} (x \textgreater{}\textgreater{} }\DecValTok{27}\NormalTok{)) * }\BaseNTok{0x94d049bb133111eb}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ x \^{} (x \textgreater{}\textgreater{} }\DecValTok{31}\NormalTok{);}
\NormalTok{    \}}

    \DataTypeTok{size\_t} \KeywordTok{operator}\NormalTok{()(}\DataTypeTok{uint64\_t}\NormalTok{ x) }\AttributeTok{const}\NormalTok{ \{}
        \AttributeTok{static} \AttributeTok{const} \DataTypeTok{uint64\_t}\NormalTok{ FIXED\_RANDOM = chrono::steady\_clock::now().time\_since\_epoch().count();}
        \ControlFlowTok{return}\NormalTok{ splitmix64(x + FIXED\_RANDOM);}
\NormalTok{    \}}
\NormalTok{\};}
\CommentTok{//Now we can simply define our unordered\_map or our gp\_hash\_table as follows:}
\NormalTok{unordered\_map\textless{}}\DataTypeTok{long} \DataTypeTok{long}\NormalTok{, }\DataTypeTok{int}\NormalTok{, custom\_hash\textgreater{} safe\_map;}
\NormalTok{gp\_hash\_table\textless{}}\DataTypeTok{long} \DataTypeTok{long}\NormalTok{, }\DataTypeTok{int}\NormalTok{, custom\_hash\textgreater{} safe\_hash\_table;}
\end{Highlighting}
\end{Shaded}

stl 更快的 hash table

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}ext/pb\_ds/assoc\_container.hpp\textgreater{}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ \_\_gnu\_pbds;}
\NormalTok{gp\_hash\_table\textless{}}\DataTypeTok{int}\NormalTok{, }\DataTypeTok{int}\NormalTok{\textgreater{} table;}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5206ux6570ux7c7b}{%
\subsection{分数类}\label{ux5206ux6570ux7c7b}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LL gcd(LL a,LL b)\{}\ControlFlowTok{return}\NormalTok{ b==}\DecValTok{0}\NormalTok{?a:gcd(b,a\%b);\}}
\KeywordTok{struct}\NormalTok{ fraction}
\NormalTok{\{}
\NormalTok{    LL a,b; }\DataTypeTok{bool}\NormalTok{ zero;}
    \DataTypeTok{void}\NormalTok{ reduce()}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(!a)\{a=b=}\DecValTok{0}\NormalTok{,zero=}\DecValTok{1}\NormalTok{;}\ControlFlowTok{return}\NormalTok{;\}}
\NormalTok{        LL g=gcd(abs(a),abs(b));a/=g,b/=g;}
\NormalTok{    \}}
\NormalTok{    fraction(LL \_a=}\DecValTok{0}\NormalTok{,LL \_b=}\DecValTok{0}\NormalTok{,}\DataTypeTok{bool}\NormalTok{ \_z=}\DecValTok{1}\NormalTok{)\{a=\_a,b=\_b,zero=\_z;\}}
    \DataTypeTok{void} \KeywordTok{operator}\NormalTok{ +=(}\AttributeTok{const}\NormalTok{ fraction \&t)\{*}\KeywordTok{this}\NormalTok{ = *}\KeywordTok{this}\NormalTok{ + t;\} }
\NormalTok{    fraction }\KeywordTok{operator}\NormalTok{ +(}\AttributeTok{const}\NormalTok{ fraction \&t)}\AttributeTok{const} 
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(zero)   }\ControlFlowTok{return}\NormalTok{ t; }
        \ControlFlowTok{if}\NormalTok{(t.zero) }\ControlFlowTok{return}\NormalTok{ *}\KeywordTok{this}\NormalTok{;}
\NormalTok{        fraction res = \{a*t.b+b*t.a,b*t.b,}\DecValTok{0}\NormalTok{\};}
\NormalTok{        res.reduce();}
        \ControlFlowTok{return}\NormalTok{ res;}
\NormalTok{    \}}
    \DataTypeTok{void} \KeywordTok{operator}\NormalTok{ {-}=(}\AttributeTok{const}\NormalTok{ fraction \&t)\{*}\KeywordTok{this}\NormalTok{ = *}\KeywordTok{this}\NormalTok{ {-} t;\} }
\NormalTok{    fraction }\KeywordTok{operator}\NormalTok{ {-}(}\AttributeTok{const}\NormalTok{ fraction \&t)}\AttributeTok{const} 
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(zero)   }\ControlFlowTok{return}\NormalTok{ t; }
        \ControlFlowTok{if}\NormalTok{(t.zero) }\ControlFlowTok{return}\NormalTok{ *}\KeywordTok{this}\NormalTok{;}
\NormalTok{        fraction res = \{a*t.b{-}b*t.a,b*t.b,}\DecValTok{0}\NormalTok{\};}
\NormalTok{        res.reduce();}
        \ControlFlowTok{return}\NormalTok{ res;}
\NormalTok{    \}}
    \DataTypeTok{void} \KeywordTok{operator}\NormalTok{ *=(}\AttributeTok{const}\NormalTok{ fraction \&t)\{*}\KeywordTok{this}\NormalTok{ = *}\KeywordTok{this}\NormalTok{ * t;\} }
\NormalTok{    fraction }\KeywordTok{operator}\NormalTok{ *(}\AttributeTok{const}\NormalTok{ fraction \&t)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(zero||t.zero)}\ControlFlowTok{return}\NormalTok{ fraction();}
\NormalTok{        fraction res = \{a*t.a,b*t.b,}\DecValTok{0}\NormalTok{\};}
\NormalTok{        res.reduce();}
        \ControlFlowTok{return}\NormalTok{ res;}
\NormalTok{    \}}
    \DataTypeTok{void} \KeywordTok{operator}\NormalTok{ /=(}\AttributeTok{const}\NormalTok{ fraction \&t)\{*}\KeywordTok{this}\NormalTok{ = *}\KeywordTok{this}\NormalTok{ / t;\} }
\NormalTok{    fraction }\KeywordTok{operator}\NormalTok{ /(}\AttributeTok{const}\NormalTok{ fraction \&t)}\AttributeTok{const}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(zero||t.zero)}\ControlFlowTok{throw}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{        fraction res = \{abs(a*t.b),abs(b*t.a),}\DecValTok{0}\NormalTok{\};}
        \ControlFlowTok{if}\NormalTok{((a\textgreater{}}\DecValTok{0}\NormalTok{)\^{}(t.a\textgreater{}}\DecValTok{0}\NormalTok{))res.a={-}res.a;}
\NormalTok{        res.reduce();}
        \ControlFlowTok{return}\NormalTok{ res;}
\NormalTok{    \}}
    \DataTypeTok{void}\NormalTok{ print()}
\NormalTok{    \{}
\NormalTok{        cout \textless{}\textless{} dbgs2(a,b) \textless{}\textless{} endl;}
\NormalTok{    \}}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{mt19937}{%
\subsection{mt19937}\label{mt19937}}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}cstdio\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}chrono\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}random\textgreater{}}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ std;}

\NormalTok{mt19937 rng(chrono::steady\_clock::now().time\_since\_epoch().count());}

\DataTypeTok{int}\NormalTok{ main()}
\NormalTok{\{}
\NormalTok{    shuffle(a, a + n, rng); }\CommentTok{//random\_shuffle()}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\%u\textbackslash{}n}\StringTok{"}\NormalTok{, rng());}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux9884ux5904ux7406log2}{%
\subsection{预处理log2}\label{ux9884ux5904ux7406log2}}

\(O(logn+n)\)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    lg2[}\DecValTok{1}\NormalTok{]=}\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{(rg }\DataTypeTok{int}\NormalTok{ i=}\DecValTok{2}\NormalTok{;i\textless{}=n;i\textless{}\textless{}=}\DecValTok{1}\NormalTok{)lg2[i]=}\DecValTok{1}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)lg2[i]+=lg2[i{-}}\DecValTok{1}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux57faux6570ux6392ux5e8f}{%
\subsection{基数排序}\label{ux57faux6570ux6392ux5e8f}}

\hypertarget{ux6a21ux677f-16}{%
\subsubsection{模板}\label{ux6a21ux677f-16}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{//二进制每8为作为一个关键字}
\AttributeTok{const} \DataTypeTok{int}\NormalTok{ N = }\DecValTok{256}\NormalTok{;}
\DataTypeTok{void}\NormalTok{ radix\_sort(}\DataTypeTok{int}\NormalTok{ a[],}\DataTypeTok{int}\NormalTok{ n)}
\NormalTok{\{}
    \AttributeTok{static} \DataTypeTok{int}\NormalTok{ r1[N],r2[N],r3[N],r4[N];}
    \AttributeTok{static} \DataTypeTok{int}\NormalTok{ t1[MAXN],t2[MAXN];}
\NormalTok{    mst(r1,}\DecValTok{0}\NormalTok{),mst(r2,}\DecValTok{0}\NormalTok{),mst(r3,}\DecValTok{0}\NormalTok{),mst(r4,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
\NormalTok{        ++r1[(a[i]    )\&}\BaseNTok{0xff}\NormalTok{]; }\CommentTok{//255}
\NormalTok{        ++r2[(a[i]\textgreater{}\textgreater{}}\DecValTok{8}\NormalTok{ )\&}\BaseNTok{0xff}\NormalTok{];}
\NormalTok{        ++r3[(a[i]\textgreater{}\textgreater{}}\DecValTok{16}\NormalTok{)\&}\BaseNTok{0xff}\NormalTok{];}
\NormalTok{        ++r4[(a[i]\textgreater{}\textgreater{}}\DecValTok{24}\NormalTok{)\&}\BaseNTok{0xff}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,N{-}}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        r1[i]+=r1[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        r2[i]+=r2[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        r3[i]+=r3[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{        r4[i]+=r4[i{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)t1[i]=i;}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)t2[r1[(a[t1[i]]    )\&}\BaseNTok{0xff}\NormalTok{]{-}{-}]=t1[i];}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)t1[r2[(a[t2[i]]\textgreater{}\textgreater{}}\DecValTok{8}\NormalTok{ )\&}\BaseNTok{0xff}\NormalTok{]{-}{-}]=t2[i];}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)t2[r3[(a[t1[i]]\textgreater{}\textgreater{}}\DecValTok{16}\NormalTok{)\&}\BaseNTok{0xff}\NormalTok{]{-}{-}]=t1[i];}
\NormalTok{    fd(i,n,}\DecValTok{1}\NormalTok{)t1[r4[(a[t2[i]]\textgreater{}\textgreater{}}\DecValTok{24}\NormalTok{)\&}\BaseNTok{0xff}\NormalTok{]{-}{-}]=t2[i];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)t1[i]=a[t1[i]];}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)a[i]=t1[i];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5f85ux8865ux821eux8e48ux94fe}{%
\subsection{(待补)舞蹈链}\label{ux5f85ux8865ux821eux8e48ux94fe}}

\hypertarget{ux52a8ux6001ux4e8cux7ef4ux6570ux7ec4}{%
\subsection{动态二维数组}\label{ux52a8ux6001ux4e8cux7ef4ux6570ux7ec4}}

\hypertarget{ux6a21ux677f-17}{%
\subsubsection{模板}\label{ux6a21ux677f-17}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{template}\NormalTok{\textless{}}\KeywordTok{class}\NormalTok{ T\textgreater{}}
\KeywordTok{class}\NormalTok{ array2 }\CommentTok{//动态二维数组}
\NormalTok{\{}
\KeywordTok{private}\NormalTok{:}
\NormalTok{    vector\textless{}vector\textless{}T\textgreater{}\textgreater{} a;}

\KeywordTok{public}\NormalTok{:}
    \DataTypeTok{void}\NormalTok{ resize(}\DataTypeTok{int}\NormalTok{ n, }\DataTypeTok{int}\NormalTok{ m)\{a.resize(n+}\DecValTok{1}\NormalTok{,vector\textless{}T\textgreater{}(m+}\DecValTok{1}\NormalTok{));\}}
    \CommentTok{//设置数组大小}

    \DataTypeTok{void}\NormalTok{ release()\{a.swap(*(}\KeywordTok{new}\NormalTok{ vector\textless{}vector\textless{}T\textgreater{}\textgreater{}));\}}
    \CommentTok{//释放空间防止MLE}

\NormalTok{    vector\textless{}T\textgreater{} \& }\KeywordTok{operator}\NormalTok{ [](}\DataTypeTok{int}\NormalTok{ row)\{}\ControlFlowTok{return}\NormalTok{ a[row];\}}

\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e8cux5206ux7b54ux6848}{%
\subsection{二分答案}\label{ux4e8cux5206ux7b54ux6848}}

\hypertarget{ux6a21ux677f-18}{%
\subsubsection{模板}\label{ux6a21ux677f-18}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ binary\_search\_result(}\DataTypeTok{int}\NormalTok{ l, }\DataTypeTok{int}\NormalTok{ r, checker check)}
\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ mid, ans = l;}
    \ControlFlowTok{while}\NormalTok{ (l \textless{}= r)}
\NormalTok{    \{}
\NormalTok{        mid = (l + r) \textgreater{}\textgreater{} }\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{ (check(mid))}
\NormalTok{            ans = mid, l = mid + }\DecValTok{1}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ r = mid {-} }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux4e09ux5206}{%
\subsection{三分}\label{ux4e09ux5206}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n;}
\DataTypeTok{double}\NormalTok{ l,r;}
\DataTypeTok{double}\NormalTok{ a[MAXN];}

\DataTypeTok{double}\NormalTok{ calc(}\DataTypeTok{double}\NormalTok{ x)}
\NormalTok{\{}
    \DataTypeTok{double}\NormalTok{ ans=}\DecValTok{0}\NormalTok{;}
\NormalTok{    fp(i,}\DecValTok{0}\NormalTok{,n)ans+=a[i]*pow(x,i);}
    \ControlFlowTok{return}\NormalTok{ ans;}
\NormalTok{\}}
\DataTypeTok{int}\NormalTok{ work()}
\NormalTok{\{}
\NormalTok{    cin \textgreater{}\textgreater{} n \textgreater{}\textgreater{} l \textgreater{}\textgreater{} r;}
\NormalTok{    fd(i,n,}\DecValTok{0}\NormalTok{)cin\textgreater{}\textgreater{}a[i];}
    \ControlFlowTok{while}\NormalTok{(fabs(r{-}l)\textgreater{}eps)}
\NormalTok{    \{}
        \DataTypeTok{double}\NormalTok{ mid1=(l+r)/}\DecValTok{2}\NormalTok{;}
        \DataTypeTok{double}\NormalTok{ mid2=(mid1+r)/}\DecValTok{2}\NormalTok{;}
        \ControlFlowTok{if}\NormalTok{(calc(mid1)\textgreater{}calc(mid2)) r=mid2;}
        \ControlFlowTok{else}\NormalTok{ l=mid1;}
\NormalTok{    \}}
\NormalTok{    cout \textless{}\textless{} fixed \textless{}\textless{} setprecision(}\DecValTok{5}\NormalTok{) \textless{}\textless{} l \textless{}\textless{} endl;}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux5355ux8c03ux6808-ux6700ux5927ux5b50ux77e9ux9635}{%
\subsection{单调栈
最大子矩阵}\label{ux5355ux8c03ux6808-ux6700ux5927ux5b50ux77e9ux9635}}

\hypertarget{ux6a21ux677f-19}{%
\subsubsection{模板}\label{ux6a21ux677f-19}}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ n,m;}
\DataTypeTok{bool}\NormalTok{ a[MAXN][MAXN],s[MAXN][MAXN];}
\DataTypeTok{int}\NormalTok{ h[MAXN],l[MAXN],r[MAXN];}
\DataTypeTok{int}\NormalTok{ ans1=}\DecValTok{0}\NormalTok{,ans2=}\DecValTok{0}\NormalTok{;}

\NormalTok{vector\textless{}pr\textgreater{} q;}

\DataTypeTok{void}\NormalTok{ init(}\DataTypeTok{int}\NormalTok{ i)}
\NormalTok{\{}
\NormalTok{    fp(j,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
        \ControlFlowTok{if}\NormalTok{(a[i][j]) h[j]=}\DecValTok{0}\NormalTok{;}
        \ControlFlowTok{else}\NormalTok{ h[j]=(a[i][j]==a[i{-}}\DecValTok{1}\NormalTok{][j])?(h[j]+}\DecValTok{1}\NormalTok{):}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    fp(j,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{    \{}
\NormalTok{        pr cur=\{h[j],j\};}
        \ControlFlowTok{while}\NormalTok{(!q.empty()\&\&cur\textless{}q.back())}
\NormalTok{            r[q.back().se]=j,q.ppb();}
\NormalTok{        q.pb(cur);}
\NormalTok{    \}}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ t:q) r[t.se]=m+}\DecValTok{1}\NormalTok{;}
\NormalTok{    q.clear();}
\NormalTok{    fd(j,m,}\DecValTok{1}\NormalTok{)}
\NormalTok{    \{}
\NormalTok{        pr cur=\{h[j],j\};}
        \ControlFlowTok{while}\NormalTok{(!q.empty()\&\&cur\textless{}q.back())}
\NormalTok{            l[q.back().se]=j,q.ppb();}
\NormalTok{        q.pb(cur);}
\NormalTok{    \}}
    \ControlFlowTok{for}\NormalTok{(}\KeywordTok{auto}\NormalTok{ t:q) l[t.se]=}\DecValTok{0}\NormalTok{;}
\NormalTok{    q.clear();}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ solve()}
\NormalTok{\{}
\NormalTok{    mst(h,}\DecValTok{0}\NormalTok{);}
\NormalTok{    fp(i,}\DecValTok{1}\NormalTok{,n)}
\NormalTok{    \{}
\NormalTok{        init(i);}
\NormalTok{        fp(j,}\DecValTok{1}\NormalTok{,m)}
\NormalTok{        \{}
            \DataTypeTok{int}\NormalTok{ w=r[j]{-}l[j]{-}}\DecValTok{1}\NormalTok{;}
\NormalTok{            ans1=max(ans1,min(h[j],w)*min(h[j],w));}
\NormalTok{            ans2=max(ans2,w*h[j]);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}


\end{document}
